<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
    <style>
    
        body {margin: 0 10% 0 10%;}
    
    </style>
</head>
<body>
   <p>JS это круто. Изо дня в день, каждый месяц, из года в год он развивается и становится лучше. Вышло и будет выходить куча библиотек и фрэймворков, написанных на нем, которые несут магию программной разработки, и это прекрасно. Фан база его юзеров растет, области применения расширяются, что делает его самым популярным языком программирования на сегодняшний день. Стать великим магом - доктором Стрэнджем в мире JS - это огромный вызов. И если получится, весь мир будет в ногах (не буквально, конечно, при этом вполне может быть обеспечено всемирное признание и уважение среди собратов). Для этого нужно обуздать, а главное - полюбить магию JS. Она не всегда понятна с самого начала и первые простенькие программы могут выдавать чудную браказябру или совсем не работать. Иногда единственная реакция на все происходящее - это дикий тупёж. Доктор Стрэндж сначала тоже лажал, не все получалось с первого раза, и, естественно, он ловил тупняк. На этом пути много тупняка. Та разум приспособится и привыкнет, помалёху начнет въезжать и понимать, что к чему. Итак, летс гоу.</p>
   
   <section>
       
       <h2>Первое, что нужно знать, когда начинаешь работать с каким-либо языком программирования: типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются одним и тем же). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object. Рассмотрим их вкратце:</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, ему по умолчанию присваивается значение undefined. Проще говоря, undefined это значение при отсуствии значения. Например, в программе используется нечто с именем "a" (пока что без конкретики). Да вот я ему не присвоил никакого значения. А значит, при вычислении "a" я знаю, что программе передается значение undefined. Хотя и не секрет, что значение undefined можно использовать намеренно при написании кода. Поэтому его использование это не только прерогатива движка JS.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе при намеренном отсуствии объектного значения (объекта или его свойства). Исторически это сложилось потому, что null принадлежит семейству объектов (это еще называют "багом" JS - typeof null <span>&#8594;</span> "object"). Итак, undefined и null это пустые значения с той разницой, что null используется при работе с объектами или с чем-то объектноподобным.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также "не-число" - NaN, или Not-a-Number (возникает в том случае, когда к обработке числового значения подключается иной тип данных и полученный результат нельзя преобразовать в число). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не более, чем 2<sup>53</sup> (т.е. существует макисмальная ведичина 2<sup>53</sup> со знаком "+", и минимальная 2<sup>53</sup> со знаком "-").</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ". И функции, о которых будет упоминаться далее, это одна из разновидностей объектов.</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
     
        <p>Строгий режим!</p>
      
       <h2>Немного об объектах</h2>
       
       <p>Здесь будет немного об свойствах и их атрибутах.</p>
       
       <p>Итак, о чем мы должны знать, прежде чем писать код?</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. Есть такие синтаксические элементы в коде, которые являются обителью значений, и им даются имена. Это обычные переменные - var, лексические переменные - let, константы - const, функции всех видов, классы, модули и импорты (пока не стоит заморачиваться, что это все такое). При вычислении кода создаются привязки имен и значений этих элементов. Поэтому в коде с помощью имени ссылаются на значение.</p> 
       
       <p>Однако, когда в коде такое имя встречается как ссылка, движок JS не определяет интуитивно, к какому элементу оно относится. В этом ему помогает лексическое окружение. Это исходит из того, что привязки принадлежат только тому лексическому окружению, в котором были созданы, а значит, они регистрируются в конкретном участке кода. Принадлежность привязки к лексическому окружению определяет то, был ли соответствующий ей элемент (а если говорить по умному - объявление) создан в области видимости этого окружения. Так что, используя имя, движок JS получает место в коде, где привязка была создана, и тем самым ее значение. Так что уникальность привязки идентифицирует не только ее имя, а еще и ее лексическое окружение. И если в кусочке программы ссылаются на имя, которое имеют две привязки, то предпочтением будет та, до лексического окружения которой поиск доберется раньше, а другая привязка для этого кусочка программы будет скрыта. Прим. В программе могут встречаться однаковые имена, так как фантазия у всех разная да и свести кое-что к одному общему виду иногда удобнее, поэтому лексическое окружение это дополнительный ориентир. И важное уточнение: именем привязки всегда является строка.</p>
       
       <p>Перед тем как начать вычисление кода внутри скрипта (тоже пока не заморачиваемся), движок JS создает глобальное лексическое окружение, внутри которого и находится весь этот код. Оно как космос - одно общее пространство для всего. А лексическое окружение, созданное при каждом отдельном вычислении в коде функций, инструкций блоков и условий Catch инструкции Try (не заморачиваемся), это как галактика внутри этого космоса. Пределы распостранения лексического окружения определяются его областью видимости. Например, когда видишь в коде функцию - ее начало и конец, - то видишь область видимости ее лексического окружения. Таким же образом работает определение области видимости для инструкций блоков и условий Catch. В случае с глобальным окружением высматривать ничего не надо: начало и конец кода внутри скрипта - это есть границы области видимости глобального окружения.</p>
       
       <p>Лексическое окружение замыкает код внутри себя, изолируя его таким образом, что он имеет доступ к "ресурсам внешнего мира", а тот, в свою очередь, не имеет доступа к "личным ресурсам" этого кода ("ресурсы" это привязки, что принадлежат конкретному лексическому окружению). Такая связь реализована с помощью ссылки на "внешний мир". Когда одно лексическое окружение находится внутри другого, это внутреннее окружение ссылается на внешнее. В отличие от глобального, конечно, где значение соответствующей ссылки - null. И внутри одного лексического окружения может находится множество других окружений. Это накладывает свои ньюансы на использование имен привязок в разных местах кода. К примеру, чтобы использовать имя привязки лексического окружения "А" в окружении "В" (а именно, чтобы привязка с таким именем была найдена и ее значение использовано по назначению), окружение "А" должно быть внешним по отношению к "В". В противном случае, сценарий выполения программы пойдет неправильным путем. Это объясняется тем, что поиск привязок по имени движется по направлению от текущего окружения к внешнему. Такой подход помогает избежать непредвиденных побочных эфектов там, где не надо. Таким образом строятся взаимосвязи и структура лексической вложенности кода.</p>
       
       ///(дальнейшее развитие событий тут уже зависит от режима строгости кода в глобальном окружении). И если код в глобальном окружении определен в строгом режиме, то программа выдаст ошибку ReferenceError. Если же код не строгий, то в глобальном объекте будет создано свойство с именем привязки, на которую ссылаются, и со значением undefined (тут уже свои мутки движка JS в зависимости от режима строгости написания кода). с возможностью их повторного использования где-то еще.  Однако, не всегда все бывает идеально и иногда в программе может проскользнуть попытка переписать значение неизменямой привязки. 
       А вот как себя поведет программа в этом случае, определяет строгость привязки. Только неизменяемые привязки могут быть строгими. Так что если в коде будет произведена попытка переписать значение строгой неизменяемой привязки, программа выдаст "error" перед тем как выполнить код (под "error" подразумевается предупреждение об ошибке). В случае такой "фигни" с не строгой неизменяемой привязкой ты узнаешь, что что-то пошло не так, "по тихому", когда программа до конца просто не выполняется, а значит, где-то там засела ошибка выполнения. Привязка определяется как строгая вне зависимости от того, используется ли она в "строгом режиме" кода, или нет (это, опять таки, предусмотривают внутренние мутки движка JS). ///
       
       <p>Поскольку каждая привязка создается в своем лексическом окружении, складывается впечатление, что оно - это контейнер, где собраны привязки, и отчасти это верно. А отчасти потому, что лексическое окружение разделяется на декларативное и объектное. И в этом смысле "контейнером" является декларативное окружение. Оно создается практически во всех случаях вычисления кода и поэтому оно самое распостраненное. Тогда как объектное окружение создается только при вычислении инструкции with и отчасти в глобальном окружении (об этом чуть позже).</p>
       
       <p>Чтобы рассмотреть каждый тип лексического окружения, сделаем небольшое отступление. Существуют привязки, значение которых можно изменить и в некоторых случаях их можно удалить (что, конечно, зависит от того, как, где и при каких условиях они используются) - это изменяемые привязки. А есть противоположные им, первоначально присвоенное значение которых нельзя изменить и их вообще нельзя удалить - это неизменяемые привязки. Суть неизменяемой привязки в том, чтобы она хранила какое-то одно значение на протяжении всего времени выполнения кода программы.</p>
       
       <p>Это все к тому, что в декларативном окружении уживаются два этих типа привязок (изменяемые и неизменяемы), имена которых напрямую связаны со значениями (так сказать, без посредников). Здесь привязка - это составляющая лексического окружения. И все имена привязок, что используются в этом окружении, будь то ссылка (имя созданного ранее объявления) или только созданное объявление, формируют его набор имен.</p>
       
       <p>Кардинально иначе ведет себя объектное окужение. Здесь уживаются только изменяемые привязки, чьим контейнером является не само окружение, а реальный объект. Хммм... Ватафак? Объектное окружение связано с объектом, в котором при выполнении кода создаются соответствующие свойства с именами и значениями объявлений, что находятся внутри области видимости этого окружения. А значит, привязками здесь являлются свойства того объекта, с которым у объектного окружения существует особая связь. Такой объект называется весьма просто - объект привязки. И поскольку значение свойств можно переписывать и сами свойства в некоторых случаях можно удалить, то и привязки здесь всегда изменяемые. А в набор имен привязок этого окружения добавляются еще имена (и только имена) всех собственных и унаследованных свойств объекта привязки. Из этого также вытекают отличия в поиске привязок по месту, поскольку в объектном окружении мониторится объект привязки, а не само окружение.</p>
       
       <p>Поскольку визуально лексическую вложенность уже определили как космос, то каждая его ветка это отдельное лексическое окружение, созданное при вычислении функций, блоков и условий Catch. А вот глобальное лексическое окружение это как ствол такого дерева - одна общая основа на всех. В JS коде всегда существует глобальное окружение, которое JS-движок создает самостоятельно, никак не выделяя. Это самое топовое окружение в коде. В глобальном окружении вместе уживаются два типа окружения: декларативное и объектное. Объектом привязки здесь является глобальный объект, поэтому тут уже заранее существует предписанный набор имен, которые взяты со свойств глобального объекта, значениями которых являются встроенные базовые объекты в JS.</p>

   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
</body> 
</html>