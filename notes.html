<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
    <style>
    
        body {margin: 0 10% 0 10%; font-size: 2rem}
        
        img {display: inline-block; width: 100%}
    
    </style>
</head>
<body>
   <p>JS это круто. Изо дня в день, каждый месяц, из года в год он развивается и становится лучше. Вышло и будет выходить куча библиотек и фрэймворков на JS, что расширяет его фан базу, области применения и делает самым популярным языком программирования на сегодняшний день. Стать доктором Стрэнджем в мире JS это огромный вызов. И если получится, можно покорять мир. Для этого нужно обуздать, а главное - полюбить магию JS. Она не всегда понятна с первого раза и первый простенький код может выдавать чудную браказябру или не работать. Иногда единственная реакция на все происходящее это дикий тупёж. Доктор Стрэндж сначала тоже ловил тупняк и, естественно, не все получалось с первого раза. Тупняка будет много та ты начнешь помалёху въезжать и понимать, что к чему. Итак, летс гоу.</p>
   
   <section>
       
       <p>Перед тем, как углублятся в дебри кода и что-то делать с js, как по мне, нужно выкупать, что происходит, когда то, что ты написал, попадает в среду своего выполнения - хост-среду. Из всех тех процессов и вызываемого ими результата мы наберемся терминологии и концепций. Таким образом, понимая, что за чем следует и при каких условиях используется, я думаю, будет проще разобраться.</p>
       
       <p>Прежде, чем непосредственно приступить к выполнению кода, произойдет целая череда процессов, чтобы подготовить необходимые условия. Первым делом, когда еще "сырой" код попадает в хост-среду (браузер и/или сервер), она создает и инициализирует (подготавливает) для него рабочую область, внутри которой он выполняется. Теперь построим ассоциации. Когда хочешь вырастить кактус, для начала его необходимо воткнуть в подходящую почву. Так вот, кактус - это код, почва - это рабочая область (или область выполнения, похер). Хост-среда должна обеспечить код всеми необходимыми ресурсами, чтобы они всегда были под рукой. Для этого и существует рабочая область - это хранилище ресурсов, которое состоит из нескольких компонентов: набора всех внутренних объектов, что изначально встроены в js ([[Intrinsics]]); глобального объекта ([[GlobalObject]]); глобального окружения ([[GlobalEnv]]); коллекции шаблонов ([[TemplateMap]]); и, возможно, дополнительных данных, предоставляемых хост-средой для своего использования ([[HostDefined]]). Рабочая область это не абстрактное понятие а реально существующая структура данных в виде объекта, которую создает хост-среда - {[[Intrinsics]]: intrinsics, [[GlobalObject]]: globObj, [[GlobalEnv]]: globEnv, [[TemplateMap]]: emptyList, [[HostDefined]]: hostValues/undefined} (realmRec).</p>
       
       <p>На этом можно было бы остановится, поскольку знание процессов при инициализации рабочей области необязательно, однако оно и не лишнее. Сначала устанавливаются все встроенные объекты ([[Intrinsics]]) внутри рабочей области. Затем создается глобальный объект. При нормальных условиях создаваемый глобальный объект это обычный расширяемый объект ([[Extensible]]: true) с прототипом Object.prototype (конечно, если иного не потребует хост-среда, что зависит от характера выполнения кода). Он устанавливаются внутри рабочей области, после чего создается глобальное окружение ([[GlobalEnv]]). Это также структура данных, состоящая из компонетов, которые создаются и инициализируются: объектного окружения ([[ObjectRecord]]), которое связано с глобальным объектом ([[GlobalObject]]); значения this, которым в основном является глобальный объект (опять-таки, при нормальных условиях, если хост-среда не потребует другой объект в качестве значения this для глобального окружения, подходящий под характер выполнения кода - [[GlobalThisValue]]); декларативного окружения ([[DeclarativeRecord]]); и списка имен переменных и функций, принадлежащих глобальному окружению (пока пустой [[VarNames]]) - {[[ObjectRecord]]: objRec, [[GlobalThisValue]]: thisObj, [[DeclarativeRecord]]: declRec, [[VarNames]]: emptyList} (globEnv). Оставшиеся компоненты рабочей области остаются в начальном состоянии. После этого глобальный объект набирается предписанных по умолчанию свойств, а их значения он получает из своей рабочей области (от [[Realm]][[Intrinsics]]).</p>
       
       <p>После того, как инициализирована рабочая область, берется каждый исходный текст, являющийся загруженным в хост-среду "сырым" кодом, и ставится в очередь на выполнение. Исходный текст определяется как скрипт или модуль, исходя из механизмов распознавания внутри хост-среды (пока что знать это не принципиально). Когда подходит очередь конкретного скрипта или модуля, первое, что происходит, это его исходный текст парсится (синтаксически анализируется).</p>
       
       <p>Когда парсится исходный текст, он анализируется на наличие в себе ошибок, которые при обнаружении не позволят запустить выполнение скрипта / модуля дальше. Однако не все ошибки, допущенные в коде, обладают такой силой. Если все благополучно и парсинг (синтаксический анализ) не выдал сюрпризов и таких ранних ошибок не обнаружено (замечу, что это именно ранние ошибки, не текущие), тогда исходный текст кода приобретает необходимую структуру для хост-среды (codeBody), напоминающуя дерево (дерево потому, что хост-среда выстраивает архитектуру кода, формируя из его структурных элементов узлы и взаимосвязи между ними, где глобальное окружение это как главный ствол дерева, а рабочая область - его корень) - это "готовый" код. Далее процессы, применяемые к скрипту и модулю отличаются.</p>
       
       <section>
          
           <h2>Что творится со скриптом</h2>
           
           <p>После успешного парсинга скрипта он становится компонентом хост-среды в виде структуры данных (script), в которой собраны такие его составляющие: "готовый" код ([[ECMAScriptCode]]), текущая рабочая область (которая была создана ранее - [[Realm]], - а значит, "готовый" код получает доступ к глобальному объекту - [[GlobalObject]], - глобальному окружению - [[GlobalEnv]], - встроенным js объектам - [[Intrinsics]] - и шаблонам js - [[TemplateMap]]), окружение (которое устанавливается для скрипта, видимо, в очень особенных случаях - [[Environment]]) и дополнительное поле для внутренних целей хост-среды ([[HostDefined]]). Изначально выглядит так: {[[Realm]]: realmRec, [[Environment]]: undefined, [[ECMAScriptCode]]: codeBody, [[HostDefined]]: hostValues/undefined} (script).</p>
       
           <p>Текущая рабочая область предоставляет глобальное лексическое окружение (это самое топовое окружение наивысшего уровня в коде - script[[Realm]][[GlobalEnv]]) для выполнения кода внутри скрипта (script[[ECMAScriptCode]]). Именно здесь из объявлений всех видов функций (обычных функций, генераторов, асинхронных функций и асинхронных генераторов), обычных переменных, классов (class) и лексических переменных (изменяемых - let, - и неизменяемых констант - const) будут создаваться глобальные привязки (это js механизм связки имени объявления с лексическим окружением, где оно было создано). Понять, какие объявления принадлежат глобальному окружению, вот как: если ты выкупаешь, что созданное объявление находится в окружении, у которого нет внешнего окружения (null), значит, - оно в глобальном окружении. Однако, есть исключения.</p>

           <p>У обычных переменных особый статус, поскольку они принадлежат лексическому окружению переменных, а в js это окружение, создаваемое функцией, модулем и глобальным окружением (и больше никаким другим!). А значит, лексическое окружение, создаваемое инструкцией блока, не "держит" в себе привязки переменных. И пусть даже будет блок, внутри которого вложены другие блоки и внутри них тоже, и в каждом из них будут объявлены переменные, их привязки, игнорируя лексическое окружение каждого блока, принадлежат окружению переменных. Так что глобальному окружению принадлежат не только переменные, объявленные в нем, а и переменные, обьявленные внутри блоков, которые непосредственно находятся в глобальном окружении (вне функций). Каждый блок создает отдельное декларативное лексическое окружение, и если оно ссылается на глобальное окружение как на внешнее, то все объявленные в нем переменные будут привязаны к глобальному окружению.</p>

           <p>Функции, лексические объявления (let, const) и классы принадлежат только тому лексическому окружению, где они объявлены. При этом функции, объявленные в глобальном окружении, принадлежат окружению переменных. Однако в версиях js до 2015 года функции, объявленные внутри блоков, ведут себя как переменные и принадлежат окружению переменных.</p>

           <p>Это все к тому, что прежде, чем создавать привязки в глобальном окружении, js необходимо их разделить, чтобы понимать, какие из объявлений принадлежат глобальному окружению переменных (обычные переменные и функции), а какие - нет (лексические переменные (let и const) и классы). А теперь еще раз вспомним, что глобальное окружение состоит из объектного (script[[Realm]][[GlobalEnv]][[ObjectRecord]]) и декларативного окружения (script[[Realm]][[GlobalEnv]][[DeclarativeRecord]]). И внимание: глобальное окружение переменных соотвествует объектному окружению, а значит, из объявлений, принадлежащих этому окружению, создаются свойства в глобальном объекте (script[[Realm]][[GlobalObject]]) в качестве их привязок к глобальному окружению. Остальные объявления рассматриваются как лексические и принадлежат глобальному декларативному окружению, где и создаются их привязки.</p>

           <p>Поэтому сначала проверяется, возможно ли создать в глобальном объекте (script[[Realm]][[GlobalObject]]) свойства из объявлений, принадлежащих глобальному окружению переменных (script[[Realm]][[GlobalEnv]][[ObjectRecord]]), или переопределить уже существующие в нем свойства, которые имеют те же имена, что и эти объявления. Для этой цели все эти объявления разделяются на функции и переменные. Функциям тоже есть чем отличится - это подымающиеся объявления и в том окружении, которому они принадлежат, сначала выстраиваются все их привязки, а потом подтягиваются остальные. Когда встречаются функции с одинаковым именем, учитывется последнее объявление такой функции (во избежание переприсваивания на начальных этапах, поскольку ее привязка инициализируется с объектом этой функции). В случае, когда проверка на свойства глобального объекта из глобальных функций выдала результат "чики-пики" (это когда все получится, бро), формируется очередь на инициализацию глобальных функций в порядке их объявления (начиная с первой и заканчивая последней). В таком порядке и будут созданы привязки из глобальных функций. К глобальным переменным относятся сами объявления переменных (var) и просто объявленные имена (без оператора var). Когда встречаются переменные с повторяющимися именами в одном окружении, привязка будет создана из первой объявленной переменной (поскольку она все-равно ининциализируется со значением undefined). Если же в глобальном объекте есть свойства с именами глобальных переменных, эти свойства будут фигурировать как привязки этих переменных в глобальном окружении. И если среди этих переменных нет таких, чьи имена встречаются среди глобальных функций (а если встречаются, то они игнорируются и привязки переменных с такими именами созданы не будут), и проверка на свойства глобального объекта из глобальных переменных тоже выдала результат "чики-пики", из них формируется очередь создания привязок в порядке их объявления. Еще раз подчеркну: сначала создаются привязки из функций, потом - из переменных. В том случае, когда проверка не выдает "чики-пики", она выдает TypeError.</p>

           <p>А теперь про "чики-пики" и TypeError. Свойства в глобальном объекте можно создать и/или переопределить (поменять) при определенных условиях. И новые, и/или обновленные свойства также будут иметь определенный набор характеристик. При условии, когда глобальный объект расширяемый ([[Extensible]]: true), без свойств с теми же именами, что имеют объявления в глобальном окружении переменных, - в нем создаются соответствующие свойства данных, которые будут перезаписваемыми ([[Writable]]: true), перечислимыми ([[Enumerable]]: true) и неизменяемыми ([[Configurable]]: false). Свойства, создаваемые из глобальных функций, получают в качестве значений объекты этих функций. А свойства, создаваемые из глобальных переменных, получают в качестве начального значения - undefined. Если объект не расширяемый ([[Extensible]]: false), будет TypeError. Если в глобальном объекте есть изменяемые ([[Configurable]]: true) свойства с именами как у глобальных функций, эти свойства будут переопределены на перезаписываемые, перечеслимые и неизменяемые с объектами этих функций в качестве значения. Если же среди таких существующих свойств попадаются неизменяемые, перезаписываемые и перечислымые свойства данных, они будут переопределены с объектами этих функций в качестве значения. Если же среди таких свойств попадаются неизменяемые свойства доступа или неизменяемые, не перезаписываемые ([[Writable]]: false) и/или не перечислимые ([[Enumerable]]: false) свойства данных, будет TypeError. Если же в глобальном объекте есть свойства, чьи имена такие же как и у глобальных переменных, то эти свойства никак не переопределяются. Поэтому, если имеющиеся условия поддерживают создание новых свойств в глобальном объекте и переопределение уже существующих в нем свойств из глобальных функций и переменных, тогда все "чики-пики". После такой проверки в глобальном окружении создаются привязки.</p>

           <p>При условии, если код выполняется в хост-среде, где крутится js выпущенный до 2015 года, есть дополнительный шаг. В этом случае, если функции, объявленные внутри блоков, под опекой глобального окружения не имеют одинаковых имен с глобальными лексическими объявлениями, с объявлениями в глобальном окружении переменных и в глобальном объекте можно создать новые свойства с именами этих функций, в нем сходу создаются соответствующие свойства со значением undefined. Они создаются по процедуре для переменных, поскольку объекты этих функций инициализируются позже. Их имена попадают в список имен переменных глобального окружения - script[[Relam]][[GlobalEnv]][[VarNames]]. После инициализации этих функций их объекты становятся значениями соответствующих свойств глобального объекта (вместо undefined). Итак, в этом исключительном случае в глобальном окружении переменных сначала создаются привязки таких функций.</p>

           <p>Из глобальных лексических объявлений создаются привязки в глобальном декларативном окружении в порядке их объявления, при этом они не инициализируются (т.е. начальное значение им пока не присваивается). Эти привязки либо изменяемые, либо неизменяемые. Если необходимо, чтобы объявление не затерли и оно хранило какое-то одно значение на протяжении всего времени выполнения кода, используется неизменяемая привязка. В остальных случаях привязки изменяемые.</p>

           <p>Затем из глобальных функций в порядке полученной очереди создаются привязки. Для каждой глобальной функции сначала инициализируется объект функции из ее глобального объявления, после чего в глобальном объекте создается свойство с именем этой функции, либо же переопределяется существующее, с перечисленными ранее характеристиками, с полученным объектом в качестве значения. Имя этой функции добавляется в список имен объявлений, что принадлежат глобальному окружению переменных - script[[Relam]][[GlobalEnv]][[VarNames]].</p>

           <p>И, напоследок, почти все то же самое для глобальных переменных. В глобальном объекте для каждой глобальной переменной создается, но не переопределяется, свойство со значением undefined и ее имя добавляется в список имен глобальных переменных - script[[Relam]][[GlobalEnv]][[VarNames]]. Если же в глобальном объекте есть уже существующее свойство, имя которого такое же, как и имя глобально объявленной переменной, оно также добавляется в этот список ([[VarNames]]).</p>

           <p>Таким образом, список имен объявлений, которые принадлежат глобальному окружению окружению переменных ([[VarNames]]), сформирован, привязки глобальных объявлений созданы и глобальное окружение ими заполнено. После этого дальнейшее вычисление кода ныряет в каждую инструкцию блока и функцию, продолжая там свое выполнение. Каждый такой блок и функция это отдельный узел анализа и выполнение кода переходит из одного узла в другой. Каждый такой узел имеет свое лексическое окружение, а глобальное окружение является общим для всех. Поэтому, только после того, как идентифицированы объявления на глобальном уровне и созданы их привязки, что привязывают эти объявления к глобальному окружению, выполнение кода ныряет вглубь.</p>
           
           <section>
               
               <h3>Ранние ошибки</h3>
               
               <p>Если же при парсинге в исходном тексте были обнаружены синтаксические ошибки или некорректные отсылки, либо сам парсинг выдавал ошибки, которые стопорят выполнение скрипта/модуля, тогда его результатом будет список из таких ошибок (SyntaxError, ReferenceError). В том случае, когда парсинг выдал ошибки и нашел ранние ошибки в коде (SyntaxError и/или ReferenceError), они регистрируются в хост-среде, после чего дальнейшее выполнение скрипта прекращается. В скрипте к таким ошибкам относятся: повторение имен лексических объявлений; если есть совпадение среди имен лексических объявлений и тех, что принадлежат окружению переменных; если в глобальном объекте есть неизменяемое свойство с таким же именем, как у глобального лексического объявления; если в коде есть инструкция eval, где есть выражение super; если в коде есть инструкция eval, где есть выражение new.target; если в коде есть инструкции, где присутствукет метки (label) с повторяющимся именем; если в коде есть инструкции, что прерывются под несуществующей меткой (break); если в коде есть инструкции, что продолжают выполнение под несуществующей меткой (continue). Во всех этих случаях тебе выкинет SyntaxError.</p>
               
               <p>Перед созданием привязок также проверяется несколько условий выше во избежание конфликта имен. Если эти условия не соблюдаются, дальнейшее выполнения скрипта стопорится.</p>
               
           </section>
           
           <section>
              
               <h3>Строгий режим</h3>
               
               <p>Помимо всех тех интересностей есть еще одна - строгий режим ("strict mode"). Код можно писать по-босяцки, без обьявления строго режима. Это дает тебе определенную свободу действий. Если же вдруг захочется обьявить строгий режим ("use strict") в глобальном окружении кода, помимо существующих ограничителей появятся дополнительные. Исходя из того, что было рассмотрено, среди них есть очень примечательные. В глобальном окружении переменных при обычном режиме позволительно (то ли по тупости, то ли специально) прописать имя, которое не встречается среди нормально объявленных переменных и присвоить ему значение. Это будет рассмотрено как обычная глобальная переменная и в глобальном объекте будет создано соответствующее свойство с этим именем. Однако при строгом режиме такое свойство в глобальном объекте создано не будет и ссылка на это имя выдаст ReferenceError.</p>
               
               <p>При обычном режиме и нормальных условиях this без значения (точнее, когда оно выдает undefined или null) указывает на глобальный объект. Однако при строгом режиме такое this не переводится в глобальный объект и оно вернет undefined (или null при сценариях, когда this это null). Если же в качестве значения this ему передается примитивное значение, оно не будет преобразовано в объект. Т.е. все значения this в этом случае воспринимаются буквально.</p>
               
               <p>Строгий режим не имеет большой популярности среди программистов, однако он используется в некоторых местах кода по умолчанию. Строгий режим имеет еще ограничения, которые будем выводить на свет постепенно.</p>
               
           </section>

       </section>
       
           <p> Если же при парсинге в исходном тексте были обнаружены синтаксические ошибки или некорректные отсылки, либо сам парсинг выдавал ошибки, которые стопорят выполнение скрипта/модуля, тогда его результатом будет список из таких ошибок (SyntaxError, ReferenceError). В том случае, когда парсинг выдал ошибки при анализе, либо ранние в коде (SyntaxError и/или ReferenceError), они регистрируются в хост-среде, после чего дальнейшее выполнение скрипта прекращается.</p>
           
       <section>

           <h2>Что творится с модулем</h2>
           
           <p>После успешного парсинга модуль становится выполняемым компонентом хост-среды. Модуль это один из составляющих элементов кода программы (как кубик в LEGO). Поэтому, помимо того, что имеет скрипт, модуль как структура данных внутри хост-среды хранит в себе информацию о своем состоянии (статусе), месте среди остальных модулей; о том, с какими модулями он связан, что он от них принимает (через импорты) и что он сам передает другим модулям (через экспорты). Из полученного "готового" кода модуля вытягиваются все модули (это запрашиваемые модули - requestedModules), откуда передаются объявления функций (всех, кроме асинхронных), обычных и лексических переменых, а также классов; все импорты (принимаемые объявления - imports) и экспорты (передаваемые объявления - local/indirect/starExports), которые он имеет. Структура данных модуля после его парсинга выглядит так: {[[Realm]]: realmRec, [[Environment]]: undefined, [[Namespace]]: undefined, [[Status]]: "unlinked", [[EvaluationError]]: undefined, [[HostDefined]]: hostValues/undefined, [[ECMAScriptCode]]: codeBody, [[RequestedModules]]: requestedModules/null, [[ImportEntries]]: imports, [[LocalExportEntries]]: localExports, [[IndirectExportEntries]]: indirectExports, [[StarExportEntries]]: starExports, [[DFSIndex]]: undefined, [[DFSAncestorIndex]]: undefined} (module).</p>
           
           <p>После парсинга запускается процесс инициализации модуля, в результате чего устанавливаются его связи с другими модулями, с которыми он связан (module[[RequestedModules]]). Изначально все модули (каждый в своем отдельном состоянии) несвязаны (module[[Status]]: "unlinked"). Когда начинается инициализация модуля (module[[Status]]: "unlinked" <span>&#8594;</span> "linking"), он первым попадает в стэк (в очередь на инициализацию). Перед тем, как инициализировать отпарсированный модуль, необходимо для начала выстроить глубинные связи с другими модулями, на которые существуют запросы. Поэтому через имеющиеся запросы (в импортах) рекурсивно извлекаются все запрашиваемые модули, которые тоже добавляются в стэк (по порядку и по вложенности). Инициализация работает по принципу LIFO: модуль, что последним попал в стэк, инициализируется первым.</p>
           
           <p>Однако стэк это временная штука, и когда все модули будут инициализированы, он опустеет. При этом формируется структура связей модуля (граф зависимостей). Чтобы понимать, в какой позиции находится модуль среди остальных в этом графе, хост-среда использует конкретный индекс (module[[DFSIndex]]). Еще есть индекс, указывающий на цыкличную зависимость в графе модуля (module[[DFSAncestorIndex]]), в результате чего формируется сильно связанный компонент. Допустим, что в графе есть предыдущий модуль (previousModule[[DFSIndex]]: x) и следующий (nextModule[[DFSIndex]]: x + y). Когда nextModule импортирует нечто из previousModule, который уже ждет инициализации (previousModule[[Status]]: "linking"), возникает цыкличная зависимость и образуется сильно связанный компонент в графе (nextModule), поскольку необходимо вернутся назад (к уровню previousModule), чтобы инициализировать nextModule (nextModule[[DFSAncestorIndex]] == previousModule[[DFSIndex]]). При условии, когда не формируется сильно связанный компонент, этот индекс соответсвует текущей позиции модуля в стэке (module[[DFSIndex]] == module[[DFSAncestorIndex]]).</p>
           
           <p>После успешной инициализации модуль становится связанным (module[[Status]]: "linking" <span>&#8594;</span> "linked"). Если инициализация выдала ошибки, все модули, начиная с того, чья инициализация накрылась, и заканчивая первым в стэке, останутся несвязаны ([[Status]]: "unlinked"), вне окружения ([[Environment]]: undefined) и вне стэка ([[DFSIndex]]: undefined и [[DFSAncestorIndex]]: undefined). При этом ранее инициализированные модули останутся связаными. И если застопорился последний модуль в стэке, это застопорит инициализацию всех модулей.</p>
           
           <p>Учитывая цыкличность всего процесса, построим простую условную схему модулей, как совокупность связанных объектов (граф). Однако сделаем небольшое отступление: когда в модуле объявляется импорт, он указывает на то, что передает и откуда (there: export something <span>&#8594;</span> import something from there), в результате чего формируется зависимость между модулем и запрашиваемым модулем (через запрос from there). Поэтому в описанной схеме условно всюду импорты, чтобы не усложнять восприятие.</p>
           
           <div><img src="img/photo_2019-06-16_11-38-38.jpg" alt="Условная схемка связей для изначального модуля"></div>
           
           <p>m это отпарсированный модуль, который первым попадает в стэк (m[[DFSIndex]]: 0 и m[[DFSAncestorIndex]]: 0). В нем есть импорт от модуля mA, который извлекается и попадает в стэк вторым (mA[[DFSIndex]]: 1 и mA[[DFSAncestorIndex]]: 1). Модуль mA формирует два направления в стэке, по одному от каждого импорта от модулей mB и mD. Сначала извлекается модуль mB, который попадает в стэк третьим (mB[[DFSIndex]]: 2 и mB[[DFSAncestorIndex]]: 2). В модуле mB также есть импорт от модуля mC, который извлекается и попадает в стэк четвертым (mC[[DFSIndex]]: 3 и mC[[DFSAncestorIndex]]: 3). Модуль mC чист (без импортов) поэтому на нем заканчивается данное направление стэка, а его окружение инициализируется первым. Условно инициализация прошла успешно: когда окружение модуля инициализировано, значит, в нем установлены привязки, формирующие связи с другими модулями. И поскольку модуль mC ни с кем не формирует сильно связанный компонент (mC[[DFSIndex]] == mC[[DFSAncestorIndex]]), он выводится из стэка. Третий модуль mB занимает его место как последний в стэке. Все повторяется, начиная от инициализации окружения модуля mB (условно успешной) и до его вывода из стэка. Теперь в стэке снова два модуля (m и mA).</p>
           
           <p>Хууух. Далее обход возвращается к модулю mA, где со второго импорта извлекается модуль mD и попадает в стэк третьим (mD[[DFSIndex]]: 2 и mD[[DFSAncestorIndex]]: 2). В нем еще два импорта от модулей mE и mF, и снова разветление стэка. Первым извлекается модуль mE, который попадает в стэк четвертым (mE[[DFSIndex]]: 3). В этом модуле есть импорт от модуля mA, что формирует сильно связанный компонент (mE[[DFSAncestorIndex]]: 1). Инициализируется окружение модуля mE, однако после этого он не выводится из стэка из-за связи с модулем mA (чтобы вывести модуль mE из стэка, необходимо сначала инициализировать модуль mA). Обход возвращается к модулю mD, извлекая из второго импорта модуль mF, который попадает в стэк последним - пятым (mF[[DFSIndex]]: 4 и mF[[DFSAncestorIndex]]: 4). Инициализируется его окружение (условно успешно) и он выводится из стэка. Затем инициализируется окружение модуля mD, однако он не выводится из стэка пока не будет инициализировано окружение модуля mA (из-за связи с модулем mF), что и происходит (в обоих случаях условно успешно). После инициализации модуля mA из стэка один за другим выводится модуль mF, mD и mA. Остается изначально отпарсированный модуль m, который успешно инициализируется и освобождает стэк (тот становится пустым, а все модули в показанной схеме - связаны).</p>
           
           <p>Рассмотрим теперь отдельно инициализацию окружения модуля, исходя из специфики построенной схемы. Условно ни в одном модуле нет условных экспортов (ре-экспорт импорта) и ни из одного модуля не экспортируется объект его пространства имен. Поэтому сразу создается декларативное окружение модуля (env), которое ссылается на глобальное окружение текущей рабочей области ([[Realm]][[GlobalEnv]]). Модуль получает окружение ([[Environment]]: env) и при условии, если в модуле присутствуют импорты, из них создаются неизменяемые лексические привязки в этом окружении (в первую очередь). Импорты передают новые привязки для своего окружения и при этом уже существующие в другом, поэтому особенность создаваемых из них привязок в том, что выстраивается "мостик", что связывет импорт (через его локальное имя) с той привязкой, которую он подхватил из модуля, в окружении которого она была локально создана (поэтому эта привязка неизменяемая). В том случае, когда импортов в модуле нет, либо их привязки уже созданы, подходит очередь для создания привязок из "готового" кода модуля. Сначала создаются привязки из переменных. Окружение модуля держит привязки объявленных в нем переменных, которые создаются с инициализируемым значением undefined. Функции, объявленные в модуле, являются лексическими объявлениями, а значит, здесь они не принадлежат окружению переменных. Затем создаются привязки из лексических объявлений (и функций в том числе). Опять-таки, они могут быть как изменяемые, так и неизменяемые, что зависит от их назначения. Из объявлений функций создаются изменяемые лексические привязки, которые инициализируются с объектами этих функций в качестве значения.</p>
           
           <p>Вот такое общее описание для инициализации окружения каждого модуля в указанной схеме. Условно все гладко и без ошибок, что прерывают внутреннее связывание модуля. Однако "жиза" бывает жестока и не все проходит так просто. Усложним теперь нашу схему, и представим, что модуль mB экспортирует свое пространство имен, а модуль mA импортирует соответствующий объект. И еще модуль mE экспортирует свою локальную привязку, которую импортирует модуль mD, которую он же потом ре-экспортирует и ее импортирует модуль mA.</p>
           
           <p>Пожалуй, начнем с самого интересного - с пространства имен модуля mB. Изначально ни один модуль не имеет в себе объект своего пространства имен ([[NameSpace]]: undefined). Модуль получает такой объект при существующей необходимости, когда его экспортируемое пространство имен импортируется в другой модуль. Итак, вернемся к схеме, где к локальным экспортам модуля mB еще добавляется условный экспорт с запросом на модуль mC. Cобираются имена всех экспортов, объявленных в модуле mB, кроме default (export default это неявно определенный экспорт, который не попадает в пространство имен модуля). Затем из имеющегося ре-экспорта извлекается модуль mC, где также собираются имена всех объявленных экспортов, кроме default. Сбор имен объявлений экспортов продолжается рекурсивно вплоть до последнего модуля без ре-экспортов (нет их, нет и запросов на другие модули). А значит, пространство имен охватывает не только экспорты своего модуля, а и тех модулей, от которых он зависим. Собранные имена используются, чтобы найти каждую локальную привязку, что передается через объявление экспорта, чье имя попало в список. Сначала поиск ведется среди экспортов в модуле mB. Ре-экспорт перекинет поиск в модуль mC. А поиск привязок, чьи экспорты не объявлены в модуле mB, продолжится в модуле mC. Суть в чем: объект пространства имен использует имена из списка экспортов в качестве ключей собственных свойств и каждое свойство этого объекта должно привести к соответствующей экспортируемой локальной привязке.</p>
           
           <p>Допустим, что в модуле mC (или в mB) есть еще один экспорт (локальный или условный) с именем "a" (их два) и они оба экспортируют разные локальные привязки - получаем неопределенность ("ambiguous"), поскольку непонятно, что все-таки экспортируется под именем "а". Если же оба локальных экспорта "а" ссылаются на одну и ту же локальную привязку (с условным экспортом это так не работает), или на разные привязки переменных (!), что имеют одинаковое имя (с условным экспортом это тоже работает), тогда все окей и в пространстве имен модуля mB будет два экспорта с одинаковым именем (во втором случае привязки взаимозаменяемые, а значит, свойство объекта пространства имен с именем "а" будет ссылаться на локальную привязку из того экспорта, что нашелся первым). Теперь допустим, что модуль mB импортирует привязку от модуля mD (при этом формируется сильно связанный компонент, да пофиг) и также ее ре-экспортирует. В обоих модулях mC и mD есть объявление локального экспорта с именем "b", которое попадет в список пространства имен два раза. И при обнаружении локальной привязки, что экспортируется под именем "b", поиск наткнется на два экспорта с одинаковым именем в разных местах - получаем неопределенность ("ambiguous"), поскольку непонятно, откуда производиться экспорт "b". Когда в модуле mB не нашли экспорта с именем "b", поиск будет искать его во всех существующих запрашиваемых модулях (потому он и продолжил поиск в модуле mD после модуля mC). Если же в модуле mB и mC (без mD) есть экспорт с именем "b", это не вызовет ошибок и оба экспорта будут в пространстве имен модуля mB (однако свойство объекта пространства имен с именем "b" будет ссылаться на локальную привязку из того экспорта, что нашелся первым, т.е. в модуле mB). Когда в модуле mB есть экспорт "b", и в запрашиваемом модуле mC тоже есть экспорт с таким же именем, тогда привязка из экспорта "b" модуля mC игнорируется (да, в объект пространства попадут имена обеих экспортов, однако ссылаться они будут на привязку, что создана в окружении модуля mB). Еще допустим, что в модуле mB нет локальной привязки, что экспортируется под именем под именем "c" - привязки не существует (null). И, наконец, допустим, что ре-экспорт "d" в модуле mB передает импорт, который ссылается на модуль mB - имеем цыкличный импорт, а значит, локальной привязки не существует (null). Экспорты, что выдают перечисленные "плохие" результаты ("ambiguous" и null), исключаются из пространства имен модуля.</p>
           
           <p>Когда все экспортируемые локальные привязки и места их обитания обнаружены, создается объект пространства имен (namespace). Он без прототипа ([[Prototype]]: null), нерасширяемый и хранит в себе инфу о том, какому модулю принадлежит ([[Module]]: mB) и какие экспорты обнаружены (собранный и отфильтрованый список имен объявлений локальных и условных экспортов каждого модуля (list) - [[Exports]]: list). Этот объект устанавливается как пространство имен модуля mB ([[Namespace]]: namespace). Каждое его свойство соответсвует найденному экспорту ([[Exports]]), перезаписываемое, перечислимое и неизменяемое ([[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: false), а в качестве значения ([[Value]]) он получает его от экспортируемой локальной привязки. В модуле mA создается лексическая неизменяемая привязка из соответствующего импорта, которая инициализируется и получает в качестве значения объект пространства имен модуля mB.</p>
           
           <p>Теперь рассмотрим случай с ре-экспортируемой привязкой из модуля mE. Ценность модуля исходит из того, что он экспортирует. Если модуль экспортирует привязку, которую нельзя обработать, это нужно определить в первую очередь. Поэтому когда в модуле, что в данный момент инициализируется, присутствует условный экспорт, проверяется, не передает ли он необрабатываемые привязки: существует ли экспортируемая привязка, не имеет ли ее локальный экспорт имя default, нет ли в модуле более одной привязки, что экспортируется под таким же именем (неопределенность). Если какое-то из условий подтвердилось, тогда выкинет SyntaxError и на этом инициализация модуля закончится. Если ничего такого нет, только тогда хост-среда начнет создавать и устанавливать лексическое окружение модуля, и делать другие штуки. Привязка импорта, создаваемая в окружении модуля mA из ре-экспортируемой локальной привязки в окружении модуля mE, создаст "мостик" между импортом в модуле mA и соответствующим локальным экспортом в модуле mE. Чтобы построить такой длинный "мостик", поиск пройдет от модуля mA до модуля mD, а оттуда из соответствующего ре-экспорта в модуль mE, в окружении которого находится экспортируемая локальная привязка. Поэтому привязка импорта, создаваемая в окружении модуля mA, получит информацию о том, в окружении какого модуля была создана дважды экспортирумая привязка и ее имя. Привязки импортов в окружении модулей mA и mD сами по себе и никак не связаны между собой.</p>
        
           <p>Итак, когда окружение каждого модуля инициализировано, последний модуль m покинул стэк и все модули, формирующие граф, связаны между собой, тогда приступает очередь выполнения кода внутри этих модулей. При условии, если один из модулей графа не закончил инициализацию и выдал ошибку (SyntaxError), внутрнее связывание прекращается, и каждый модуль, начиная с того, где все застопорилось, и вплоть до отпарсированного модуля m становится несвязаным ([[Status]]: linking <span>&#8594;</span> unlinked), без окружения ([[Environment]]: undefined) и выводится из стэка ([[DFSIndex]]: undefined и [[DFSAncestorIndex]]: undefined). При этом те модули, что попали в стэк после него, остаются связаны.</p>
           
           <p>Как и в прошлый раз, все начинается с отпарсированного модуля m, который теперь на выполнении ([[Status]]: linked <span>&#8594;</span> evaluating) и первым попадает в стэк. Все модули попадают в стэк в том же порядке как и на инициализацию. Добравшись до модуля mC, хост среда начнет его выполнение. Выполнив "готовый" код внутри него, хост-среда отмечает модуль mC как выполненный ([[Status]]: evaluating <span>&#8594;</span> evaluated) и он покидает стэк. То же самое с модулем mB. Затем, добравшись до модуля mE, выполняется только его код, он не выводится из стэка (сильно связанный компонент, что удерживает модули mA, mD и mE вместе). Затем выполняется модуль mF и выводится из стэка, после чего выполняется модуль mD и вслед за ним mA. Добравшись до модуля mA, хосте-среда выведет из стэка по-очереди модули mE, mD и напоследок mA. Далее выполняется модуль m и освобождает стэк. В результате все модули в нашей схеме выполнены.</p>
           
           <p>Когда выполняется модуль, это происходит в его контексте (т.е. модуль сам за себя ответственный). Если выполнение "готового" кода прошло гладко, модуль спокойно передаст эстафету следующему модулю в стэке. Однако, если бы в одном из модулей схемы, к примеру, mB, вылезла прерывающая ошибка (result) при выполнениие его кода, тогда это стопорнет дальнейшее выполнение модулей mA и m (mD, mE и mF вообще бы не попали в стэк), они все будут отмечены как выполненные ([[Status]]: evaluated) и каждому передастся ошибка выполнения ([[EvaluationError]]: undefined <span>&#8594;</span> result) как конечный результат. При этом модуль mC, будучи без проблем с кодом, останется выполненным и его не затронет ошибка, что распостранилась из модуля mB на другие модули ([[EvaluationError]]: undefined).</p>
           
           <p>Итак, мы рассмотрели два источника, что передают код в хост-среду - это скрипт и модуль. Если они на всем своем пути не выкинули ошибок, их выполнение успешное и можно только порадоваться. Если же ошибки были, они передаются в хост среду.</p>
           
       </section>
       
       <section>
           
           <p>Рассмотрев скрипты и модули, находится общая деталь: когда создаются привязки из объявлений функций, они инициализируются с объектом своей функции. Значит, рассмотрим, как этот объект создается. Функции это одна из разновидностей объектов, что имеют свое поведение в зависимости от того являются ли они просто функциями, просто генераторами, асинхронными функциями или асинхронными генераторфми. И это та штука, которая запускает выполнение отдельных кусков кода внутри скрипта / модуля. Начнем с просто функций (function).</p>
           
           <p></p>
           
           Если импортируются объект пространства имен запрашиваемого модуля, там создается объект (его пространство имен) со всеми этими экспортами в качестве свойств, а в окружении модуля  с импортом создается собственная неизменяемая лексическая привязка, которая инициализируется с этим объектом в качестве значения. 
       </section>
       
   </section>
   
   <section>
       
       <h2>Первое, что нужно знать, когда начинаешь работать с каким-либо языком программирования: типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются одним и тем же). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object. Рассмотрим их вкратце:</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, ему по умолчанию присваивается значение undefined. Проще говоря, undefined это значение при отсуствии значения. Например, в программе используется нечто с именем "a" (пока что без конкретики). Да вот я ему не присвоил никакого значения. А значит, при вычислении "a" я знаю, что программе передается значение undefined. Хотя и не секрет, что значение undefined можно использовать намеренно при написании кода. Поэтому его использование это не только прерогатива движка JS.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе при намеренном отсуствии объектного значения (объекта или его свойства). Исторически это сложилось потому, что null принадлежит семейству объектов (это еще называют "багом" JS - typeof null <span>&#8594;</span> "object"). Итак, undefined и null это пустые значения с той разницой, что null используется при работе с объектами или с чем-то объектноподобным.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также "не-число" - NaN, или Not-a-Number (возникает в том случае, когда к обработке числового значения подключается иной тип данных и полученный результат нельзя преобразовать в число). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не более, чем 2<sup>53</sup> (т.е. существует макисмальная ведичина 2<sup>53</sup> со знаком "+", и минимальная 2<sup>53</sup> со знаком "-").</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ". И функции, о которых будет упоминаться далее, это одна из разновидностей объектов.</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
     
        <p>Строгий режим!</p>
      
       <h2>Немного об объектах</h2>
       
       <p>Здесь будет немного об свойствах и их атрибутах.</p>
       
       <p>Итак, о чем мы должны знать, прежде чем писать код?</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. В коде JS есть синтаксические элементы, которые являются обителью значений, и им даются имена. Это обычные переменные (var), лексические переменные (let), константы (const), функции всех видов, классы, модули и импорты (пока не стоит заморачиваться, что это все такое). Каждый такой элемент имеет свою роль, которая возлагается на его значение. И когда в каком-то участке кода необходимо использовать значение конкретного элемента, используется имя, с которым это значение связано. Т.е. имя это посредник между значением и тем участком кода. Однако не будет лишним прояснить несколько моментов. Связь имя-значение реализовывают привязки. Они связывают имя и значение. Пэтому с помощью имени ссылаются на значение. 
       
       Когда они прописываются в коде (а если говорить по умному - объявляются), имена помогают не только опознать их. Однако после этого имя может быть использовано в других местах кода. является посредником между значением и местом в коде, где это значение необходимо использовать. Имя используется как ссылка и с его помощью ссылаются на значение. После того, как такие элементы прописывается в коде, его имя можно использовать в разных участках этого кода, если там используется необходимое значение При вычислении кода, чтобы связать их имя и значение, движок JS создает привязки из этих элементов. Кроме этого, привязки еще цепляют такие элементы к лексическому окружению.</p> 
       
       Итак, что происходит: когда в коде прописываются такие элементы, то при его вычислении из их имен и значений создаются привязки.
       
       <p>Однако, когда в коде такое имя встречается как ссылка, движок JS не определяет интуитивно, к какому элементу оно относится. В этом ему помогает лексическое окружение. Это исходит из того, что привязки принадлежат только тому лексическому окружению, в котором были созданы, а значит, они регистрируются в конкретном участке кода. Принадлежность привязки к лексическому окружению определяет то, был ли соответствующий ей элемент (а если говорить по умному - объявление) создан в области видимости этого окружения. Так что, используя имя, движок JS получает место в коде, где привязка была создана, и тем самым ее значение. Так что уникальность привязки идентифицирует не только ее имя, а еще и ее лексическое окружение. И если в кусочке программы ссылаются на имя, которое имеют две привязки, то предпочтением будет та, до лексического окружения которой поиск доберется раньше, а другая привязка для этого кусочка программы будет скрыта. Прим. В программе могут встречаться однаковые имена, так как фантазия у всех разная да и свести кое-что к одному общему виду иногда удобнее, поэтому лексическое окружение это дополнительный ориентир. И важное уточнение: именем привязки всегда является строка.</p>
       
       <p>Перед тем как начать вычисление кода внутри скрипта (тоже пока не заморачиваемся), движок JS создает глобальное лексическое окружение, внутри которого и находится весь этот код. В самом коде также создается отдельное лексическое окружение всякий раз при каждом вычислении функции, инструкции блоков и условия Catch инструкции Try (не заморачиваемся) каждый раз . Пределы распостранения лексического окружения определяются его областью видимости. Например, когда видишь в коде функцию - ее начало и конец, - то видишь область видимости ее лексического окружения. Таким же образом работает определение области видимости для инструкций блоков и условий Catch. В случае с глобальным окружением высматривать ничего не надо: начало и конец кода внутри скрипта - это есть границы области видимости глобального окружения.</p>
       
       <p>Лексическое окружение замыкает код внутри себя, изолируя его таким образом, что он имеет доступ к "ресурсам внешнего мира", а тот, в свою очередь, не имеет доступа к "личным ресурсам" этого кода ("ресурсы" это привязки, что принадлежат конкретному лексическому окружению). Такая связь реализована с помощью ссылки на "внешний мир". Когда одно лексическое окружение находится внутри другого, это внутреннее окружение ссылается на внешнее. В отличие от глобального, конечно, где значение соответствующей ссылки - null. И внутри одного лексического окружения может находится множество других окружений. Это накладывает свои ньюансы на использование имен привязок в разных местах кода. К примеру, чтобы использовать имя привязки лексического окружения "А" в окружении "В" (а именно, чтобы привязка с таким именем была найдена и ее значение использовано по назначению), окружение "А" должно быть внешним по отношению к "В". В противном случае, сценарий выполения программы пойдет неправильным путем. Это объясняется тем, что поиск привязок по имени движется по направлению от текущего окружения к внешнему. Такой подход помогает избежать непредвиденных побочных эфектов там, где не надо. Таким образом строятся взаимосвязи и структура лексической вложенности кода.</p>
       
       ///(дальнейшее развитие событий тут уже зависит от режима строгости кода в глобальном окружении). И если код в глобальном окружении определен в строгом режиме, то программа выдаст ошибку ReferenceError. Если же код не строгий, то в глобальном объекте будет создано свойство с именем привязки, на которую ссылаются, и со значением undefined (тут уже свои мутки движка JS в зависимости от режима строгости написания кода). с возможностью их повторного использования где-то еще.  Однако, не всегда все бывает идеально и иногда в программе может проскользнуть попытка переписать значение неизменямой привязки. 
       А вот как себя поведет программа в этом случае, определяет строгость привязки. Только неизменяемые привязки могут быть строгими. Так что если в коде будет произведена попытка переписать значение строгой неизменяемой привязки, программа выдаст "error" перед тем как выполнить код (под "error" подразумевается предупреждение об ошибке). В случае такой "фигни" с не строгой неизменяемой привязкой ты узнаешь, что что-то пошло не так, "по тихому", когда программа до конца просто не выполняется, а значит, где-то там засела ошибка выполнения. Привязка определяется как строгая вне зависимости от того, используется ли она в "строгом режиме" кода, или нет (это, опять таки, предусмотривают внутренние мутки движка JS). ///
       
       <p>Поскольку каждая привязка создается в своем лексическом окружении, складывается впечатление, что оно - это контейнер, где собраны привязки, и отчасти это верно. А отчасти потому, что лексическое окружение разделяется на декларативное и объектное. И в этом смысле "контейнером" является декларативное окружение. Оно создается практически во всех случаях вычисления кода и поэтому оно самое распостраненное. Тогда как объектное окружение создается только при вычислении инструкции with и отчасти в глобальном окружении (об этом чуть позже).</p>
       
       <p>Чтобы рассмотреть каждый тип лексического окружения, сделаем небольшое отступление. Существуют привязки, значение которых можно изменить и в некоторых случаях их можно удалить (что, конечно, зависит от того, как, где и при каких условиях они используются) - это изменяемые привязки. А есть противоположные им, первоначально присвоенное значение которых нельзя изменить и их вообще нельзя удалить - это неизменяемые привязки. Суть неизменяемой привязки в том, чтобы она хранила какое-то одно значение на протяжении всего времени выполнения кода программы.</p>
       
       <p>Это все к тому, что в декларативном окружении уживаются два этих типа привязок (изменяемые и неизменяемы), имена которых напрямую связаны со значениями (так сказать, без посредников). Здесь привязка - это составляющая лексического окружения. И все имена привязок, что используются в этом окружении, будь то ссылка (имя созданного ранее объявления) или только созданное объявление, формируют его набор имен.</p>A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.
       
       <p>Кардинально иначе ведет себя объектное окужение. Здесь уживаются только изменяемые привязки, чьим контейнером является не само окружение, а реальный объект. Хммм... Ватафак? Объектное окружение связано с объектом, в котором при выполнении кода создаются соответствующие свойства с именами и значениями объявлений, что находятся внутри области видимости этого окружения. А значит, привязками здесь являлются свойства того объекта, с которым у объектного окружения существует особая связь. Такой объект называется весьма просто - объект привязки. И поскольку значение свойств можно переписывать и сами свойства в некоторых случаях можно удалить, то и привязки здесь всегда изменяемые. А в набор имен привязок этого окружения добавляются еще имена (и только имена) всех собственных и унаследованных свойств объекта привязки. Из этого также вытекают отличия в поиске привязок по месту, поскольку в объектном окружении мониторится объект привязки, а не само окружение.</p>
       
       <p>Поскольку визуально лексическую вложенность уже определили как космос, то каждая его ветка это отдельное лексическое окружение, созданное при вычислении функций, блоков и условий Catch. А вот глобальное лексическое окружение это как ствол такого дерева - одна общая основа на всех. В JS коде всегда существует глобальное окружение, которое JS-движок создает самостоятельно, никак не выделяя. Это самое топовое окружение в коде. В глобальном окружении вместе уживаются два типа окружения: декларативное и объектное. Объектом привязки здесь является глобальный объект, поэтому тут уже заранее существует предписанный набор имен, которые взяты со свойств глобального объекта, значениями которых являются встроенные базовые объекты в JS.</p>

   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
    
    
           <p>А теперь небольшое отступление о модулях. Модуль это универсальная штука, где можно хранить кусок кода для других модулей и скриптов, используя его многократно, чтобы не дублировать. Таким образом, если надо внести изменения одним махом в тех местах, где этот кусок используется, то достаточно залезть в конкретный модуль и сделать все там. Так что весьма удобно по возможности разбить код программы на модули.</p>
           
</body> 
</html>