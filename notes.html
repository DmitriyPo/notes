<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
</head>
<body>
   <p>JS это круто. Изо дня в день, каждый месяц, из года в год он развивается и становится лучше. Вышло и будет выходить куча библиотек и фрэймворков, написанных на нем, которые несут магию программной разработки, и это прекрасно. Фан база его юзеров растет, области применения расширяются, что делает его самым популярным языком программирования на сегодняшний день. Стать великим магом - доктором Стрэнджем в мире JS - это огромный вызов. И если получится, весь мир будет в ногах (не буквально, конечно, при этом вполне может быть обеспечено всемирное признание и уважение среди собратов). Для этого нужно обуздать, а главное - полюбить магию JS. Она не всегда понятна с самого начала и первые простенькие программы могут выдавать чудную браказябру или совсем не работать. Иногда единственная реакция на все происходящее - это дикий тупёж. Доктор Стрэндж сначала тоже лажал, не все получалось с первого раза, и, естественно, он ловил тупняк. На этом пути много тупняка. Та разум приспособится и привыкнет, помалёху начнет въезжать и понимать, что к чему. Итак, летс гоу.</p>
   
   <section>
       
       <h2>Первое, что нужно знать, когда начинаешь работать с каким-либо языком программирования: типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются одним и тем же). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object. Рассмотрим их вкратце:</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, ему по умолчанию присваивается значение undefined. Проще говоря, undefined это значение при отсуствии значения. Например, в программе используется нечто с именем "a" (пока что без конкретики). Да вот я ему не присвоил никакого значения. А значит, при вычислении "a" я знаю, что программе передается значение undefined. Хотя и не секрет, что значение undefined можно использовать намеренно при написании кода. Поэтому его использование это не только прерогатива движка JS.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе при намеренном отсуствии объектного значения (объекта или его свойства). Исторически это сложилось потому, что null принадлежит семейству объектов (это еще называют "багом" JS - typeof null <span>&#8594;</span> "object"). Итак, undefined и null это пустые значения с той разницой, что null не возникает по умолчанию и используется при работе с объектами.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также "не-число" - NaN, или Not-a-Number (возникает в том случае, когда к обработке числового значения подключается иной тип данных и полученный результат нельзя преобразовать в число). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не более, чем 2<sup>53</sup> (т.е. существует макисмальная ведичина 2<sup>53</sup> со знаком "+", и минимальная 2<sup>53</sup> со знаком "-").</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ". И функции, о которых будет упоминаться далее, это одна из разновидностей объектов.</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
     
        <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. С помощью имени на значение можно сослаться. А иначе оно потеряется среди остальных. Представь, что ты попал в город с безымянными улицами и домами, где все жители немые и глухие. Если построить ассоциации, то значение это как энергия, которой просякнута вселенная. Поговорим об этом. В JS есть синтаксические элементы, которым присваивается одно значение. используют имя для идентификаИмя дается не значению, а Это так, что на значение можно сослаться с помощью имени, поскольку между именем и значением существует связь. </p>
      
       <h2>Немного об объектах</h2>
       
       <p>Здесь будет немного об свойствах и их атрибутах.</p>
       
       <p>Итак, о чем мы должны знать, прежде чем писать код?</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. Есть такие синтаксические элементы в коде, которые являются обителью значений, и им даются имена. Это обычные переменные - var, лексические переменные - let, константы - const, функции всех видов, классы, модули и импорты (пока не стоит заморачиваться, что это все такое). Когда они прописываются в коде (а если говорить по умному - объявляются), то при их вычислении создаются соответствующие привязки имен и значений этих объявлений. Привязка действует на подобии свойства объекта, связывая имя и значение. Поэтому имя привязки в коде работает как ссылка и с его помощью ссылаются на значение. Однако это не означает, что все имена, которые ты раздаешь таким элементам при написании кода, должны быть уникальными. В конце концов, фантазия у всех разная да и свести кое-что к одному общему виду иногда удобнее. Это означает, что в программе могут встречаться однаковые имена. Только вот как в таком случае ей различить, на какое значение ссылается повторяющееся имя? Определить это помогает лексическое окружение.</p>
       
       <p>Привязки принадлежат только тому лексическому окружению, в котором они были созданы, а значит, они регистрируются в конкретном участке кода с возможностью их повторного использования где-то еще в коде (хотя тут есть свои правила). Так что роль лексического окружения при обработке имени можно сравнить с координатами на карте: движок JS получает то место в коде, где привязка с определенным именем была создана, а значит, и значение, которое ей соответствует. И если в кусочке программы в качетсве ссылки используется имя, которое имеют две привязки, то предпочтением будет та, до лексического окружения которой поиск доберется раньше, а другая привязка для этого кусочка программы будет скрыта. Итак, уникальность привязки идентифицирует не только имя, а еще и ее лексическое окружение. И важное уточнение: именем привязки всегда является строка.</p>
       
       <div>
           
           <p>Лексическое окружение создается:</p>
           <ol>
               <li>в начале вычисления общего кода, когда движок JS создает глобальное лексическое окружение, внутри которого и находится весь код;</li>
               <li>при каждом отдельном вычислении в программе функций, инструкций блоков и условий Catch инструкции Try.</li>
           </ol>
           <p>Пределы его распостранения определяются областью видимости (например, когда видишь в коде функцию - ее начало и конец, - то видишь область видимости ее лексического окружения). Лексическое окружение замыкает код внутри себя, изолируя его таким образом, что он имеет доступ к "ресурсам внешнего мира", а тот, в свою очередь, не имеет доступа к "личным ресурсам" этого кода. Такая связь реализовывается с помощью ссылки на "внешний мир". Когда одно лексическое окружение находится внутри другого, это внутреннее окружение ссылается на внешнее. И внутри одного лексического окружения может находится множество других окружений. Именно эта особенность лексического окружения накладывает ограничения на использование имен привязок в других местах кода. К примеру, когда имя привязки лексического окружения "А" используется в окружении "В", то, чтобы задум сработал, окружение "А" должно быть внешним по отношению к "В". В противном случае в окружении "B" такая привязка будет определена как несуществующая. Это, конечно, спровоцирует ее поиск во внешнем окружении "В", и, не найдя там, во внешнем окружении внешнего и так далее до конечной точки - глобального окружения (тут уже свои мутки движка JS в зависимости от режима строгости написания кода). Так что использование имен привязок работает "как надо" по месту и вглубь кода, поскольку их поиск движется по направлению от текущего окружения к внешнему. Это помогает каждому такому замкнутому фрагменту кода выполнять свою роль, не вызывая непредвиденных побочных эфектов в тех местах кода, которые принадлежат другому лексическому окружению (например, "соседу", или внешнему). Таким образом строятся взаимосвязи и структура лексической вложенности кода, которую можно сравнить с деревом.</p>
           
       </div>
       
       <p>Исходя из вышесказанного, создается впечатление, что лексическое окружение это контейнер, где собраны привязки, и отчасти это верно. А отчасти потому, что лексическое окружение разделяется на декларативное и объектное. И это верно только для декларативного окружения. Оно создается практически во всех случаях вычисления кода и поэтому является самым распостраненным. Привязки бывают изменяемыми и неизменяемыми. В первом случае, им можно переприсвоить другое значение и, если это предусмотривает движок JS, их можно удалить. Во втором случае, первоначально присвоенное им значение нельзя изменить; они не удаляемые и, если это предусмотрено программой, строгие (строгая привязка означает, что при попытке переписать ее значение программа наявно выдаст "error"). В декларативном окружении уживаются два этих типа привязок, где их имена напрямую свзяаны со значениями (так сказать, без посредников).</p>
       
       <p>А вот объектное окружение создается только при вычислении инструкции with и отчасти в глобальном окружении (об этом позже). Здесь уживаются только изменяемые привязки, которые являются свойствами объекта. Хммм... Ватафак? Объектное окружение связано с объектом - это объект привязки. Эта связь реализована таким образом, что когда в области видимости этого окружения создается какое-нибудь объявление, то при вычислении кода это сопровождается созданием соответствующего свойства в объекте привязки. И имя, и значение свойства опять-таки соответствуют тем, что имеет объявление. Так что создаваемые привязки в этом окужении это свойства в данном объекте.</p>
       
       <p>/// Привязка - это составляющая лексического окружения. И если объект это контейнер, где собраны свойства, то лексическое окружение - это контейнер, где собраны привязки.</p>
       
       <p>Возможность использования в коде, что замкнут внутри области видимости лексического окружения, привязок из внешнего окружения, если оно существует, немного напоминает наследование свойств в объектах. Такая способность создает в лексичском окружении набор имен, среди которых есть имена собственных и, возможно, "унаследованных" привязок. </p>
       
       <p>Поскольку визуально лексическую вложенность кода можно определить как дерево, то каждая его ветка это отдельное лексическое окружение, созданное при вычислении кода. А вот глобальное лексическое окружение это как ствол такого дерева - одна общая основа на всех. В JS коде всегда существует глобальное лексическое окружение, которое JS-движок создает самостоятельно, никак не выделяя. Оно не имеет внешнего окружения, поэтому очевидное значение соответствующей ссылки - null. Чтобы рассмотреть глобальное окружение, для начала необходимо рассмотреть еще некоторые ньюансы лексического окружения.</p>
       
       <p>А вот объектное окружение создается при вычислении инструкции with и отчасти в глобальном окружении (об этом позже). Здесь создаются только изменяемые привязки, и они - это свойства объекта. Хммм... Объектное окружение связано с объектом - это объект привязки. Эта связь реализована таким образом, что когда в области видимости этого окружения создается какое-нибудь объявление, то при вычислении кода это сопровождается созданием соответствующего свойства в объекте привязки. И имя, и значение свойства опять-таки соответствуют тем, что имеет объявление. Так что создаваемые привязки в этом окужении это свойства в данном объекте.</p>
       
Декларативное это окружение, где привязка идентификатора создается через объявление, что находится в области видимсоти. В программе JS объявляются переменные var, переменные let и константы const (это лексические объявления), классы, модули, импорты и функции. происходит объявление в котором привязки идентификаторов напрямую связываются со значениями. выполняет привязку набора идентификаторов, что определены объявлениями, что содержатся внутри его области видимости. связано с областью видимости программы, где содержатся объявления переменных var и let, констант const, классов, модулей, импортов и/или функций.
      
      Декларативное окружение является основным и непосредственно/напрямую связывает привязки идентификаторов со значениями. А есть еще объектное окружение. Оно используется в инструкции with и отчасти в глобальном окружении (об этом позже). Суть такова: есть реальный объект, где движок JS создает свойства, которые соответствуют объявлениям внутри инструкции with. Имена объявлений регистрируются как ключи свойств. А значения объявлений присваиваются этим свойствам. Так что эти свойства и являются привязками: здесь привязки идентификаторов связываются со свойствами некоторого объекта, который называется объектом привязки. Объектное окружение связывает набор имен идентификаторв в виде строки, что напрямую соответссвуют именам свойств объекта привязки. Собственные и унаследованные свойства этого объекта содержатся в наборе. Ключ свойтсва, что не является строкой (как символ), не принадлежит набору. Набор идентификаторов может менятся, поскольку свойства могту как добавлятся в объект так и удалятся из него. Все такие привязки изменяемые. 
       
   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
</body> 
</html>