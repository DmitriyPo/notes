<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
</head>
<body>
   <p>JS это круто. Изо дня в день, каждый месяц, из года в год он развивается и становится лучше. Вышло и будет выходить куча библиотек и фрэймворков, написанных на нем, которые несут магию программной разработки, и это прекрасно. Стать великим магом - доктором Стрэнджем в мире JS - это огромный вызов. И если получится, весь мир будет в ногах (не буквально, конечно, при этом вполне может быть обеспечено всемирное признание и уважение среди собратов). Для этого нужно приручить, обуздать и, наконец, полюбить магию. Она не всегда понятна с самого начала и первые заклятия могут выдавать чудную браказябру или совсем не работать. Иногда единственная реакция на все происходящее - это дикий тупёж. Доктор Стрэндж сначала тоже лажал, не все получалось с первого раза, и, естественно, он ловил тупняк. На этом пути много тупняка. Та не надо боятся. Тело и разум приспособятся и привыкнут, помалёху начнут прокачиваться, въезжать и понимать, что к чему. Итак, летс гоу.</p>
   
   <section>
       
       <h2>Типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются синонимами). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object.</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью его имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, этот идентификатор по умолчанию получит значение undefined. Проще говоря, undefined это значение при отсуствии значения.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе в тех случаях, когда идентификатору надобно бы присвоить значение в виде объекта (или его свойства), а его нет. Проще говоря, null это значение при намеренном отсуствии объектного значения. Исторически это сложилось потому, что typeof null <span>&#8594;</span> "object".
           Итак, undefined и null это пустые значения с той разницой, что null сам по себе не возникает и используется при работе с объектами.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также NaN (Not-a-Number). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не больше, чем 2<sup>53</sup>.</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов с определенным значением. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ".</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее косвенно упоминалось про идентификаторы (они же зарегистрированные имена в коде) и их роль: к ним привязываются значения. Эта связь между именем и значением является привязкой. Она сама по себе не существует как рыбка Дори до встречи с Нэмо. Все привязки регистрируются и существуют в лексическом окружении, в пределах его области видимости (она устанавливает границы распостранения лексического окружения).</p>
       
       <p>Лексическое окружение это особенная составляющая магии, которую кодеру надо прочувствовать. Все, что находится в коде JSКод JS имеет вложенную структуру, что можно представить в виде дерева: есть общий для всех ствол, на котором держится код - это глобальное окружение, - каждая ветка - это отдельное лексическое окружение, созданное определенными составляющими синтаксиса JS, - а листик - это то, что не создает лексического окружения. Поэтому код JS имеет вложенную структуру, что определяет логику построения кода: какие синтаксические элементы находятся внутри других таких элементов и к какому лексическому окружению они принадлежат.</p>
       
       <p>Почти каждое лексическое окружение находится внутри другого и ссылается на него. Только глобальное окружение, которое является общей обителью всего, что есть в коде, не имеет внешнего окружения (в его случае значением соответствующей ссылки является null). Лексическое окружение создается каждый раз, когда вычисляется объявление функции (функция это особенная рановидность объектов), инструкция блока и условие Catch инструкции Try (все это будет рассмотрено позже). Во внешнем лексическом окружении может находится множество внутренних. Ссылка на внешнее лексическое окружение моделирует логику вложенности значений лексического окружения.</p>
       
       <p>Глобальное окружение не имеет внешнего окружения.</p>
       
   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
</body> 
</html>