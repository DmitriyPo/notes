<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
    <style>
    
        body {margin: 0 10% 0 10%; font-size: 2rem}
        
        img {display: inline-block; width: 100%}
    
    </style>
</head>
<body>
   <p>JS это круто. Изо дня в день, каждый месяц, из года в год он развивается и становится лучше. Вышло и будет выходить куча библиотек и фрэймворков на нем, фан база растет, области применения расширяются, что делает его самым популярным языком программирования на сегодняшний день. Стать доктором Стрэнджем в мире JS это огромный вызов. И если получится, можно покорять мир. Для этого нужно обуздать, а главное - полюбить магию JS. Она не всегда понятна с первого раза и первый простенький код может выдавать чудную браказябру или не работать. Иногда единственная реакция на все происходящее это дикий тупёж. Доктор Стрэндж сначала тоже ловил тупняк и, естественно, не все получалось с первого раза. Тупняка будет много та ты начнешь помалёху въезжать и понимать, что к чему. Итак, летс гоу.</p>
   
   <section>
       
       <p>Перед тем, как углублятся в дебри кода и что-то делать с js, как по мне, нужно выкупать, что происходит, когда то, что ты написал, попадает в среду своего выполнения. Из всех тех процессов и вызываемого ими результата мы наберемся терминологии и концепций, которые потом рассмотрим отдельно. Таким образом, понимая, что за чем следует и при каких условиях используется, я думаю, будет проще разобраться.</p>
       
       <p>Прежде, чем непосредственно приступить к выполнению кода, произойдет целая череда процессов, чтобы подготовить необходимые условия. Первым делом, когда еще "сырой" код попадает в среду своего выполнения (браузер и/или сервер), она создает и инициализирует (подготавливает) для него рабочую область, внутри которой он выполняется. Теперь построим ассоциации. Когда хочешь вырастить кактус, для начала его необходимо воткнуть в подходящую почву. Так вот, кактус - это код, почва - это рабочая область (или область выполнения, похер). Среда выполнения (ну или иными словами, хост-среда) должна обеспечить код всеми необходимыми ресурсами, чтобы они всегда были у него под рукой. Для этого и существует рабочая область - это хранилище ресурсов, которое состоит из нескольких компонентов: набора всех внутренних объектов, что изначально встроены в js ([[Intrinsics]]); глобального объекта ([[GlobalObject]]); глобального окружения ([[GlobalEnv]]); коллекции шаблонов ([[TemplateMap]]); и, возможно, дополнительных данных, предоставляемых средой выполнения для своего использования ([[HostDefined]]).</p>
       
       <p>На этом можно было бы остановится, поскольку знание процессов при инициализации рабочей области необязательно, однако оно и не лишнее. Сначала устанавливаются все встроенные объекты внутри рабочей области и начальное состояние ее остальных компонентов. Затем создается глобальный объект. При нормальных условиях создаваемый глобальный объект это обычный расширяемый объект ([[Extensible]]: true) с прототипом Object.prototype (конечно, если иного не потребует хост-среда, что зависит от характера выполнения кода). Он устанавливаются внутри рабочей области, после чего создается глобальное окружение. Оно также состоит из компонетов: объектного окружения, где объектом привязки является глобальный объект ([[ObjectRecord]]); значения this, которым в основном является глобальный объект (опять-таки, при нормальных условиях, если хост-среда не потребует другой объект в качестве значения глобального this, подходящий под характер выполнения кода - [[GlobalThisValue]]); декларативного окружения ([[DeclarativeRecord]]); и списка имен переменных и функций, принадлежащих глобальному окружению (пока пустой [[VarNames]]), - которые создаются и инициализируются. Оставшиеся компоненты рабочей области остаются в прежнем состоянии. После этого глобальный объект набирается свойств, предписанных по умолчанию, а их значения он получает из встроенных объектов своей рабочей области (от [[Intrinsics]]).</p>
       
       <p>После того, как инициализирована рабочая область, берется каждый исходный текст, являющийся загруженным в хост-среду "сырым" кодом, и ставится в очередь выполнения по принципу FIFO - первым вошел, первым вышел. Исходный текст определяется как скрипт или модуль, исходя из его расширения (.js для скрипта и .mjs - для модуля). Когда подходит очередь конкретного скрипта или модуля, первое, что происходит, это его исходный текст парсится (синтаксически анализируется).</p>
       
       <p>Когда парсится исходный текст, он анализируется на наличие в себе ошибок, которые при обнаружении не позволят запустить выполнение скрипта / модуля дальше. Однако не все ошибки, допущенные в коде, обладают такой силой. Если все благополучно и парсинг (синтаксический анализ) не выдал сюрпризов и таких ранних ошибок не обнаружено, тогда исходный текст приобретает форму дерева анализа - это "готовый" код необходимой струткуры для хост-среды. Далее процессы, применяемые к скрипту и модулю отличаются.</p>
       
       <section>
          
           <p>После успешного парсинга скрипта формируется его jsовский объект и к нему в качестве свойств подтягиваются необходимые составляющие для дальнейшего выполнения, - в частности, "готовый" код и текущая рабочая область, которая была создана ранее, а значит, подтянувшийся код получает доступ к глобальному объекту ([[GlobalObject]]), глобальному окружению ([[GlobalEnv]]), встроенным объектам ([[Intrinsics]]) и шаблонам js ([[TemplateMap]]).</p>
       
           <p>После этого глобальное окружение из текущей рабочей области ([[GlobalEnv]]) устанавливается как лексическое окружение наивысшего уровня и как окружение переменных для этого кода и всех его составляющих. Грубо говоря, глобальное окружение "окутывает" код скрипта и он выполняется как бы в пределах области видимости этого окружения. Именно здесь из объявлений всех видов функций (обычных функций, генераторов, асинхронных функций и генераторов), переменных, классов (class) и лексических объявлений (лексических переменных - let - и констант - const) будут создаваться глобальные привязки. Понять, какие объявления принадлежат глобальному окружению, вот как: если ты выкупаешь, что созданное объявление находится в окружении, у которого нет внешнего окружения, значит, - оно в глобальном окружении. Однако, есть исключения.</p>

           <p>У обычных переменных особый статус, поскольку они принадлежат лексическому окружению переменных, а в js это окружение, создаваемое функцией, и глобальное окружение. А значит, лексическое окружение, создаваемое инструкцией блока, не "держит" в себе привязки переменных. И пусть даже будет блок, внутри которого вложены другие блоки и внутри них тоже, и в каждом из них будут объявлены переменные, их привязки, игнорируя лексическое окружение каждого блока, принадлежат окружению переменных. Так что глобальному окружению принадлежат не только переменные, объявленные в нем, а и переменные, обьявленные внутри блоков, которые непосредственно находятся в глобальном окружении. А понять, какие это блоки, вот как: каждый блок это отдельное лексическое окружение, и если оно ссылается на глобальное окружение как на внешнее, то все объявленные в нем переменные будут привязаны к глобальному окружению.</p>

           <p>Функции, лексические объявления (let, const) и классы принадлежат только тому лексическому окружению, где они объявлены. При этом функции, объявленные в глобальном окружении, принадлежат окружению переменных. Однако в версиях js до 2015 года функции, объявленные внутри блоков, ведут себя как переменные - они принадлежат окружению переменных. Классы же, в отличие от функций, не принадлежат окружению переменных.</p>

           <p>Это все к тому, что прежде, чем создавать привязки в глобальном окружении, js необходимо их разделить, чтобы понимать, какие из объявлений принадлежат глобальному окружению переменных (обычные переменные и функции), а какие - нет (лексические переменные (let), константы (const) и классы). А теперь еще раз вспомним, что глобальное окружение состоит из объектного ([[ObjectRecord]]) и декларативного окружения ([[DeclarativeRecord]]). И внимание: глобальное окружение переменных соотвествует объектному окружению. А значит, из объявлений, принадлежащих глобальному окружению переменных, создаются свойства в глобальном объекте ([[GlobalObject]]) в качестве привязок. Остальные объявления рассматриваются как лексические и принадлежат глобальному декларативному окружению и там же создаются их привязки.</p>

           <p>Перед созданием привязок, во избежание конфликта имен проверяется несколько условий. Если среди имен глобальных лексических объявлений встречаются имена объявлений, принадлежащих глобальному окружению переменных, - SyntaxError; если среди имен глобальных лексических объявлений встречаются повторы - SyntaxError; если в глобальном объекте есть незаменяемое свойство с таким же именем, как у глобального лексического объявления - SyntaxError. Если эти условия не соблюдаются, дальнейшее выполнения скрипта стопорится.</p>

           <p>При условии, когда таких ошибок не обнаружено, проверяется, возможно ли создать в глобальном объекте ([[GlobalObject]]) свойства из объявлений, принадлежащих глобальному окружению переменных, или переопределить уже существующие в нем свойства с именами этих объявлений. Для этого все объявления в глобальном окружении переменных прогоняются два раза. Первый раз в обратном порядке их объявления (начиная с последнего и заканчивая первым). Эта прогонка для глобальных функций. Функциям тоже есть чем отличится - это подымающиеся объявления и в том окружении, которому они принадлежат, сначала выстраиваются все их объявления, а потом подтягиваются остальные. Такая прогонка используется по той причине, что когда встречаются функции с одинаковым именем, используется последнее объявление такой функции. Значит, с той функции, что засветилась первой, и будет создана привязка, а если дальше будет обнаружена еще одна, объявленная раньше, с таким же именем, ее проигнорируют. В случае, когда проверка на свойства глобального объекта из глобальных функций выдала результат "чики-пики" (это когда все получится, бро), формируется очередь на инициализацию глобальных функций в порядке их объявления (начиная с первой и заканчивая последней). Привязки из глобальных функций будут созданы в порядке этой очереди. После этого снова прогоняются глобальные объявления. Второй раз - в нормальном порядке их объявления (начиная с первого и заканчивая последним). Эта прогонка для глобальных переменных. К ним относятся сами объявления переменных (var) и просто объявленные имена (без оператора var). Когда встречаются переменные с повторяющимеся именами в одном окружении, привязка будет создана из переменной, что объявлена первой (остальные будут проигнорированы). Если же в глобальном объекте есть свойства с именами глобальных переменных, эти свойства будут фигурировать как привязки этих переменных в глобальном окружении. И если среди этих переменных нет таких, чьи имена встречаются среди глобальных функций (а если встречаются, то они игнорируются и привязки переменных с такими именами созданы не будут), и проверка на свойства глобального объекта из глобальных переменных тоже выдала результат "чики-пики", из них формируется очередь создания привязок  в порядке их объявления. В том случае, когда проверка не выдает "чики-пики", она выдает TypeError.</p>

           <p>А теперь про "чики-пики" и TypeError. Свойства в глобальном объекте можно создать и/или переопределить (поменять) при определенных условиях. И новые, и/или обновленные свойства также будут иметь определенный набор характеристик. При условии, когда глобальный объект расширяемый, без свойств с именами объявлений в глобальном окружении переменных, в нем создаются соответствующие свойства данных, которые будут перезаписваемыми ([[Writable]]: true), перечислимыми ([[Enumerable]]: true) и неизменяемыми ([[Configurable]]: false). Свойства, создаваемые из глобальных функций, получают в качестве значений объекты этих функций. А свойства, создаваемые из глобальных переменных, получают в качестве начального значения - undefined. Если объект не расширяемый ([[Extensible]]: false), будет TypeError. Если в глобальном объекте уже есть свойства с именами глобальных функций и они изменяемые ([[Configurable]]: true), эти свойства будут переопределены на перезаписываемые, перечеслимые и неизменяемые с объектами этих функций в качестве значения. Если же среди существующих попадаются неизменяемые, перезаписываемые и перечислымые свойства данных, они будут переопределены с объектами этих функций в качестве значения. Если же попадаются неизменяемые свойства доступа или неизменяемые, не перезаписываемые ([[Writable]]: false) и/или не перечислимые ([[Enumerable]]: false) свойства данных, будет TypeError. Поэтому, если эти условия поддерживают создание новых свойств в глобальном объекте и переопределение уже существующих в нем свойств из глобальных функций и переменных, тогда все "чики-пики". После этого в глобальном окружении создаются привязки.</p>

           <p>При условии, если код выполняется в хост-среде, где крутится js выпущенный до 2015 года, есть перестраховочный шаг. В этом случае, если функции, объявленные внутри блоков, под опекой глобального окружения, не имеют одинаковых имен с глобальными лексическими объявлениями, с объявлениями в глобальном окружении переменных и в глобальном объекте можно создать новые свойства из этих функций, в нем сходу создаются соответствующие свойства со значением undefined. Они создаются по процедуре для привязок переменных, поскольку объекты этих функций инициализируются позже. Их имена попадают в список имен переменных глобального окружения - [[VarNames]]. После инициализации этих функций их объекты становятся значениями соответствующих свойств глобального объекта вместо undefined. Итак, в этом исключительном случае в глобальном окружении переменных сначала создаются привязки таких функций.</p>

           <p>После этого из глобальных лексических объявлений создаются привязки в глобальном декларативном окружении в порядке их объявления, при этом они не инициализируются (т.е. значение им пока не присваивается). Эти привязки либо изменяемые, либо неизменяемые. Если необходимо, чтобы объявление не затерли и оно хранило какое-то одно значение на протяжении всего времени выполнения кода, используется лексическая константа (const), из которой создается неизменяемая привязка. В остальных случаях привязки изменяемые.</p>

           <p>Затем из глобальных функций в порядке полученной очереди создаются привязки. Для каждой глобальной функции сначала инициализируется объект функции из ее глобального объявления в порядке своей очереди на инициализацию. После чего в глобальном объекте создается соответствующее этой функции свойство с перечисленными ранее характеристиками, либо же переопределяется существующее, с ее объектом в качестве значения. Ее имя добавляется в список имен объявлений, что принадлежат глобальному окружению переменных - [[VarNames]].</p>

           <p>И, напоследок, почти все то же самое для глобальных переменных. В глобальном объекте для каждой глобальной переменной в порядке полученной очереди создается, или переопределяется, свойство со значением undefined и ее имя добавляется в список имен глобальных переменных - [[VarNames]]. Имя уже существующего свойства глобального объекта, что соответствует имени глобально объявленной переменной, также добавляется в этот список ([[VarNames]]).</p>

           <p>Таким образом, список имен объявлений, которые принадлежат глобальному окружению окружению переменных ([[VarNames]]), сформирован, привязки глобальных объявлений созданы и глобальное окружение ими заполнено.  После этого дальнейшее вычисление кода ныряет в каждую инструкцию блока и функцию, продолжая там свое выполнение. Каждый такой блок и функция это отдельный узел анализа и выполнение кода переходит из одного узла в другой. Каждый такой узел имеет свое лексическое окружение и для каждого узла общим окружением является глобальное. Поэтому, только после того как идентифицированы объявления на глобальном уровне и созданы их привязки, что привязывают эти объявления к глобальному окружению, выполнение кода ныряет вглубь.</p>

       </section>
       
           <p> Если же при парсинге в исходном тексте были обнаружены синтаксические ошибки или некорректные отсылки, либо сам парсинг выдавал ошибки, которые стопорят выполнение скрипта/модуля, тогда его результатом будет список из таких ошибок (SyntaxError, ReferenceError). В том случае, когда парсинг выдал ошибки при анализе, либо ранние в коде (SyntaxError и/или ReferenceError), они регистрируются в хост-среде, после чего дальнейшее выполнение скрипта прекращается.</p>
           
       <section>

           <p>После успешного парсинга модуля из его "готового" кода вытягиваются все модули, на которые идут запросы из импортов и/или экспортов, объявленных в нем, а также сами эти импорты (то, что ему передается от дугих модулей) и экспорты (то, что он передает другим модулям и/или скриптам). При их наличии, они подтягиваются в качестве составляющих модуля: создается jsовский объект со своими свойствами для текущей рабочей области, "готового" кода, запрашиваемых модулей ([[RequestedModules]]), импортов ([[ImportEntries]]), экспортов, индексов (DFSные), состояния ([[Status]]), окружения ([[Environment]]) и прочими. Здесь, в этом объекте хранится информация об отпарсированном модуле. </p>
           
           <p>Затем модуль инициализируется, в результате чего устанавливаются его связи с другими модулями, на которые есть запросы (пока не будем уточнять откуда). Каждый модуль имеет свое состояние, зависящее от стадии, и результата его выполнения, и изначально все модули несвязаны ([[Status]]: "unlinked"). Когда модуль ожидает своей инициализации ([[Status]]: "unlinked" <span>&#8594;</span> "linking"), он попадает в стэк (как в очередь на инициализацию), после чего хост-среда извлекает и обрабатывает каждый запрашиваемый модуль (по порядку), если они есть, и так будет рекурсивно продолжатся до последнего модуля в стэке. Добравшись до него, запускается процесс инициализации по принципу LIFO (последним вошел в стэк, первым инициализировался). Поэтому у каждого модуля есть индексы, чьи отчеты начинаются с нуля, определяющие его позицию в стэке ([[DFSIndex]]) и того модуля, с которым он формирует сильно связанный компонент ([[DFSAncestorIndex]]). Этот компонент формируется, когда запрашиваемый модуль уже находится в стэке и ждет инициализации. При условии, когда не формируется сильно связанный компонент, этот индекс соответсвует текущей позиции модуля в стэке ([[DFSIndex]]). Когда модуль после своей инициализации покидает стэк, он становится связанным ([[Status]]: "linking" <span>&#8594;</span> "linked"). Если инициализация выдала ошибки или неопределенные результаты, то все модули вплоть до того, чья инициализация накрылась, останутся несвязаны ([[Status]]: "unlinked"), вне окружения ([[Environment]]: undefined) и вне стэка ([[DFSIndex]]: undefined и [[DFSAncestorIndex]]: undefined).</p>
           
           <p>Учитывая цыкличность всего процесса внутреннего связывания, построим простую условную схему модулей, как совокупность связанных объектов (граф), которую разжуем на ходу. Однако сделаем небольшое отступление. Когда в модуле объявляется импорт, это объявление ссылается на другой запрашиваемый модуль, откуда передается конкретная привязка через экспорт (export something <span>&#8594;</span> import something from somewhere), в результате чего формируется зависимость между модулем и запрашиваемым модулем. Поэтому описанная схема графа модулей формирует зависимости с помощью импортов.</p>
           
           <div><img src="img/photo_2019-06-16_11-38-38.jpg" alt="Условная схемка связей для изначального модуля"></div>
           
           <p>m это отпарсированный модуль, который первым попадает в стэк (m[[DFSIndex]]: 0 и m[[DFSAncestorIndex]]: 0). В нем есть импорт от модуля mA, который извлекается и попадает в стэк вторым (mA[[DFSIndex]]: 1 и mA[[DFSAncestorIndex]]: 1). Модуль mA формирует два направления в стэке, по одному от каждого импорта от модуля mB и mD. Сначала извлекается модуль mB, который попадает в стэк третьим (mB[[DFSIndex]]: 2 и mB[[DFSAncestorIndex]]: 2). В модуле mB также есть импорт от модуля mC, который извлекается и попадает в стэк четвертым (mC[[DFSIndex]]: 3 и mC[[DFSAncestorIndex]]: 3). Модуль mC чист (без импортов) поэтому на нем заканчивается данное направление стэка, а его окружение инициализируется первым. Условно инициализация прошла успешно: когда окружение модуля инициализировано, значит, в нем установлены привязки, формирующие связи с другими модулями. И поскольку модуль mC ни с кем не формирует сильно связанный компонент (mC[[DFSIndex]] == mC[[DFSAncestorIndex]]), он выводится из стэка. Третий модуль mB занимает его место как последний в стэке. Все повторяется, начиная от инициализации окружения модуля mB (условно успешной) и до его вывода из стэка. Теперь в стэке снова два модуля (m и mA).</p>
           
           <p>Хууух. Далее обход возвращается к модулю mD, который извлекается и попадает в стэк третьим (mD[[DFSIndex]]: 2 и mD[[DFSAncestorIndex]]: 2). В нем еще два импорта от модулей mE и mF, и снова разветление стэка. Первым извлекается модуль mE, который попадает в стэк четвертым (mE[[DFSIndex]]: 3). В этом модуле есть импорт от модуля mA, что формирует сильно связанный компонент (mE[[DFSAncestorIndex]]: 1). Инициализируется окружение модуля mE, однако после этого он не выводится из стэка из-за связи с модулем mA (чтобы вывести модуль mE из стэка, необходимо сначала инициализировать модуль mA). Обход возвращается к модулю mF, который извлекается и попадает в стэк последним - пятым (mF[[DFSIndex]]: 4 и mF[[DFSAncestorIndex]]: 4). Инициализируется его окружение (условно успешно) и он выводится из стэка. Затем инициализируется окружение модуля mD, однако он не выводится из стэка пока не будет инициализировано окружение модуля mA (из-за связи с модулем mF), что и происходит (в обоих случаях условно успешно). После инициализации модуля mA из стэка один за другим выводится модуль mF, mD и mA. Остается изначально отпарсированный модуль m, который успешно инициализируется и освобождает стэк (тот становится пустым, а все модули в показанной схеме - связаны).</p>
           
           <p>Рассмотрим теперь отдельно инициализацию окружения модуля, исходя из специфики построенной схемы. Условно ни в одном модуле нет ре-экспортов ([[IndirectExportEntries]]) и ни в одном модуле не экспортируется его объект пространства имен ([[StarExportEntries]]). Поэтому сразу создается декларативное окружение модуля (env), которое ссылается на глобальное окружение текущей рабочей области ([[Realm]][[GlobalEnv]]). Модуль получает окружение ([[Environment]]: env) и при условии, если в модуле присутствуют импорты, из них создаются соответствующие неизменяемые лексические привязки в этом окружении (в первую очередь). Импорты передают новые привязки для своего окружения, поэтому особенность их привязок в том, что создается "мостик", что связывет импорт (через его локальное имя) с той привязкой, которую он передает и которая изначально была создана в окружении своего модуля. В том случае, когда импортов в модуле нет, либо их привязки уже созданы, подходит очередь для создания привязок из "готового" кода модуля. Сначала создаются привязки из переменных. Окружение модуля является окружением переменных, поэтому держит в себе привязки своих переменных, которые создаются с инициализируемым значением undefined. Функции, объявленные в модуле, являются лексическими объявлениями, а значит, здесь они не принадлежат окружению переменных. Далее после переменных создаются привязки из лексических объявлений (и функций в том числе). Опять-таки, они могут быть как изменяемые, так и неизменяемые, что зависит от их назначеня. Из объявлений функций создаются изменяемые лексические привязки, которые инициализируются с объектами этих функций в качестве значения.</p>
           
           <p>Вот такое общее описание для инициализации окружения каждого модуля в указанной схеме. Условно все прошло гладко и без ошибок, что прерывают внутреннее связывание модуля. Однако "жиза" бывает жестока и не все проходит гладко или так просто. Усложним теперь нашу схему, и представим, что модуль mB передает свое пространство имен, а модуль mA принимает соответствующий объект. И еще модуль mE передает свою локальную привязку, которую принимает модуль mD, которую он же потом ре-экспортирует и ее принимает модуль mA.</p>
           
           <p>Пожалуй, начнем с самого интересного - с пространства имен модуля mB. Изначально ни один модуль не имеет в себе объект его пространства имен ([[NameSpace]]: undefined). Модуль получает такой объект, когда его экспортируемое пространство имен импортируется в другой модуль. Итак, из соответствующего импорта модуля mA извлекается запрашиваемый модуль mB, где теперь условно есть локальные экспорты ([[ExportEntries]]) и ре-экспорты от модуля mC. Собираются имена всех этих экспортов, кроме default (export default это неявно определенный экспорт, который не попадает в пространство имен модуля). В модуле mB есть ре-экспорт, из которого извлекается модуль mC. Собираются имена всех его экспортов, которые попадают в общий список. Сбор имен всех экспортов продолжается рекурсивно вплоть до того модуля, где нет ре-экспортов (нет их, нет запросов на другие модули). Обход прошелся по модулю mB и mC, собрав имена всех экспортов внутри них, а значит, пространство имен охватывает не только экспорты своего модуля, а и тех модулей, что формируют с ним граф на основании зависимостей. После того, как имена всех экспортов собраны </p>
           
           <p>Однако сам экспорт бывает разный. Есть экспорт, который напрямую передает конкретную привязку, что принадлежит окружению его же модуля (это локальный экспорт). Есть экспорт, который передает привязку ранее попавшего в его модуль импорта (это ре-экспорт привязок со своей спецификой). В этом случае экспорт ссылается на запрашиваемый модуль. И есть экспорт, который передает все объявленные в его модуле локальные экспорты и ре-экспорты за один раз (это передача пространства имен модуля, которому принадлежат только экспортируемые привязки). Ранее уже упоминалось, что для такого экспорта создается контейнер - объект, где соответствующие привязки хранятся как свойства. Этот экспорт также ссылается на модуль, однако на свой же.</p>
           
           <p>Исходя из той роли, которая возлагается на модуль, ценность ему придают эго экспорты - то, что он дает. Когда он передает локальную привязку, все понятно. </p>
           
           Они проверяются в первую очередь. Поэтому если он передает какую-то непонятную "фигню", это надо выкупить сразу. Есть два условия непонятной "фигни". Если в модуль попадает импорт с запросом на этот же модуль и с таким же именем, с каким экспортируется из этого модуля, получаем цыкличность - это "фигня". Если експортируется импортируемое из запрашиваемого модуля пространство имен (объект со всеми его экспортами в качестве свойств), где среди его экспортов встречаются одинаковые имена, создается неясность: при ссылке на повторяющееся имя нельзя определить, какой именно экспорт дёрнуть из запрашиваемого модуля, - это тоже "фигня". Оба условия выкинут ошибку SyntaxError, что застопоприт связывание модуля. При условии, что все хорошо, создается декларативное окружение для модуля, которое ссылается на глобальное окружение текущей рабочей области. 
           </p>
           
           от одного элемента в этом стэке зависит дальнейшая судьба выполнения остальных модулей, которые идут до него. Т.е. если пятый модуль в стэке застопорился, то вслед за ним застопорятся четвертый, третий, второй и первый, а те, что идут после пятого (шестой, седьмой, восьмой и т.д.), уже будут связаны друг с другом. И если застопорился последний модуль в стэке, то логично, что дальше будет стопсигнал для всех. И это еще не все. Связи между модулями могут иметь разные направления, когда, к примеру, первый элемент стека связан со вторым, второй с третьим, а третий - со вторым. Поэтому 
           
           Если импортируются объект пространства имен запрашиваемого модуля, там создается объект (его пространство имен) со всеми этими экспортами в качестве свойств, а в окружении модуля  с импортом создается собственная неизменяемая лексическая привязка, которая инициализируется с этим объектом в качестве значения. 
       </section>
       
   </section>
   
   <section>
       
       <h2>Первое, что нужно знать, когда начинаешь работать с каким-либо языком программирования: типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются одним и тем же). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object. Рассмотрим их вкратце:</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, ему по умолчанию присваивается значение undefined. Проще говоря, undefined это значение при отсуствии значения. Например, в программе используется нечто с именем "a" (пока что без конкретики). Да вот я ему не присвоил никакого значения. А значит, при вычислении "a" я знаю, что программе передается значение undefined. Хотя и не секрет, что значение undefined можно использовать намеренно при написании кода. Поэтому его использование это не только прерогатива движка JS.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе при намеренном отсуствии объектного значения (объекта или его свойства). Исторически это сложилось потому, что null принадлежит семейству объектов (это еще называют "багом" JS - typeof null <span>&#8594;</span> "object"). Итак, undefined и null это пустые значения с той разницой, что null используется при работе с объектами или с чем-то объектноподобным.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также "не-число" - NaN, или Not-a-Number (возникает в том случае, когда к обработке числового значения подключается иной тип данных и полученный результат нельзя преобразовать в число). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не более, чем 2<sup>53</sup> (т.е. существует макисмальная ведичина 2<sup>53</sup> со знаком "+", и минимальная 2<sup>53</sup> со знаком "-").</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ". И функции, о которых будет упоминаться далее, это одна из разновидностей объектов.</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
     
        <p>Строгий режим!</p>
      
       <h2>Немного об объектах</h2>
       
       <p>Здесь будет немного об свойствах и их атрибутах.</p>
       
       <p>Итак, о чем мы должны знать, прежде чем писать код?</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. В коде JS есть синтаксические элементы, которые являются обителью значений, и им даются имена. Это обычные переменные (var), лексические переменные (let), константы (const), функции всех видов, классы, модули и импорты (пока не стоит заморачиваться, что это все такое). Каждый такой элемент имеет свою роль, которая возлагается на его значение. И когда в каком-то участке кода необходимо использовать значение конкретного элемента, используется имя, с которым это значение связано. Т.е. имя это посредник между значением и тем участком кода. Однако не будет лишним прояснить несколько моментов. Связь имя-значение реализовывают привязки. Они связывают имя и значение. Пэтому с помощью имени ссылаются на значение. 
       
       Когда они прописываются в коде (а если говорить по умному - объявляются), имена помогают не только опознать их. Однако после этого имя может быть использовано в других местах кода. является посредником между значением и местом в коде, где это значение необходимо использовать. Имя используется как ссылка и с его помощью ссылаются на значение. После того, как такие элементы прописывается в коде, его имя можно использовать в разных участках этого кода, если там используется необходимое значение При вычислении кода, чтобы связать их имя и значение, движок JS создает привязки из этих элементов. Кроме этого, привязки еще цепляют такие элементы к лексическому окружению.</p> 
       
       Итак, что происходит: когда в коде прописываются такие элементы, то при его вычислении из их имен и значений создаются привязки.
       
       <p>Однако, когда в коде такое имя встречается как ссылка, движок JS не определяет интуитивно, к какому элементу оно относится. В этом ему помогает лексическое окружение. Это исходит из того, что привязки принадлежат только тому лексическому окружению, в котором были созданы, а значит, они регистрируются в конкретном участке кода. Принадлежность привязки к лексическому окружению определяет то, был ли соответствующий ей элемент (а если говорить по умному - объявление) создан в области видимости этого окружения. Так что, используя имя, движок JS получает место в коде, где привязка была создана, и тем самым ее значение. Так что уникальность привязки идентифицирует не только ее имя, а еще и ее лексическое окружение. И если в кусочке программы ссылаются на имя, которое имеют две привязки, то предпочтением будет та, до лексического окружения которой поиск доберется раньше, а другая привязка для этого кусочка программы будет скрыта. Прим. В программе могут встречаться однаковые имена, так как фантазия у всех разная да и свести кое-что к одному общему виду иногда удобнее, поэтому лексическое окружение это дополнительный ориентир. И важное уточнение: именем привязки всегда является строка.</p>
       
       <p>Перед тем как начать вычисление кода внутри скрипта (тоже пока не заморачиваемся), движок JS создает глобальное лексическое окружение, внутри которого и находится весь этот код. В самом коде также создается отдельное лексическое окружение всякий раз при каждом вычислении функции, инструкции блоков и условия Catch инструкции Try (не заморачиваемся) каждый раз . Пределы распостранения лексического окружения определяются его областью видимости. Например, когда видишь в коде функцию - ее начало и конец, - то видишь область видимости ее лексического окружения. Таким же образом работает определение области видимости для инструкций блоков и условий Catch. В случае с глобальным окружением высматривать ничего не надо: начало и конец кода внутри скрипта - это есть границы области видимости глобального окружения.</p>
       
       <p>Лексическое окружение замыкает код внутри себя, изолируя его таким образом, что он имеет доступ к "ресурсам внешнего мира", а тот, в свою очередь, не имеет доступа к "личным ресурсам" этого кода ("ресурсы" это привязки, что принадлежат конкретному лексическому окружению). Такая связь реализована с помощью ссылки на "внешний мир". Когда одно лексическое окружение находится внутри другого, это внутреннее окружение ссылается на внешнее. В отличие от глобального, конечно, где значение соответствующей ссылки - null. И внутри одного лексического окружения может находится множество других окружений. Это накладывает свои ньюансы на использование имен привязок в разных местах кода. К примеру, чтобы использовать имя привязки лексического окружения "А" в окружении "В" (а именно, чтобы привязка с таким именем была найдена и ее значение использовано по назначению), окружение "А" должно быть внешним по отношению к "В". В противном случае, сценарий выполения программы пойдет неправильным путем. Это объясняется тем, что поиск привязок по имени движется по направлению от текущего окружения к внешнему. Такой подход помогает избежать непредвиденных побочных эфектов там, где не надо. Таким образом строятся взаимосвязи и структура лексической вложенности кода.</p>
       
       ///(дальнейшее развитие событий тут уже зависит от режима строгости кода в глобальном окружении). И если код в глобальном окружении определен в строгом режиме, то программа выдаст ошибку ReferenceError. Если же код не строгий, то в глобальном объекте будет создано свойство с именем привязки, на которую ссылаются, и со значением undefined (тут уже свои мутки движка JS в зависимости от режима строгости написания кода). с возможностью их повторного использования где-то еще.  Однако, не всегда все бывает идеально и иногда в программе может проскользнуть попытка переписать значение неизменямой привязки. 
       А вот как себя поведет программа в этом случае, определяет строгость привязки. Только неизменяемые привязки могут быть строгими. Так что если в коде будет произведена попытка переписать значение строгой неизменяемой привязки, программа выдаст "error" перед тем как выполнить код (под "error" подразумевается предупреждение об ошибке). В случае такой "фигни" с не строгой неизменяемой привязкой ты узнаешь, что что-то пошло не так, "по тихому", когда программа до конца просто не выполняется, а значит, где-то там засела ошибка выполнения. Привязка определяется как строгая вне зависимости от того, используется ли она в "строгом режиме" кода, или нет (это, опять таки, предусмотривают внутренние мутки движка JS). ///
       
       <p>Поскольку каждая привязка создается в своем лексическом окружении, складывается впечатление, что оно - это контейнер, где собраны привязки, и отчасти это верно. А отчасти потому, что лексическое окружение разделяется на декларативное и объектное. И в этом смысле "контейнером" является декларативное окружение. Оно создается практически во всех случаях вычисления кода и поэтому оно самое распостраненное. Тогда как объектное окружение создается только при вычислении инструкции with и отчасти в глобальном окружении (об этом чуть позже).</p>
       
       <p>Чтобы рассмотреть каждый тип лексического окружения, сделаем небольшое отступление. Существуют привязки, значение которых можно изменить и в некоторых случаях их можно удалить (что, конечно, зависит от того, как, где и при каких условиях они используются) - это изменяемые привязки. А есть противоположные им, первоначально присвоенное значение которых нельзя изменить и их вообще нельзя удалить - это неизменяемые привязки. Суть неизменяемой привязки в том, чтобы она хранила какое-то одно значение на протяжении всего времени выполнения кода программы.</p>
       
       <p>Это все к тому, что в декларативном окружении уживаются два этих типа привязок (изменяемые и неизменяемы), имена которых напрямую связаны со значениями (так сказать, без посредников). Здесь привязка - это составляющая лексического окружения. И все имена привязок, что используются в этом окружении, будь то ссылка (имя созданного ранее объявления) или только созданное объявление, формируют его набор имен.</p>A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.
       
       <p>Кардинально иначе ведет себя объектное окужение. Здесь уживаются только изменяемые привязки, чьим контейнером является не само окружение, а реальный объект. Хммм... Ватафак? Объектное окружение связано с объектом, в котором при выполнении кода создаются соответствующие свойства с именами и значениями объявлений, что находятся внутри области видимости этого окружения. А значит, привязками здесь являлются свойства того объекта, с которым у объектного окружения существует особая связь. Такой объект называется весьма просто - объект привязки. И поскольку значение свойств можно переписывать и сами свойства в некоторых случаях можно удалить, то и привязки здесь всегда изменяемые. А в набор имен привязок этого окружения добавляются еще имена (и только имена) всех собственных и унаследованных свойств объекта привязки. Из этого также вытекают отличия в поиске привязок по месту, поскольку в объектном окружении мониторится объект привязки, а не само окружение.</p>
       
       <p>Поскольку визуально лексическую вложенность уже определили как космос, то каждая его ветка это отдельное лексическое окружение, созданное при вычислении функций, блоков и условий Catch. А вот глобальное лексическое окружение это как ствол такого дерева - одна общая основа на всех. В JS коде всегда существует глобальное окружение, которое JS-движок создает самостоятельно, никак не выделяя. Это самое топовое окружение в коде. В глобальном окружении вместе уживаются два типа окружения: декларативное и объектное. Объектом привязки здесь является глобальный объект, поэтому тут уже заранее существует предписанный набор имен, которые взяты со свойств глобального объекта, значениями которых являются встроенные базовые объекты в JS.</p>

   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
    
    
           <p>А теперь небольшое отступление о модулях. Модуль это универсальная штука, где можно хранить кусок кода для других модулей и скриптов, используя его многократно, чтобы не дублировать. Таким образом, если надо внести изменения одним махом в тех местах, где этот кусок используется, то достаточно залезть в конкретный модуль и сделать все там. Так что весьма удобно по возможности разбить код программы на модули.</p>
           
</body> 
</html>