<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Заметки</title>
    <style>
    
        body {margin: 0 10% 0 10%; font-size: 2rem}
        
        img {display: inline-block; width: 100%}
        
        table {font-size: 1.75rem; width: 100%}
        
        td {text-align: center}
        
        tr > * {padding: 1rem 0}
        
        a {color: black; text-decoration: none}
        
        
    </style>
</head>

<body>
  
   <section>
      
        <p>Есть среда, где выполняется код - это хост-среда. Хост-средой для js является браузер и сервер (через Node.js). Выполнение кода в хост-среде возможно за счет того, что js внедрен туда как программа - это движок js. В этой программе присутствуют внутренние типы данных, объекты, их методы, функции и алгоритмы, которые невидимы для пользователя и которые задействуются, когда код попадает в хост-среду. Поэтому перед тем, как выполнить код, происходит целая череда процессов, чтобы подготовить необходимые для этого условия. Он попадает в хост среду как текст в сыром виде. Первым делом создается и подготавливается - инициализируется - область выполнения (realm_Record). Внутри движка js это объемная структура данных, напоминающая объект (внутренний тип Record), которая хранит необходимые ресурсы для выполнения кода. Она состоит из набора всех внутренних объектов, что изначально встроены в js и используются внутри кода (внутреннее свойство [[Intrinsics]]); глобального объекта (внутреннее свойство [[GlobalObject]]); глобального окружения (внутреннее свойство [[GlobalEnv]]); коллекции шаблонов, если есть (внутреннее свойство [[TemplateMap]]); и, возможно, дополнительных данных, предоставляемых хост-средой для своего использования (внутреннее свойство [[HostDefined]]). В итоге движок js формирует нечто такое:</p>
       
        <div>
            <pre><code>
                
                realm_Record as {
                    [[Intrinsics]]: <a href="https://tc39.es/ecma262/#sec-well-known-intrinsic-objects">intrinsics_Record</a> as {
                        %intrinsic_key%: intrinsic_Object, 
                        ... their list
                    },
                    [[GlobalObject]]: <a href="https://tc39.es/ecma262/#sec-global-object">global_Object</a> as {
                        Infinity: +∞,
                        NaN: NaN,
                        undefined: undefined,
                        global_Property_key: corresponding intrinsic_Object, 
                        ... their list
                    },
                    [[GlobalEnv]]: global_Environment_Record as {
                        [[ObjectRecord]]: global_Object_Env_Record as {
                            binding_Object: association with global_Object,
                            HasBinding(N),
                            CreateMutableBinding(N,D),
                            CreateImmutableBinding(N,S),
                            InitializeBinding(N,V),
                            SetMutableBinding(N,V,S),
                            GetBindingValue(N,S),
                            DeleteBinding(N),
                            HasThisBinding() <span>&#8594;</span> false,
                            HasSuperBinding() <span>&#8594;</span> false,
                            WithBaseObject()
                        },
                        [[GlobalThisValue]]: this_Object <span>&#8594;</span> usually global_Object,
                        [[DeclarativeRecord]]: global_Declarative_Env_Record as {
                            HasBinding(N),
                            CreateMutableBinding(N,D),
                            CreateImmutableBinding(N,S),
                            InitializeBinding(N,V),
                            SetMutableBinding(N,V,S),
                            GetBindingValue(N,S),
                            DeleteBinding(N),
                            HasThisBinding() <span>&#8594;</span> false,
                            HasSuperBinding() <span>&#8594;</span> false,
                            WithBaseObject() <span>&#8594;</span> undefined
                        },
                        [[VarNames]]: [] empty var_Names_List,
                        outer_Env_link: null,
                        HasBinding(N),
                        CreateMutableBinding(N,D),
                        CreateImmutableBinding(N,S),
                        InitializeBinding(N,V),
                        SetMutableBinding(N,V,S),
                        GetBindingValue(N,S),
                        DeleteBinding(N),
                        HasThisBinding() <span>&#8594;</span> true,
                        HasSuperBinding() <span>&#8594;</span> false,
                        WithBaseObject() <span>&#8594;</span> undefined,
                        GetThisBinding(),
                        HasVarDeclaration(N),
                        HasLexicalDeclaration(N),
                        HasRestrictedGlobalProperty(N),
                        CanDeclareGlobalVar(N),
                        CanDeclareGlobalFunction(N),
                        CreateGlobalVarBinding(N,D),
                        CreateGlobalFunctionBinding(N,V,D)
                    },
                    [[TemplateMap]]: [] empty list,
                    [[HostDefined]]: any value or undefined
                }
                
            </code></pre>
        </div>
        
        <p>Это грубое отображение, которое не претендует на то, чтобы быть правильным, однако, исходя из имеющейся инфы, вполне рабочая версия. Троеточие указывает на длинный перечень: например, внутренних объектов (те, что в intrinsics_Record) очень много и свойств в глобальном объекте (те, что в global_Object) тоже.</p>
        
        <p>Сначала внутри области выполнения (realm_Record[[Intrinsics]]) устанавливаются внутренняя структура данных, состоящая из всех встроенных объектов (intrinsics_Record). Затем в качестве глобального объекта (realm_Record[[GlobalObject]]) создается и устанавливается обычный расширяемый объект с прототипом Object.prototype (global_Object). Однако в очень особенных случаях хост-среда может подогнать объект с другими характеристиками. Затем создается и устанавливается глобальное окружение (realm_Record[[GlobalEnv]]), которое внутри движка js также является объектноподобной структурой данных (global_Environment_Record), состоящей из объектного окружения (внутреннее свойство [[ObjectRecord]]); значения this (внутреннее свойство [[GlobalThisValue]]); декларативного окружения (внутреннее свойство [[DeclarativeRecord]]); списка имен глобально объявленных функций и обычных переменных (внутреннее свойтсво [[VarNames]]); ссылки на внешнее окружение (внутреннее свойство outer_Env_link); и внутренних методов.</p>
        
        <p>Теперь кое-что проясним: глобальное объектное окружение связано с глобальным объектом (binding_Object <span>&#8594;</span> global_Object); значением this внутри глобального окружения в основном является глобальный объект (this_Object <span>&#8594;</span> usually global_Object), хотя хост-среда может подогнать другой объект, подходящий под особенные условия выполнения кода; чтобы определить глобально объявленные функции и обычные переменные, необходимо обработать код, что произойдет позже, поэтому соответствующий список пока пустой (var_Names_List <span>&#8594;</span> empty []); глобальное окружение не находится внутри какого-либо другого окружения, поэтому ссылка на внешнее окружение пустая (outer_Env_link <span>&#8594;</span> null).</p>
        
        <p>После этого глобальный объект набирается предписанных по умолчанию свойств, чьи значения (кроме свойств Infinity, NaN и undefined) он получает из встроенных объектов, что установлены внутри области выполнения (от intrinsics_Record <span>&#8594;</span> global_Property_key: corresponding intrinsic_Object).</p>
        
        <p>После того, как инициализирована область выполнения, "сырой" код ставится в очередь на выполнение. Он определяется как код скрипта или модуля, исходя из механизмов распознавания внутри хост-среды. Когда подходит очередь конкретного скрипта или модуля, первое, что происходит, это его исходный текст синтаксически анализируется на наличие в себе ранних ошибок, которые при обнаружении не позволят запустить выполнение кода (не все ошибки, допущенные в коде, обладают такой силой), и, если все благополучно, движок js преобразовывает его в рабочий формат (parsed_Code_body) - это уже "готовый" код. Весь процесс от анализа до построения архитектуры кода вкратце называется парсинг.</p>
        
        <p>После успешного парсинга скрипт и модуль становится выполняемым компонентом хост-среды. Далее процессы, применяемые к скрипту и модулю отличаются.</p>
       
        <section>

            <h2>Что творится со скриптом</h2>

            <p>В скрипте (script_Record) после парсинга собраны отпарсированный "готовый" код (внутреннее свойство [[ECMAScriptCode]]), текущая область выполнения, которая была создана ранее, а значит, код получает доступ ко всем ее ресурсам (внутреннее свойство [[Realm]]), окружение, которое устанавливается для скрипта, видимо, в очень особенных случаях (внутреннее свойство [[Environment]]), и дополнительное поле для внутренних целей хост-среды (внутреннее свойство [[HostDefined]]). После парсинга скрипт для хост-среды выглядит так:</p>

            <div>
                <pre><code>
                    
                    script_Record as {
                        [[Realm]]: realm_Record,
                        [[Environment]]: undefined,
                        [[ECMAScriptCode]]: parsed_Code_body,
                        [[HostDefined]]: any value or undefined
                    }
                    
                </code></pre>
            </div>

            <p>В коде скрипта (parsed_Code_body) есть инструкции, что создают отдельные участки - блоки кода. К этим инструкциям относятся обычные функции (fucntion), генераторы (function *), асинхронные функции (async function), асинхронные генераторы (async function *), цыклы (while, do-while, for), инструкции try-catch, switch, with и if-else, а также просто созданные руцями блоки, отмеченные по имени или безымянные, и которые не являются частью какой-либо вышеперечисленной инструкции. После парсинга они становятся отдельными узлами, формирующими лексическую структуру и вложенность в коде, которым оперирует хост-среда (parsed_Code_body).</p>
            
            <p>За каждой такой блокоформирующей инструкцией стоит отдельное лексическое окружение, которое она создает - это внутренняя структура данных, где регистрируются привязки (в старой версии js, до релиза 2015, единственная инструкция, которая может иметь лексическое окружение, это функция). Ее начало и конец определяют область видимости, в пределах которой уже создаются такие инструкции, которые содержат в себе значения разных типов данных (Undefined, Null, Number, String, Symbol и Object) и у которых есть имена, что дает возможность ссылатся на них из других участков (блоков) кода и использовать, где необходимо, придерживаясь логики вложенности. Это обычные функции (fucntion), генераторы (function *), асинхронные функции (async function), асинхронные генераторы (async function *), классы (class), лексические изменяемые (let) и неизменяемые переменные (const), а также обычные переменные (var или просто имя без предшествующего оператора). Возможно, сейчас произошла недопонятка, поскольку функции всплыли и там, и там: хоть они и замыкают в себе кусок кода, создавая блок, при этом являются отдельной разновидностью объектов (тип данных Object). Эти инструкции со значениями являются объявлениями и с помощью лексического окружения привязываются к тому блоку и месту в коде, в пределах области видимости которого они были созданы (объявлены). Отдельно зарегистрированное имя объявления в лексическом окружении называется привязкой. За этим именем закрепляется значение соответствующего объявления. Таким образом, объявление привязывается к конкретному участку кода, где оно создано. И перед тем как запустить выполнение кода, движок js сначала создаст привязки в каждом лексическом окружении внутри скрипта (те, что внутри script_Record[[Realm]][[GlobalEnv]] и script_Record[[ECMAScriptCode]]).</p>

            <p>Сначала создаются привязки в глобальном окружении (global_Environment_Record). Оно как и любое другое окружение в js является лексическим (т.е. находится в статичном состоянии). Здесь содержатся привязки, которые доступны для всего кода внутри скрипта (parsed_Code_body). Они создаются из объявлений в глобальной области видимости. Она никуда не вложена, так как охватывает весь код скрипта (его начало и конец) и является внешней по отношению ко всему, что есть в коде. Поэтому созданные здесь объявления попадают под юрисдикцию глобального окружения.</p>
            
            <p>Глобальное окружение (global_Environment_Record) соответствует окружению переменных (variable_Env) внутри кода скрипта, которое также создается функцией. Особенность такого окружения в том, что только в нем создаются привязки из объявлений обычных переменных. Поэтому глобальному окружению принадлежат привязки глобально объявленных обычных переменных и тех, что обьявлены внутри инструкций, которые не являются функцией. Глобально объявленные функции и обычные переменные формируют отдельную группу, из которой создаются привязки в глобальном объектном окружении (global_Object_Env_Record). Однако, привязки в объектном окружении создаются как свойства в конкретно предписанном объекте. Для глобального окружения это глобальный объект (global_Object). Значит, из тех объявлений создаются не просто привязки, а свойства в глобальном объекте (!).</p>
            
            <p>Поскольку во всю эту движуху впутан глобальный объект, в котором уже существует свой установленный набор свойств, проверяется, возможно ли вообще создать в нем новые свойства из соответствующих объявлений или переопределить уже существующие свойства, которые имеют те же имена, что и эти объявления. Если проверка не увенчалась успехом, словишь TypeError, который вылезет при определенных условиях: либо глобальный объект не расширяемый, либо в нем уже есть свойства, которые вообще никак нельзя переопределить под глобальные объявления.</p>
            
            <p>При условии, когда глобальный объект расширяемый и имя объявленной функции или обычной переменной не повторяется среди уже существующих в нем свойств, тогда из этого объявления создается новое свойство данных (global_Binding_Property_key), в котором можно изменить только значение (binding_Value).</p>

            <div>
                <pre><code>
                    
                    global_Binding_Property_key {
                        [[Value]]: binding_Value,
                        [[Writable]]: true,
                        [[Enumerable]]: true,
                        [[Configurable]]: false
                    }
                    
                </code></pre>
            </div>
            
            <p>Сначала в глобальном объекте создаются свойства из всех глобально объявленных функций. Такое свойство получает в качестве значения объект своей функции (global_Binding_Property_key[[Value]]: function_Object), который перед этим инициализируется. Если же встречаются функции с одинаковым именем, свойство в глобальном объекте будет создано из той функции, что объявлена последней (объекты функций могут быть разные). При условии, когда в глобальном объекте уже есть свойство с именем как у функции и его можно полностью переопределить (global_Property_key[[Configurable]]: true), оно будет переопределено к формату, что показан выше. А если уже существующее свойство нельзя переопределить (global_Property_key[[Configurable]]: false), при этом оно не скрыто (global_Property_key[[Enumerable]]: true) и его значение изменяемое (global_Property_key[[Writable]]: true), тогда его текущее значение будет изменено на объект этой функции (global_Property_key[[Value]]: function_Object). Имя функции добавляется в список имен глобально объявленных функций и переменных (var_Names_List).</p>
            
            <p>Затем в глобальном объекте создаются свойства из обычных переменных, к которым относятся сами объявления переменных (с оператором var) и просто объявленные имена (без оператора var, если код не в строгом режиме). Свойства, создаваемые из глобальных обычных переменных, получают в качестве начального значения undefined (global_Binding_Property_key[[Value]]: undefined). Поэтому когда в одном окружении встречаются переменные, чьи имена повторяются, привязка будет создана из первой объявленной переменной, поскольку изначально инициализируемое значение одинаковое. Если же среди глобально объявленных переменных есть та, чьё имя такое же, как у одного из свойств глобального объекта, это свойство никак не переопределяется и сначала эта переменная будет ссылаться на него. Имя переменной пополняет список имен глобально объявленных функций и переменных (var_Names_List). Если же в глобальном объекте уже есть существующее свойство, имя которого такое же, как и имя глобально объявленной переменной, оно также добавляется в этот список, если его там нет.</p>
            
            <p>В версиях движка js до 2015 года функции, объявленные внутри инструкций блоков, принадлежат окружению переменных. Поэтому, при условии, если код выполняется в хост-среде с таким движком, тогда под опекой глобального окружения находятся еще функции, которые объявлены внутри блоков, но не внутри других функций (как в случае с обычными переменными). Если они не имеют одинаковых имен с глобально объявленными лексическими переменными, классами, функциями и обычными переменными, и в глобальном объекте можно создать новые свойства из этих функций, тогда в нем сперва создаются эти свойства со значением undefined, поскольку объекты этих функций инициализируются позже. После инициализации этих функций их объекты становятся значениями соответствующих свойств в глобальном объекте (вместо undefined). Их имена попадают в список имен глобально объявленных функций и переменных (var_Names_List). Итак, в этом исключительном случае в глобальном окружении сначала создаются привязки из таких функций.</p>

            <p>В итоге получается такое:</p>

            <div>
                <pre><code>
                    
                    [[GlobalEnv]]: global_Environment_Record as {
                        [[ObjectRecord]]: global_Object_Env_Record as {
                            binding_Object: association with global_Object as <span>&#8594;</span> {
                                Infinity: +∞,
                                NaN: NaN,
                                undefined: undefined,
                                global_Property_key: corresponding intrinsic_Object, 
                                ... their list,
                                global_Function_Binding_Property_key: function_Object,
                                ... their list,
                                global_Variable_Binding_Property_key: undefined,
                                ... their list
                            },
                            ...
                        },
                        ...
                    }
                    
                </code></pre>
            </div>

            <p>Поэтому в коде в пределах глобальной области видимости функция может быть вызвана даже перед тем, как она была объявлена. Это не имеет никакого значения, поскольку сначала создаются привязки из всех возможных объявлений, а потом происходит выполнение кода как вызов функции. И поэтому вызов той функции ссылается на уже существующее свойство в глобальном объекте. То же самое и для обычных переменных: в коде ими можно оперировать даже перед тем, как им будет присвоено конкретное значение, однако в этом случае полученное из них значение будет undefined.</p>
            
            <p>Привязки из лексических переменных (let и const) и классов создаются непосредственно в глобальном декларативном окружении (global_Declarative_Env_Record) в порядке их объявления, при этом они не инициализируются с каким-либо значением (т.е. начальное значение им не присваивается). Эти привязки либо изменяемые (mutable), либо неизменяемые (immutable). Если необходимо, чтобы объявление не затерли и оно хранило какое-то одно значение на протяжении всего времени выполнения кода, используется неизменяемая привязка.</p>
            
            <div>
                <pre><code>
                    
                    [[GlobalEnv]]: global_Environment_Record as {
                        ...,
                        [[DeclarativeRecord]]: global_Declarative_Env_Record as {
                            ...,
                            global_Mutable_Binding_key <span>&#8594;</span> unitialized,
                            ... their list,
                            global_Imutable_Binding_key <span>&#8594;</span> unitialized,
                            ... their list
                        },
                        ...
                    }
                    
                </code></pre>
            </div>
            
            <p>Однако, если в декларативном окружении сослаться на лексические переменные let, const и классы перед тем, как в коде им будут присвоены значения, получишь ReferenceError, поскольку они не могут ничего вернуть (ссылка будет указывать на то, чего еще вообще не существует).</p>
            
            <p>Таким образом, глобальное окружение это топовое лексическое окружение и последнее пристанище, где может хранится больше нигде не найденная привязка в коде как свойство глобального объекта. Функции, лексические переменные (let, const) и классы привязаны только к той области видимости, внутри которой они объявлены (это лексические объявления), при этом обычные переменные привязаны к глобальной области видимости и к той, которую создают функции. После парсинга кода его глобальное окружение заполняется привязками глобально объявленных функций, классов, лексических и обычных переменных. Затем дальнейшая инициализация кода рекурсивно ныряет вглубь каждой инструкции блока и функции.</p>

            <section>
            
           <section>
               
               <h3>Ранние ошибки</h3>

               <p>Если же при парсинге в исходном тексте были обнаружены синтаксические ошибки или некорректные отсылки, либо сам парсинг выдавал ошибки, которые стопорят выполнение скрипта/модуля, тогда его результатом будет список из таких ошибок (SyntaxError, ReferenceError). В том случае, когда парсинг выдал ошибки и нашел ранние ошибки в коде (SyntaxError и/или ReferenceError), они регистрируются в хост-среде, после чего дальнейшее выполнение скрипта прекращается. В скрипте к таким ошибкам относятся: повторение имен лексических объявлений; если есть совпадение среди имен лексических объявлений и тех, что принадлежат окружению переменных; если в глобальном объекте есть неизменяемое свойство с таким же именем, как у глобального лексического объявления; если в коде есть инструкция eval, где есть выражение super; если в коде есть инструкция eval, где есть выражение new.target; если в коде есть инструкции, где присутствукет метки (label) с повторяющимся именем; если в коде есть инструкции, что прерывются под несуществующей меткой (break); если в коде есть инструкции, что продолжают выполнение под несуществующей меткой (continue). Во всех этих случаях тебе выкинет SyntaxError.</p>

               <p>Перед созданием привязок также проверяется несколько условий выше во избежание конфликта имен. Если эти условия не соблюдаются, дальнейшее выполнения скрипта стопорится.</p>

            </section>

            <section>

               <h3>Строгий режим</h3>

               <p>Помимо всех тех интересностей есть еще одна - строгий режим ("strict mode"). Код можно писать по-босяцки, без обьявления строгого режима. Это дает тебе определенную свободу действий. Если же вдруг захочется обьявить строгий режим ("use strict") в глобальном окружении кода, помимо существующих ограничителей появятся дополнительные. Исходя из того, что было рассмотрено, среди них есть очень примечательные. В глобальном окружении переменных при обычном режиме позволительно (то ли по тупости, то ли специально) прописать имя, которое не встречается среди нормально объявленных переменных и присвоить ему значение. Это будет рассмотрено как обычная глобальная переменная и в глобальном объекте будет создано соответствующее свойство с этим именем. Однако при строгом режиме такое свойство в глобальном объекте создано не будет и ссылка на это имя выдаст ReferenceError.</p>

               <p>При обычном режиме и нормальных условиях this без значения (точнее, когда оно выдает undefined или null) указывает на глобальный объект. Однако при строгом режиме такое this не переводится в глобальный объект и оно вернет undefined (или null при сценариях, когда this это null). Если же в качестве значения this ему передается примитивное значение, оно не будет преобразовано в объект. Т.е. все значения this в этом случае воспринимаются буквально.</p>

               <p>Строгий режим не имеет большой популярности среди программистов, однако он используется в некоторых местах кода по умолчанию. Строгий режим имеет еще ограничения, которые будем выводить в свет постепенно.</p>
               
            Лексическое окружение это внутренняя, похожая на объект структура внутри движка js, где регистрируются имена созданных по месту объявлений. Лексическое окружение устанавливается для тех инструкций, что создают отдельные блоки кода  , поэтому из их объявлений создаются привязки, содержащие объект функции. Помимо лексического окружения, которое создается на каждую инструкцию, что замыкает код и формирует блок,



            </section>

        </section>
           
       <section>

            <h2>Что творится с модулем</h2>
           
            <p>Скрипт как монолит хранит в себе весь код программы, а модуль - отдельную его часть. Поэтому, помимо того, что имеет скрипт, модуль, как структура данных (module_Record), хранит информацию о своем состоянии (внутреннее свойство [[Status]]), позиции среди остальных модулей (внутренне свойство [[DFSIndex]]), о том, какие из них напрямую запрашиваются внутри него (внутренне свойство [[RequestedModules]]), что он от них принимает через свои импорты (внутреннее свойство [[ImportEntries]]), что он сам передает через свои экспорты (внутренние свойства [[LocalExportEntries]], [[IndirectExportEntries]] и [[StarExportEntries]]), и еще кучу всего, включая его методы. Изначально это выглядит так:</p>
           
            <div>
                <pre><code>
                    
                    module_Record as {
                        [[Realm]]: realm_Record,
                        [[Environment]]: undefined,
                        [[Namespace]]: undefined,
                        [[HostDefined]]: any value or undefined,
                        [[ECMAScriptCode]]: parsed_Code_Body,
                        [[Status]]: "unlinked",
                        [[EvaluationError]]: undefined,
                        [[DFSIndex]]: undefined,
                        [[DFSAncestorIndex]]: undefined,
                        [[RequestedModules]]: list of module_Specifiers [...]
                            or [] empty list,
                        [[ImportEntries]]: list of import_Records as [
                            import_Record as {
                                [[ModuleRequest]]: "module_Specifier",
                                [[ImportName]]: "imported_Name",
                                [[LocalName]]: "local_Import_Decl_Name"
                            },
                            ... their list 
                        ] or [] empty list,
                        [[LocalExportEntries]]: list of export_Records as [
                            export_Record as {
                                [[ExportName]]: "exported_Name",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "local_Binding_Name"
                            },
                            ... their list
                        ] or [] empty list,
                        [[IndirectExportEntries]]: list of re-export_Records as [
                            re-export_Record as {
                                [[ExportName]]: "exported_Name",
                                [[ModuleRequest]]: "module_Specifier",
                                [[ImportName]]: "imported_Name",
                                [[LocalName]]: null
                            },
                            ... their list
                        ] or [] empty list,
                        [[StarExportEntries]]: list of re-export_Records as [
                            re-export_Record as {
                                [[ExportName]]: null,
                                [[ModuleRequest]]: "module_Specifier",
                                [[ImportName]]: "*",
                                [[LocalName]]: null
                            },
                            ... their list
                        ] or [] empty list,
                        GetExportedNames([export_Set]),
                        ResolveExport(name, [export_Set]),
                        Link(),
                        Evaluate(),
                        InitializeEnvironment(),
                        ExecuteModule()
                    }
                    
                </code></pre>
            </div>
           
           <p>После парсинга из модуля, что изначально загружается в хост-среду (module_Record), собирается весь код программы. Программа, что исползует модульную систему, разбита на отдельные куски кода, которые содержатся в разных модулях (файлах). Они сначала  собираются, затем связываются, а потом - выполняются. Связывание разных модулей в коде реализовывается с помощью объявлений экспорта (export ...), ре-экспорта (явного export ... from ... и неявного) и импорта (import ... from ...). Они могут быть созданы только внутри модуля. Если их объявить в скрипте, получишь ошибку. После парсинга эти объявления становятся структурами данных внутри движка js, как показано выше. Детализированный пример был бы очень кстати. У нас есть изначально отпарсированный модуль (module_Record), который называется "module" и он условно имеет один импорт, объявленный под именем "imported_a", что запрашивает экспорт, объявленный под именем "a" в модуле "module_A" (чей путь хранится в module_Record[[RequestedModules]]).</p> 
           
           <p>У модуля "module" как у структуры данных есть место, где он отдельно хранит свои импорты (module_Record[[ImportEntries]]). Задача импорта (import_Record) это принять и сохранить значение из другого модуля. Объявленные внутри модуля импорты создают запросы на экспорты из других модулей. От импорта движок js получает пачку данных (import_Record), в которой содержится путь к модулю (внутреннее свойство [[ModuleRequest]]), указывающий на то, где объявлен запрашиваемый экспорт; имя запрашиваемого экспорта (внутреннее свойство [[ImportName]]); и имя, под которым импорт объявлен внутри своего модуля (внутреннее свойство [[LocalName]]). Модуль это именованный файл, и разные модули могут находится в разных директориях (папках). Поэтому, когда внутри модуля запрашиваются другие модули, к ним указывается путь, что состоит из месторасположения и имени конкретного модуля. С его помощью движок js находит этот запрашиваемый модуль и загружает его в хост-среду (там парсинг происходит уже на лету).</p>
           
           <p>Итак, начинается процесс связывания модуля "module". Выстраивается граф зависимостей, первым элементом которого становится этот модуль. Граф отрисовывает структуру связей модулей, начиная с изначально отпарсированного. Чтобы понимать, в какой позиции находится каждый модуль среди остальных в графе, движок использует конкретный индекс (внутреннее свойство [[DFSIndex]]), который начинает свой отчет с 0 (это указывает на первый элемент в графе). Еще есть индекс, указывающий на зависимость с предыдущим модулем в графе (внутреннее свойство [[DFSAncestorIndex]]). При нормальных условиях второй индекс соответсвует текущей позиции модуля в графе. Таким образом, движок выкупает, как построена программа, разбитая на модули. Еще независимо от графа формируется очередь на связывание - стэк, - что пополняется модулями в том порядке, в котором они попадают в хост-среду. Модуль "module" первым попадает в стэк. То, что мы описали, выглядит так:</p>
           
           <div>
               <pre><code>
                   
                    module.js <!-- 1st in the stack -->

                    <span>&#8595;</span>

                    import {a as imported_a} from "../module_A"; 

                    <span>&#8595;</span>

                    module_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 0,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 0,
                        [[RequestedModules]]: ["../module_A"],
                        [[ImportEntries]]: [
                           {
                                [[ModuleRequest]]: "../module_A",
                                [[ImportName]]: "a",
                                [[LocalName]]: "imported_a"
                            }
                        ],
                        [[LocalExportEntries]]: [] empty list,
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
              
               </code></pre>
           </div>
           
           <p>Модуль "module" в очереди на связывание. Движок обходит его список запрашиваемых модулей (module_Record[[RequestedModules]]), откуда извлекает первый и единственный модуль "module_A". Этот модуль загружается в хост-среду и там парсится. В нем есть два экспорта "a" и "S". Экспорт "a" указывает на привязку под именем "container_a", а экспорт "S" - на привязку под именем "container_S". Таким образом, эти привязки маркируются как экспортируемые и могут быть доступны для других модулей.</p>
           
           <p>Это обычные локальные экспорты, которые хранятся в модуле отдельно (module_A_Record[[LocalExportEntries]]). Задача локального экспорта (export_Record) это открыть для других модулей доступ к значению конкретной привязки. От него движок js получает пачку данных (export_Record), что состоит из имени, под которым экспорт объявлен внутри своего модуля и на которое можно сослаться из другого модуля (внутреннее свойство [[ExportName]]), и имени экспортируемой привязки, к значению которой этот экспорт открывает доступ, ссылаясь на нее напрямую (внутреннее свойство [[LocalName]]). Т.е., когда в области видимости модуля существует объявление, привязка из которого отмечается как экспортируемая - это локальный экспорт.</p>
           
           <p>При парсинге модуля движок js имеет набор условий, которые являются причиной ранних ошибок. При наличии какого-либо из них парсинг выполнен не будет. Среди них примечательное такое: если в экспорте указывается имя экспортируемой привязки, которое не встречается среди объявлений в области видимости модуля, это рассматривается как ранняя ошибка, ведь получается, что такого объявления не существует (пусть даже оно объявлено внутри какго-то блока или функции, для экспорта оно остается недоступным). Поэтому из модуля может быть расшарена только та привязка, на которую ссылается локальный экспорт по имени уже существующего объявления(!). И когда после парсинга выдается модуль, где есть экспорты, движок уже заранее проверил существование всех соответствующих объявлений, чьи привязки экспортируются. Таким образом, наличие этих привязок определено априори и они только ждут своей инициализации. Пока лексическое окружение модуля не инициализировано, к ним предоставляется косвенный доступ.</p>
           
           <p>Также в этом модуле есть два импорта "imported_Obj_B" и "imported_e". Первый запрашивает объект из всех экспортов модуля "module_B" (другими словами, объект его пространства имен), а второй - экспорт "e" из модуля "module_E". Чтобы запросить объект, состоящий из экспортов модуля "module_B", достаточно вместо имени запрашиваемого экспорта указать "*". Начинается процесс связывания модуля "module_A", который попадает в граф вторым и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_A.js <!-- 2nd in the stack -->
            
                    <span>&#8595;</span>

                    export {container_a as a};
                    export {container_S as S};
                    import * as imported_Obj_B from "../module_B";
                    import {e as imported_e} from "../module_E";

                    <span>&#8595;</span>

                    module_A_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 1,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 1,
                        [[RequestedModules]]: ["../module_B", "../module_E"],
                        [[ImportEntries]]: [
                           {
                                [[ModuleRequest]]: "../module_B",
                                [[ImportName]]: "*",
                                [[LocalName]]: "imported_Obj_B"
                            },
                            {
                                [[ModuleRequest]]: "../module_E",
                                [[ImportName]]: "e",
                                [[LocalName]]: "imported_e"
                            }
                        ],
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "a",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_a"
                            },
                            {
                                [[ExportName]]: "S",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_S"
                            }
                        ],
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Модуль "module_A" в очереди на связывание. Из его списка запрашиваемых модулей извлекается первый модуль - "module_B". Запрашиваемые модули извлекаются рекурсивно по порядку появления запросов внутри каждого модуля. В этом модуле есть три экспорта: пространства имен модуля "module_C", ре-экспорт, что запрашивает экспорт "d" из модуля "module_D", и неявный локальный экспорт "default". Экспорт пространства имен модуля "module_C" (это общее количество экспортов внутри него) хранится в модуле "module_B" отдельно (внутри module_B_Record[[StarExportEntries]]). Этот экспорт является разновидностью ре-экспорта, поэтому из него движок получает пачку данных (re-export_Record), что состоит из указателя на пространство имен (внутреннее свойство [[ImportName]] с символом "*") и пути к запрашиваемому модулю (внутреннее свойство [[ModuleRequest]]). Этот экспорт безымянный (внутреннее свойство [[ExportName]] со значением null). Он объединяет целые пространства имен других модулей. Т.е. когда из модуля экспортируется все, что экспортирует другой модуль - это экспорт пространства имен.</p>
           
           <p>Ре-экспорт, или повторный экспорт, экспорта "d" из модуля "module_D", объявленный под именем "re-exported_d", тоже хранится внутри модуля "module_B" отдельно (module_B_Record[[IndirectExportEntries]]). Он не используется для нужд кода внутри этого модуля. Его пачка данных (re-export_Record) состоит из имени ре-экспорта (внутреннее свойство [[ExportName]]), имени запрашиваемого экспорта (внутреннее свойство [[ImportName]]) и пути к файлу запрашиваемого модуля (внутреннее свойство [[ModuleRequest]]). Задача такого экспорта это точечно расширить пространство имен своего модуля, поскольку он передает уже существующий в другом модуле экспорт. Он не имеет отношения к экспортируемым привязкам из своего модуля. Есть еще экспорты, которые похожы на локальные, однако являются ре-экспортами. Это экспорты импортов, при условии, что и те, и те объявлены внутри одного модуля. Однако экспорт будет локальным, если импорт запрашивает объект пространства имен другого модуля. Т.е. когда из модуля экспортируется чужой экспорт из другого модуля - это ре-экспорт. Он создает канал связи, по которому транслирует в свой модуль образ запрашиваемого экспорта.</p>
           
           <p>Склепаем табличку для визуализации всех различий между тремя разновидностями экспорта:</p>
           
           <table>
               
               <tr>
                   
                   <th>EE / module</th>
                   <th>[[LocalExportEntries]]</th>
                   <th>[[IndirectExportEntries]]</th>
                   <th>[[StarExportEntries]]</th>
                   
               </tr>
               
               <tr>
                   
                   <th>[[ExportName]]</th>
                   <td>yes / "name"</td>
                   <td>yes / "name"</td>
                   <td>no / null</td>
                   
               </tr>
               
               <tr>
                   
                   <th>[[ModuleRequest]]</th>
                   <td>no / null</td>
                   <td>yes / "path"</td>
                   <td>yes / "path"</td>
                   
               </tr>
               
               <tr>
                   
                   <th>[[ImportName]]</th>
                   <td>no / null</td>
                   <td>yes / "name"</td>
                   <td>yes / "*"</td>
                   
               </tr>
               
               <tr>
                   
                   <th>[[LocalName]]</th>
                   <td>yes / "name"</td>
                   <td>no / null</td>
                   <td>no / null</td>
                   
               </tr>
               
           </table>
           
           <p>Количество экспортов в одном модуле не ограничено, кроме одного неявного экспорта "export default ..." на модуль. Он еще особенный тем, что не попадает в пространство имен своего модуля. Экспорт default в модуле "module_B" указывает на функцию F как экспортируемую. Начинается процесс связывания этого модуля, который попадает в граф третьим и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_B.js <!-- 3rd in the stack -->

                    <span>&#8595;</span>

                    export * from "../module_C";
                    export {"d" as "re-exported_d"} from "../module_D";
                    export default function F () {...};

                    <span>&#8595;</span>

                    module_B_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 2,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 2,
                        [[RequestedModules]]: ["../module_C", "../module_D"],
                        [[ImportEntries]]: [] empty list,
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "default",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "F"
                            }
                        ],
                        [[IndirectExportEntries]]: [
                            {
                                [[ExportName]]: "re-exported_d",
                                [[ModuleRequest]]: "../module_D",
                                [[ImportName]]: "d",
                                [[LocalName]]: null
                            }
                        ],
                        [[StarExportEntries]]: [
                            {
                                [[ExportName]]: null,
                                [[ModuleRequest]]: "../module_C",
                                [[ImportName]]: "*",
                                [[LocalName]]: null
                            }
                        ],
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Следом извлекается модуль "module_C", в котором только локальные экспорты. Начинается процесс его связывания, он попадает в граф четвертым и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_C.js <!-- 4th in the stack -->

                    <span>&#8595;</span>

                    export {"container_h" as "h"};
                    export {"container_i" as "i"};
                    export {"container_j" as "j"};
                    export default let N = ...;

                    <span>&#8595;</span>

                    module_C_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 3,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 3,
                        [[RequestedModules]]: [] empty list,
                        [[ImportEntries]]: [] empty list,
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "h",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_h"
                            },
                            {
                                [[ExportName]]: "i",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_i"
                            },
                            {
                                [[ExportName]]: "j",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_j"
                            },
                            {
                                [[ExportName]]: "default",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "N"
                            },
                        ],
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Когда в стэк попадает модуль, в котором нет импортов/ре-экспортов, инициализируется его лексическое окружение. Сначала cоздается лексическое окружение модуля (module_C_Env_Record), которое является декларативным и ссылается на глобальное окружение из текущей области выполнения (module_Record[[outer_Env_link]] <span>&#8594;</span> module_Record[[Realm]][[GlobalEnv]]). Затем оно заполняется привязками из объявлений, что созданы в области видимости этого модуля. К ним относятся ранее перечисленные функции и переменные всех разновидностей, а еще - импорты. Поскольку в этом модуле импортов нет, создаются привязки из других объявленй внутри его кода. Сперва создаются изменяемые привязки из объявлений обычных переменных с инициализируемым значением undefined (окружение модуля тоже является окружением переменных). Затем в порядке появления создаются привязки из других объявлений, которые являются лексическими. Внутри модуля из объявлений функций создаются изменяемые лексические привязки, которые инициализируются с объектами этих функций (function_Object) в качестве значения (привязки функций не подымаются в лексическом окружении модуля выше других).</p>
           
           <div>
               <pre><code>
                   
                    [[Environment]]: module_C_Env_Record as {
                        outer_Env_link: [[Realm]][[GlobalEnv]],
                        HasBinding(N),
                        CreateMutableBinding(N,D),
                        CreateImmutableBinding(N,S),
                        InitializeBinding(N,V),
                        SetMutableBinding(N,V,S),
                        GetBindingValue(N,S),
                        DeleteBinding(N) <span>&#8594;</span> is never invoked,
                        HasThisBinding() <span>&#8594;</span> true,
                        HasSuperBinding() <span>&#8594;</span> false,
                        WithBaseObject() <span>&#8594;</span> undefined,
                        GetThisBinding() <span>&#8594;</span> undefined,
                        CreateImportBinding (N,M,N2),
                        module_Mutable_Var_Binding_key: undefined,
                        [..., their list],
                        module_Mutable_Binding_key <span>&#8594;</span> unitialized or
                        module_Mutable_Binding_key: function_Object <span>&#8594;</span> if a function,
                        [..., their list],
                        module_Immutable_Binding_key <span>&#8594;</span> unitialized,
                        [..., their list]
                    }
                   
               </code></pre>
           </div>
           
           <p>После инициализации лексического окружения модуля к его экспортируемым привязкам предоставляется прямой доступ и они становятся доступными для других модулей. Модуль "module_C" выводится из стэка и становится связанным с теми модулями, где есть запросы на его экспорты (с модулем "module_B"). Связанный модуль означает, что он передает доступ к реально существующим привязкам(!). Итак, связывание происходит с конца стэка по принципу LIFO:</p>
           
           <div>
               <pre><code>
                   
                    module_C.js <!-- not in the stack - module_B last in the stack -->

                    <span>&#8595;</span>

                    module_C_Record {
                        ...
                        [[Environment]]: module_C_Env_Record,
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Затем эстафета переходит к предыдущему модую в стэке, и если там нет запросов на другие модули, начнется инициализация его окружения. А если они есть, эти модули добавляются в стэк и пополняют граф. Обход возвращается к модулю "module_B", откуда извлекается модуль "module_D", где только один локальный экспорт. Начинается процесс его связывания, он попадает в граф пятым и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_D.js <!-- 4th in the stack -->

                    <span>&#8595;</span>

                    export {"container_d" as "d"};

                    <span>&#8595;</span>

                    module_D_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 4,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 4,
                        [[RequestedModules]]: [] empty list,
                        [[ImportEntries]]: [] empty list,
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "d",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_d"
                            }
                        ],
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>В нем нет запросов на другие модули, поэтому инициализируется его лексическое окружение (module_D_Env_Record). Затем он выводится из стэка и становится связанным:</p>
           
           <div>
               <pre><code>
                   
                    module_D.js <!-- not in the stack - module_B last in the stack -->

                    <span>&#8595;</span>

                    module_D_Record {
                        ...
                        [[Environment]]: module_D_Env_Record,
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>В модуле "module_B" больше нет запросов на другие модули, поэтому он становится последним элементом в стэке. Модуль "module_B" может быть связанным только в том случае, если запрашиваемый экспорт "d" обрабатываемый. Проверка того, являются ли локальные экспорты в модуле обрабатываемыми, происходит при парсинге модуля. Однако парсинг не затрагивает ре-экспорты. Есть несколько условий, при которых выкинет ошибку SyntaxError и дальнейшее связывание оставшихся модулей в стэке прекратится. Это когда запрашивается несуществующий локальный экспорт. Это когда запрос цепляет два, или более, экспорта с одинаковыми именами, что объявлены в разных модулях и указывают на разные имена привязок. Это когда запрашивается экспорт default. Это когда запрашивается экспорт импорта с цыкличным запросом (т.е. импорт запрашивает этот же экспорт). Поэтому экспорт является обрабатываемым, если в запрашиваемом модуле он существует в одном экземпляре. После проверки нициализируется лексическое окружение модуля "module_B" (module_B_Env_Record). Он выводится из стэка и становится связанным:</p>
           
           <div>
               <pre><code>
                   
                    module_B.js <!-- not in the stack - module_A last in the stack -->

                    <span>&#8595;</span>

                    module_B_Record {
                        ...
                        [[Environment]]: module_B_Env_Record,
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Обход возвращается к модулю "module_A", откуда извлекается модуль "module_E", в котором один локальный экспорт и импорт. Начинается процесс его связывания, он попадает в граф шестым и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_E.js <!-- 3rd in the stack -->

                    <span>&#8595;</span>

                    export {"container_e" as "e"};
                    import {"f" as "imported_f"} from "../module_F";

                    <span>&#8595;</span>

                    module_E_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 5,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 5,
                        [[RequestedModules]]: ["../module_F"],
                        [[ImportEntries]]: [
                            {
                                [[ModuleRequest]]: "../module_F",
                                [[ImportName]]: "f",
                                [[LocalName]]: "imported_f"
                            }
                        ],
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "e",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_e"
                            }
                        ],
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Из модуля "module_E" извлекается модуль "module_F", в котором есть один локальный экспорт и импорт, который запрашивает экспорт "S" из модуля "module_A". Начинается процесс его связывания, он попадает в граф последним, седьмым, и пополняет стэк:</p>
           
           <div>
               <pre><code>
                   
                    module_F.js <!-- 4th in the stack -->

                    <span>&#8595;</span>

                    export {"container_f" as "f"};
                    import {"S" as "imported_S"} from "../module_A";

                    <span>&#8595;</span>

                    module_F_Record {
                        ...
                        [[Status]]: "unlinked" <span>&#8594;</span> "linking",
                        [[DFSIndex]]: undefined <span>&#8594;</span> 6,
                        [[DFSAncestorIndex]]: undefined <span>&#8594;</span> 1,
                        [[RequestedModules]]: ["../module_A"],
                        [[ImportEntries]]: [
                            {
                                [[ModuleRequest]]: "../module_A",
                                [[ImportName]]: "S",
                                [[LocalName]]: "imported_S"
                            }
                        ],
                        [[LocalExportEntries]]: [
                            {
                                [[ExportName]]: "f",
                                [[ModuleRequest]]: null,
                                [[ImportName]]: null,
                                [[LocalName]]: "container_f"
                            }
                        ],
                        [[IndirectExportEntries]]: [] empty list,
                        [[StarExportEntries]]: [] empty list,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>В этом случае формируется цыкличная зависимость и сильно связанный компонент, поскольку, чтобы модуль "module_F" стал связанным, необходимо инициализировать окружение предшествующего модуля, с которым он связывается. Есть запрос на модуль "module_A", чье окружение будет инициализировано только после инициализации окружения модуля "module_E", а это, в свою очередь, произойдет только после инициализации окружения модуля "module_F". Поэтому соответствующий индекс модуля "module_F" указывает на позицию модуля "module_A" в графе (module_F_Record[[DFSAncestorIndex]] <span>&#8594;</span> module_A_Record[[DFSIndex]] <span>&#8594;</span> 1).</p>
           
           <p>Итак, сперва инициализируется окружение модуля "module_F". Когда в модуле используется импорт, значит, ему необходимо особое значение, чтобы выполнить свой код, которое находится в другом модуле. В лексическом окружении модуля привязки из объявлений импортов создаются в первую очередь, подымаясь над остальными. Сначала проверяется, является ли запрашиваемый экспорт из импорта обрабатываемым. Затем из объявления обычного импорта (как "imported_S" в модуле "module_F") создается неизменяемая лексическая привязка, которая затем инициализируется (получает неявное значение). Эта привязка ссылается на нужное значение, не храня его в себе. Исходя из запроса импорта, она ссылается на модуль, что запрашивается, и на конкретную привязку (по ее имени) из этого модуля, на которую указывает экспорт, что запрашивается. Таким образом, импорт транслирует в свой модуль ссылку на привязку через запрашиваемый экспорт в другом модуле. Как результат, к экспортируемой привязке предоставляется активное подключение в режиме просмотра (это означает, что ее значение можно изменить только внутри запрашиваемого модуля). Поэтому, когда такая привязка экспортируется, это считается как неявный ре-экспорт. Одако есть один случай, когда привязка импорта хранит в себе именно значение, а не ссылку на него (о чем позже). Итак, когда импорт, цепляется за конкретный экспорт (не за пространство имен, о чем позже), что находится в другом модуле, создается канал связи. Обычные импорты по этому каналу транслируют ссылку, указывающую на значение, чтобы использовать ее для выполнения кода внутри своего модуля.</p>
           
           <p>Поскольку в модуле "module_A" существование привязки "container_S" анонсировано и к ней есть косвенный доступ, привязка "imported_S" в модуле "module_F" не привязывается к существованию лексического окружения модуля "module_A". В этом случае главное, чтобы запрашиваемый экспорт указывал на имя существующего объявления (а он указывает). Только после инициализации лексического окружения запрашиваемого модуля ("module_A") к его привязкам открывается прямой доступ.</p>
           
           <div>
               <pre><code>
                   
                    module_F.js 

                    <span>&#8595;</span>

                    module_F_Record {
                        ...
                        [[Environment]]: module_F_Env_Record as 
                            {
                                ...,
                                module_Immutable_Import_Binding_imported_S 
                                references to {
                                    [[Module]]: module_A_Record,
                                    [[Binding]]: "container_S"
                                }
                                ...
                            },
                        [[Status]]: "linking",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Модуль "module_F" не выводится из стэка после инициализации своего лексического окружения. Затем инициализируется лексическое окружение модуля "module_E", по кончании чего из стэка выводится последний модуль в стэке - "module_F", - а после него - модуль "module_E":</p>
           
           <div>
               <pre><code>
                  
                    module_F.js <!-- last in the stack -->

                    <span>&#8595;</span>

                    module_F_Record {
                        ...
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
                    module_E.js <!-- module_F last in the stack - module_F not in the stack - not in the stack - module_A last in the stack -->

                    <span>&#8595;</span>

                    module_E_Record {
                        ...
                        [[Environment]]: module_E_Env_Record,
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>И, наконец, начинается инициализация модуля "module_A". Этот модуль примечателен тем, что в нем есть импорт "imported_Obj_B", который запрашивает объект пространства имен модуля "module_B". Этот запрос запустит сбор имен всех локальных экспортов и ре-экспортов в запрашиваемом модуле "module_B". Все эти экспорты собираются в один объект. В результате из такого импорта создается обычная (!) неизменяемая привязка, которой в качестве значения устанавливается этот объект.</p>
           
           <p>Замечу, что, когда объявляется импорт с указателем "*", это запрос на соответсвующий объект. Тогда как экспорт с указателем "*" не запрашивает объект - к экспортам текущего модуля добавляются экспорты запрашиваемого модуля (их пространства имен неявно объединяются). Например, рассматривая модуль "module_A", в нем можно создать импорт с запросом на экспорт "i" из модуля "module_B" и это не выкинет ошибки, поскольку поиск, не найдя такой экспорт в модуле "module_B", перейдет в модуль "module_C", где тот экспорт изначально объявлен.</p>
            
           <p>При запросе на объект пространства имен модуля "module_B" собираются все его экспорты с именем, на которое можно сослаться из другого модуля. Эти экспорты включают в себя одиночные ре-экспорты и не включают экспорт default. На экспорт пространства имен (export * ...) нельзя сослаться, поскольку он безымянный ([[ExportName]]: null). Из модуля "module_B" вытягивается только ре-экспорт "re-exported_d". И так как в этом модуле есть экспорт с запросом на пространство имен модуля "module_C", оттуда тоже собираются все экспорты, не включая экспорт default. Итак, с модулей "module_B" и "module_C" собраны экспорты с именами "re-exported_d", "h", "i" и "j". Учитывая, что пространства имен этих двух модулей пересекаются, из собранных экспортов отсеиваются необрабатывемые (даже если такие и попадаются, ошибка SyntaxError при создании объекта пространства имен не вызывается).</p>
           
           <p>Отобрав все обрабатываемые экспорты, движок приступает к созданию соответствующего объекта. Он нерасширяемый и без прототипа. Изначально ни один модуль не имеет в себе такого объекта ([[Namespace]]: undefined). Он создается для того модуля, чей объект пространства имен запрашивается, а это модуль "module_B". Каждое свойство этого объекта предоставляет доступ (!) к значению определенной экспортируемой привязки (само значение в нем не хранится). Свойства этого объекта неизменяемые, не скрыты и их значения можно переписать, однако это делается удаленно в том модуле, откуда экспортируется соответствующая привязка. Из собранных экспортов берутся их имена, которые и будут ключами свойств этого объекта. </p>
           
           <div>
               <pre><code>
                    module_B.js 
                    
                    <span>&#8595;</span>
                    
                    module_B_Record {
                        ...
                        [[Namespace]]: undefined <span>&#8594;</span> module_B_Namespace_Object as 
                            {"re-exported_d": access to exported binding "container_d",
                            "h": access to exported binding "container_h",
                            "i": access to exported binding "container_i",
                            "j": access to exported binding "container_j"},
                        ...
                    }
                    
                    <span>&#8595;</span>
                   
                    module_B_Namespace_Object_Property_key {
                        [[Value]]: access to exported binding,
                        [[Writable]]: true,
                        [[Enumerable]]: true,
                        [[Configurable]]: false
                    }
                   
               </code></pre>
           </div>
           
           <p>Именно этот созданный объект и инициализируется привязке из импорта "imported_Obj_B" в качестве значения. Из такого вида импорта создается обычная неизменяемая лексическая привязка которая сразу получает значение.</p>
           
           <div>
               <pre><code>
                    module_A.js
                    
                    <span>&#8595;</span>
                    
                    module_A_Record {
                        ...,
                        [[Environment]]: module_A_Env_Record as 
                            {
                                ...,
                                module_Immutable_Binding_imported_Obj_B: 
                                    module_B_Namespace_Object,
                                ...
                            }
                        [[Status]]: "linking",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>После успешной инициализации модуля "module_A" он выводится из стэка и становится связанным:</p>
           
           <div>
               <pre><code>
                   
                    module_A.js <!-- not in the stack - module last in the stack -->

                    <span>&#8595;</span>

                    module_A_Record {
                        ...
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Остается изначально отпарсированный модуль "module", чье окружение успешно инициализируется, он освобождает стэк и становится связанным:</p>
           
           <div>
               <pre><code>
                   
                    module.js <!-- not in the stack -->
                    
                    <span>&#8595;</span>

                    module_Record {
                        ...
                        [[Status]]: "linking" <span>&#8594;</span> "linked",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Итак, стэк, который определяет порядок связывания, становится пустым, граф зависимостей построен, а все модули - связаны между собой. Исходя из рассмотренного примера, все рекурсивно извлеченные модули будут связаны между собой только после того, как каждый из них получит свое лексическое окружение и к его привязками будет предоставлен прямой доступ. Таким образом, модули с импортами и ре-экспортами привязываются к модулям, где есть экспорты с нужными им значениями, в результате чего отдельные модули становятся частью целой программы.</p>
           
           <p>Если при инициализации лексического окружения модуля произошли ошибки (SyntaxError), тогда связывание оставшихся модулей в стэке прекращается. Каждый оставшийся модуль в стэке, начиная с того, где все застопорилось, становится несвязаным ([[Status]]: linking <span>&#8594;</span> unlinked), ему не инициализируется лексическое окружение ([[Environment]]: undefined) и покидает граф ([[DFSIndex]]: "current index" <span>&#8594;</span> undefined и [[DFSAncestorIndex]]: "current index" <span>&#8594;</span>undefined). При этом те модули, что ранее стали связанными такими и остаются.</p>
          
           <p>Затем наступает очередь выполнения кода внутри этих модулей после их связывания. Все снова начинается с изначально отпарсированного модуля с той разницей, что все модули уже в хост-среде и граф зависимостей не формируется (индексы каждого модуля в графе не сбрасываются). Модули попадают в стэк выполнения в таком же порядке, как при связывании:</p>
           
           <div>
               <pre><code>
                   
                    module.js <!-- 1st in the stack -->
                    
                    <span>&#8595;</span>

                    module_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                    
                    module_A.js <!-- 2nd in the stack -->
                    
                    <span>&#8595;</span>

                    module_A_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                    
                    module_B.js <!-- 3rd in the stack -->
                    
                    <span>&#8595;</span>

                    module_B_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                    
                    module_C.js <!-- 4th in the stack -->
                    
                    <span>&#8595;</span>

                    module_C_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Модули просто добавляются в стэк выполнения в порядке появления запросов и если туда попал модуль, не имеющий запросов (без импортов/ре-экспортов), начинается выполнение его кода, после чего он выводится из стэка и становится выполненным. Таким модулем в стэке является "module_C":</p>
           
           <div>
               <pre><code>
                   
                    module_C.js <!-- not in the stack - module_B last in the stack -->
                    
                    <span>&#8595;</span>

                    module_C_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Затем из модуля "module_B" в стэк попадает модуль "module_D" и начинается выполнение его кода:</p>
           
           <div>
               <pre><code>
                   
                    module_D.js <!-- 4th in the stack -->
                    
                    <span>&#8595;</span>

                    module_D_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>После успешного выполнения кода этот модуль выводится из стэка и становится выполненным. Затем выполняется код внутри модуля "module_B", он освобождает стэк и становится выполненным:</p>
           
           <div>
               <pre><code>
                   
                    module_D.js <!-- not in the stack - module_B last in the stack -->
                    
                    <span>&#8595;</span>

                    module_D_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                    
                    module_B.js <!-- not in the stack - module_A last in the stack -->
                    
                    <span>&#8595;</span>

                    module_B_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Затем в стэк один за другим попадают модули "module_E" и "module_F":</p>
           
           <div>
               <pre><code>
                   
                    module_E.js <!-- 3rd in the stack -->
                    
                    <span>&#8595;</span>

                    module_E_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                    
                    module_F.js <!-- 4th in the stack -->
                    
                    <span>&#8595;</span>

                    module_F_Record {
                        ...
                        [[Status]]: "linked" <span>&#8594;</span> "evaluating",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Учитывая связанность модуля "module_F" с модулем-предшественником "module_A", схема та же, что и при связывании. Сначала выполняется код модуля "module_F". После этого выполняется код модуля "module_E". И только потом из стэка сначала выводится  модуль "module_F", а затем - модуль "module_E", и они становятся выполненными:</p>
           
           <div>
               <pre><code>
                   
                    module_F.js <!-- last in the stack -->
                    
                    <span>&#8595;</span>

                    module_F_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                    
                    module_E.js <!-- module_F last in the stack - module_F not in the stack - not in the stack - module_A last in the stack -->
                    
                    <span>&#8595;</span>

                    module_E_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Напоследок выполняется код модуля "module_A", а за ним - модуля "module". Покинув стэк, теперь все модули в графе теперь не только связаны, а еще и выполнены:</p>
           
           <div>
               <pre><code>
                   
                    module_A.js <!-- not in the stack - module last in the stack -->
                    
                    <span>&#8595;</span>

                    module_A_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                    
                    module.js <!-- not in the stack -->
                    
                    <span>&#8595;</span>

                    module_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>Выполнение кода внутри каждого модуля также происходит с конца стэка по принципу LIFO. Если же при выполнении кода внутри модуля произошла ошибка, она прерывает выполнение кода всех оставшихся модулей. Однако, эти модули становятся выполнеными, поскольку полученная ошибка регистрируется как результат их выполнения. Допустим, в модуле "module_A" при выполнении кода произошла ошибка (module_A_Error). Это прекратит выполнение кода модуля "module", который также получит эту ошибку, при этом оба модуля отмечаются как выполненные, получив неприятный сюрприз в качестве конечного результата:</p>
           
           <div>
               <pre><code>
                   
                    module_A.js <!-- not in the stack - module last in the stack -->
                    
                    <span>&#8595;</span>

                    module_A_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        [[EvaluationError]]: undefined <span>&#8594;</span> module_A_Error,
                        ...
                    }
                    
                    module.js <!-- not in the stack -->
                    
                    <span>&#8595;</span>

                    module_Record {
                        ...
                        [[Status]]: "evaluating" <span>&#8594;</span> "evaluated",
                        [[EvaluationError]]: undefined <span>&#8594;</span> module_A_Error,
                        ...
                    }
                   
               </code></pre>
           </div>
           
           <p>А если бы такая ошибка произошла при выполнении кода модуля "module_C", то модули "module_D", "module_E" и "module_F" вообще бы не попали в стэк и ни один модуль в графе не был бы нормально выполнен, поскольку та ошибка распостранилась бы по существующим в стэке модулям "module_B", "module_A" и "module". Код модуля находится внутри своей изолированной "экосистемы", и если при его выполнении произошла ошибка, она не затронет код в других модулях, ее будет легче найти и устранить. Итак, модули весьма удобны, когда необходимо сделать код мобильным.</p>
           
       </section>
       
       
           <p>Итак, мы рассмотрели два источника, что передают код в хост-среду - это скрипт и модуль. Если они на всем своем пути не выкинули ошибок, их выполнение успешное и можно только порадоваться. Если же ошибки были, они передаются в хост среду.</p>
       
       <section>
           
           <p>Рассмотрев скрипты и модули, находится общая деталь: когда создаются привязки из объявлений функций, они инициализируются с объектом своей функции. Значит, рассмотрим, как этот объект создается. Функции это одна из разновидностей объектов, что имеют свое поведение в зависимости от того являются ли они просто функциями, просто генераторами, асинхронными функциями или асинхронными генераторфми. И это та штука, которая запускает выполнение отдельных кусков кода внутри скрипта / модуля. Начнем с просто функций (function).</p>
           
           <p></p>
           
           Если импортируются объект пространства имен запрашиваемого модуля, там создается объект (его пространство имен) со всеми этими экспортами в качестве свойств, а в окружении модуля  с импортом создается собственная неизменяемая лексическая привязка, которая инициализируется с этим объектом в качестве значения. 
       </section>
       
   </section>
   
   <section>
       
       <h2>Первое, что нужно знать, когда начинаешь работать с каким-либо языком программирования: типы данных</h2>
   
       <p>Суть любой работающей программы в том, что она берет какие-то значения, оперирует ими и возвращает... значение. Это ее смыл: выдать результат, обработав входящие данные. (В этом контексте "данные" и "значения" являются одним и тем же). Как маг, ты будешь скармливать программе и получать от нее такие типы данных, как: Undefined, Null, String, Symbol, Number и Object. Рассмотрим их вкратце:</p>

       <ol>
           <li>Undefined. Данные не передаются программе просто так. Программа идентифицирует и обработывает значение с помощью имени. Это имя является мостиком между значением и тем местом в коде, где оно используется. В том случае, когда в программе существует имя, которому не присвоено значение, ему по умолчанию присваивается значение undefined. Проще говоря, undefined это значение при отсуствии значения. Например, в программе используется нечто с именем "a" (пока что без конкретики). Да вот я ему не присвоил никакого значения. А значит, при вычислении "a" я знаю, что программе передается значение undefined. Хотя и не секрет, что значение undefined можно использовать намеренно при написании кода. Поэтому его использование это не только прерогатива движка JS.</li>
           <li>Null. Значения undefined и null похожи тем, что оба означают отсуствие значения. При этом есть ньюанс. Значение null используется в программе при намеренном отсуствии объектного значения (объекта или его свойства). Исторически это сложилось потому, что null принадлежит семейству объектов (это еще называют "багом" JS - typeof null <span>&#8594;</span> "object"). Итак, undefined и null это пустые значения с той разницой, что null используется при работе с объектами или с чем-то объектноподобным.</li>
           <li>String. Чтобы работать с данными в виде текста, в программе используется строка. В этом случае JS обрабатывает каждый элемент строки согласно кодировке UTF-16. У строки, как у значения, есть свои особенности:
               <ol type="i">
                   <li>Она имеет длину - это общее число ее элементов;</li>
                   <li>Элементы строки индексируются, начиная с 0 (первый элемент имеет индекс 0, второй - 1, третий - 2 и т.д.).</li>
               </ol>
           </li>
           <li>Number. Также есть значения для работы конкретно с числами. Числа в JS представлены в виде 64-битовых значений формата IEEE 754-2008. Среди них выделяют конечные и бесконечные числа, а также "не-число" - NaN, или Not-a-Number (возникает в том случае, когда к обработке числового значения подключается иной тип данных и полученный результат нельзя преобразовать в число). Все эти числа, кроме NaN, разделяются на положительные и отрицательные (бесконечность и 0 тоже). Абсолютная величина конечных положительных и отрицательных целых чисел, используемых в JS, составляет не более, чем 2<sup>53</sup> (т.е. существует макисмальная ведичина 2<sup>53</sup> со знаком "+", и минимальная 2<sup>53</sup> со знаком "-").</li>
           <li>Symbol. Это значение можно назвать помощником при работе с объектами. Один и тот же "символ" можно использовать как уникальное не перечислимое (анонимное) и неизменное свойство для разных объектов. В JS есть уже предписанный набор "символов" со своим предназначением, которые можно смело юзать.</li>
           <li>Object. Все выше перечисленные значения являются примитивными в отличие от объекта. Объект это сложное значение, с внутренней структурой, состоящей из свойств, где хранятся другие значения. Эти свойства идентифицируются с помощью своих ключей. В качестве ключа свойства используется либо строка (в этом случае она может быть либо именем, либо индексом), либо "символ". И функции, о которых будет упоминаться далее, это одна из разновидностей объектов.</li>
       </ol>

       <p>Получив минимально необходимое представление о том, какие есть типы данных и их значения, теперь известно, с чем придется работать, чтобы творить мэджик. Однако этого недостаточно, чтобы отхерячить Дормамму.</p>
       
   </section>
   
   <section>
     
        <p>Строгий режим!</p>
      
       <h2>Немного об объектах</h2>
       
       <p>Здесь будет немного об свойствах и их атрибутах.</p>
       
       <p>Итак, о чем мы должны знать, прежде чем писать код?</p>
       
   </section>
   
   <section>
       
       <h2>Лексическое окружение</h2>
       
       <p>Ранее я упомянул важную фразу про обработку значения с помощью имени. В коде JS есть синтаксические элементы, которые являются обителью значений, и им даются имена. Это обычные переменные (var), лексические переменные (let), константы (const), функции всех видов, классы, модули и импорты (пока не стоит заморачиваться, что это все такое). Каждый такой элемент имеет свою роль, которая возлагается на его значение. И когда в каком-то участке кода необходимо использовать значение конкретного элемента, используется имя, с которым это значение связано. Т.е. имя это посредник между значением и тем участком кода. Однако не будет лишним прояснить несколько моментов. Связь имя-значение реализовывают привязки. Они связывают имя и значение. Пэтому с помощью имени ссылаются на значение. 
       
       Когда они прописываются в коде (а если говорить по умному - объявляются), имена помогают не только опознать их. Однако после этого имя может быть использовано в других местах кода. является посредником между значением и местом в коде, где это значение необходимо использовать. Имя используется как ссылка и с его помощью ссылаются на значение. После того, как такие элементы прописывается в коде, его имя можно использовать в разных участках этого кода, если там используется необходимое значение При вычислении кода, чтобы связать их имя и значение, движок JS создает привязки из этих элементов. Кроме этого, привязки еще цепляют такие элементы к лексическому окружению.</p> 
       
       Итак, что происходит: когда в коде прописываются такие элементы, то при его вычислении из их имен и значений создаются привязки.
       
       <p>Однако, когда в коде такое имя встречается как ссылка, движок JS не определяет интуитивно, к какому элементу оно относится. В этом ему помогает лексическое окружение. Это исходит из того, что привязки принадлежат только тому лексическому окружению, в котором были созданы, а значит, они регистрируются в конкретном участке кода. Принадлежность привязки к лексическому окружению определяет то, был ли соответствующий ей элемент (а если говорить по умному - объявление) создан в области видимости этого окружения. Так что, используя имя, движок JS получает место в коде, где привязка была создана, и тем самым ее значение. Так что уникальность привязки идентифицирует не только ее имя, а еще и ее лексическое окружение. И если в кусочке программы ссылаются на имя, которое имеют две привязки, то предпочтением будет та, до лексического окружения которой поиск доберется раньше, а другая привязка для этого кусочка программы будет скрыта. Прим. В программе могут встречаться однаковые имена, так как фантазия у всех разная да и свести кое-что к одному общему виду иногда удобнее, поэтому лексическое окружение это дополнительный ориентир. И важное уточнение: именем привязки всегда является строка.</p>
       
       <p>Перед тем как начать вычисление кода внутри скрипта (тоже пока не заморачиваемся), движок JS создает глобальное лексическое окружение, внутри которого и находится весь этот код. В самом коде также создается отдельное лексическое окружение всякий раз при каждом вычислении функции, инструкции блоков и условия Catch инструкции Try (не заморачиваемся) каждый раз . Пределы распостранения лексического окружения определяются его областью видимости. Например, когда видишь в коде функцию - ее начало и конец, - то видишь область видимости ее лексического окружения. Таким же образом работает определение области видимости для инструкций блоков и условий Catch. В случае с глобальным окружением высматривать ничего не надо: начало и конец кода внутри скрипта - это есть границы области видимости глобального окружения.</p>
       
       <p>Лексическое окружение замыкает код внутри себя, изолируя его таким образом, что он имеет доступ к "ресурсам внешнего мира", а тот, в свою очередь, не имеет доступа к "личным ресурсам" этого кода ("ресурсы" это привязки, что принадлежат конкретному лексическому окружению). Такая связь реализована с помощью ссылки на "внешний мир". Когда одно лексическое окружение находится внутри другого, это внутреннее окружение ссылается на внешнее. В отличие от глобального, конечно, где значение соответствующей ссылки - null. И внутри одного лексического окружения может находится множество других окружений. Это накладывает свои ньюансы на использование имен привязок в разных местах кода. К примеру, чтобы использовать имя привязки лексического окружения "А" в окружении "В" (а именно, чтобы привязка с таким именем была найдена и ее значение использовано по назначению), окружение "А" должно быть внешним по отношению к "В". В противном случае, сценарий выполения программы пойдет неправильным путем. Это объясняется тем, что поиск привязок по имени движется по направлению от текущего окружения к внешнему. Такой подход помогает избежать непредвиденных побочных эфектов там, где не надо. Таким образом строятся взаимосвязи и структура лексической вложенности кода.</p>
       
       ///(дальнейшее развитие событий тут уже зависит от режима строгости кода в глобальном окружении). И если код в глобальном окружении определен в строгом режиме, то программа выдаст ошибку ReferenceError. Если же код не строгий, то в глобальном объекте будет создано свойство с именем привязки, на которую ссылаются, и со значением undefined (тут уже свои мутки движка JS в зависимости от режима строгости написания кода). с возможностью их повторного использования где-то еще.  Однако, не всегда все бывает идеально и иногда в программе может проскользнуть попытка переписать значение неизменямой привязки. 
       А вот как себя поведет программа в этом случае, определяет строгость привязки. Только неизменяемые привязки могут быть строгими. Так что если в коде будет произведена попытка переписать значение строгой неизменяемой привязки, программа выдаст "error" перед тем как выполнить код (под "error" подразумевается предупреждение об ошибке). В случае такой "фигни" с не строгой неизменяемой привязкой ты узнаешь, что что-то пошло не так, "по тихому", когда программа до конца просто не выполняется, а значит, где-то там засела ошибка выполнения. Привязка определяется как строгая вне зависимости от того, используется ли она в "строгом режиме" кода, или нет (это, опять таки, предусмотривают внутренние мутки движка JS). ///
       
       <p>Поскольку каждая привязка создается в своем лексическом окружении, складывается впечатление, что оно - это контейнер, где собраны привязки, и отчасти это верно. А отчасти потому, что лексическое окружение разделяется на декларативное и объектное. И в этом смысле "контейнером" является декларативное окружение. Оно создается практически во всех случаях вычисления кода и поэтому оно самое распостраненное. Тогда как объектное окружение создается только при вычислении инструкции with и отчасти в глобальном окружении (об этом чуть позже).</p>
       
       <p>Чтобы рассмотреть каждый тип лексического окружения, сделаем небольшое отступление. Существуют привязки, значение которых можно изменить и в некоторых случаях их можно удалить (что, конечно, зависит от того, как, где и при каких условиях они используются) - это изменяемые привязки. А есть противоположные им, первоначально присвоенное значение которых нельзя изменить и их вообще нельзя удалить - это неизменяемые привязки. Суть неизменяемой привязки в том, чтобы она хранила какое-то одно значение на протяжении всего времени выполнения кода программы.</p>
       
       <p>Это все к тому, что в декларативном окружении уживаются два этих типа привязок (изменяемые и неизменяемы), имена которых напрямую связаны со значениями (так сказать, без посредников). Здесь привязка - это составляющая лексического окружения. И все имена привязок, что используются в этом окружении, будь то ссылка (имя созданного ранее объявления) или только созданное объявление, формируют его набор имен.</p>A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.
       
       <p>Кардинально иначе ведет себя объектное окужение. Здесь уживаются только изменяемые привязки, чьим контейнером является не само окружение, а реальный объект. Хммм... Ватафак? Объектное окружение связано с объектом, в котором при выполнении кода создаются соответствующие свойства с именами и значениями объявлений, что находятся внутри области видимости этого окружения. А значит, привязками здесь являлются свойства того объекта, с которым у объектного окружения существует особая связь. Такой объект называется весьма просто - объект привязки. И поскольку значение свойств можно переписывать и сами свойства в некоторых случаях можно удалить, то и привязки здесь всегда изменяемые. А в набор имен привязок этого окружения добавляются еще имена (и только имена) всех собственных и унаследованных свойств объекта привязки. Из этого также вытекают отличия в поиске привязок по месту, поскольку в объектном окружении мониторится объект привязки, а не само окружение.</p>
       
       <p>Поскольку визуально лексическую вложенность уже определили как космос, то каждая его ветка это отдельное лексическое окружение, созданное при вычислении функций, блоков и условий Catch. А вот глобальное лексическое окружение это как ствол такого дерева - одна общая основа на всех. В JS коде всегда существует глобальное окружение, которое JS-движок создает самостоятельно, никак не выделяя. Это самое топовое окружение в коде. В глобальном окружении вместе уживаются два типа окружения: декларативное и объектное. Объектом привязки здесь является глобальный объект, поэтому тут уже заранее существует предписанный набор имен, которые взяты со свойств глобального объекта, значениями которых являются встроенные базовые объекты в JS.</p>

   </section>
   
   <p> С помощью лексического окружения определяется, какие идентификаторы существуют внутри определенных структурных единиц JS кода.  JS расценивает то полотно, где прописывается код программы, как один документ. У него есть такие составляющие, как область кода, его окружение, сам код и поле, отведенное для хост-среды. Код прописывается в сценарии (скрипте) или модуле.</p>
   
   <p>Объект это самое мэджикал значение. При использовании индексов в объектах их числовое значение может находится в диапазоне от 0 до <span>2<sup>53</sup> - 1</span> включительно (в массивах этот диапазон меньше и составляет от 0 до <span>2<sup>32</sup> - 1</span>). Иногда необходимо знать, что лежит внутри работы кода программы и, в частности, объекта. Как уже было сказано, объект это сложное значение. Его свойства как хранилище для других значений могут использоваться для разных целей. Поэтому они могут иметь разное внутреннее состояние, которое определяется их атрибутами в описании свойства. В зависимости от набора атрибутов различают свойства для хранения данных и свойства с функциями доступа get/set для манипуляций с данными. Кратко об этих атрибутах:</p>
       <ol type="i">
           <li>[[Value]] - тут содержится значение свойства;</li>
           <li>[[Writable]] - определяет, возможно ли записать свойству новое значение;</li>
           <li>[[Get]] - тут содержится функция доступа get, которая извлекает значение из свойства;</li>
           <li>[[Set]] - тут содержится функция доступа set, которая присваивает новое значение свойству;</li>
           <li>[[Enumerable]] - определяет, перечисляется ли свойство в цыкле for-in;</li>
           <li>[[Configurable]] - определяет, возможно ли перенастроить атрибуты, изменить тип свойства и удалить его. Хотя при работе с этим атрибутом есть один ньюанс: если этот атрибут имеет отрицательный контекст для свойства данных (со значением false), все еще можно изменить значение свойства, если оно перезаписываемое (когда {[[Writable]]: true}), и сделать его не перезаписываемым (а вот сделать не перезаписываемое свойство (когда {[[Writable]]: false}) перезаписывемым уже нельзя).</li>
       </ol>
    <p>Атрибуты [[Enumerable]] и [[Configurable]] содержаться во всех свойствах, [[Value]] и [[Writable]] - только в свойствах данных, а [[Get]] и [[Set]] - в свойствах функций get и set.</p>
    
    <p>Объект тоже имеет свое внутреннее состояние, которое определяют слоты. Они используются алгоритмами JS и влияют на поведение объекта. Объекты есть разные и для их разновидностей предусмотрены разные наборы внутренних слотов. Поведение объектов определяют их внутренние методы. Перечислять и описывать все слоты и методы сейчас не нужно - пока достаточно знать, что они есть.</p>
   
   
   
    <h3>Цыклы</h3>
    
    <p>Существует 6 разновидностей цыклов. Изначально значение цыкла - undefined. Голова цыкла это то, что находится внутри скобок соответствующих операторов while ( ... ) / for ( ... ). Тело цыкла это код, что вычисляется с каждой итерацией и находится внутри блока { ... } (хотя, если код состоит из одной инструкции, то можно обойтись и без обявления блока {} - на вкус и цвет).</p>
    
    <p>Цыкл do { ... } while ( ... ) Он сначала выполняет код в теле цыкла. Полученный результат либо завершает цыкл, либо требует его дальнейшего выполнения. В первом случае вернется полученный результат кода и овер. Во втором случае алгоритм присвоит цыклу значение из этого результата и затем выполнит выражение while. Оно является условием (тестом), при котором вычисляется цыкл. Если его значение интерпретируется как true, запускается следующая итерация цыкла. Если же как false, вернется значение цыкла и его выполнение завершится.</p>
    
    <p>Цыкл while ( ... ) { ... } Он сначала выполнит выражение while, которое является условием (тестом) цыкла. Если его значение интерпретируется как true, выполнится код в теле цыкла. Если же как false, вернется значение цыкла и его выполнение завершится. При выполнении кода в теле цыкла его результат либо завершает, либо продолжает цыкл. В первом случае вернется полученный результат кода и цыкл прекращается. Во втором случае алгоритм присвоит цыклу значение из этого результата и запускается следующая его итерация.</p>
    
    <div>
       
        <p>Цыкл for ( ... ; ... ; ... ) { ... } Все три составляющие в голове цыкла (внутри for) не являются обязательными. Если в голове цыкла не будет какой-либо из них, или она вообще будет пустая, это пропускается и вычисление топает дальше по алгоритму, а итерации все равно запускаются. Каждая из этих составляющих имеет свою роль. Первая определяет точку отчета (она используется для выполнения кода в теле цыкла). Вторая - это условие проверки цыкла (его тест). Третья - это апдейт (в основном для точки отчета). Существует три вариации цыкла for.</p>
        
        <ol>
            <li>Одна из них, это когда первая составляющая в голове цыкла является выражением (ни var, ни let или const).</li>
        </ol>
        
        <p>После ее вычисления начинают выполнятся итерации. Итерация начинается с вычисления условия цыкла. Если его результат интерпретируется как true, тогда далее вычисляется код в теле цыкла. Если же как false, тогда алгоритм вернет значение цыкла и его выполнение закончится. Результат выполнения кода в теле цыкла либо завершает его, либо продолжает вычисление итерации. В первом случае вернется полученный результат и цыкл прекращается. Во втором - вычисляется последнее выражение в голове цыкла (апдейт точки отчета) и затем начинается новая итерация.</p>
        
        <ol start="2">
            <li>Другая вариация цыкла for, это когда первая составляющая в голове цыкла является объявлением переменной (var), которому может быть присвоено значение.</li>
        </ol>
        
        <p>После вычисления var запускается итерация, алгоритм которой не меняется.</p>
        
        <ol start="3">
            <li>Третья вариация цыкла for, это когда первая составляющая в голове цыкла является лексическим объявлением (let или const), которому может быть присвоено значение.</li>
        </ol>
        
        <p>Тут алгоритм вычисления меняется. Сначала создается новое лексическое окружение цыкла (оно ссылается на внешнеее лексическое окружение, в котором существует текущий контекст выполнения) с привязками соответствующего лексического объявления (let или const). Если лексическая объявление константное (const), создае.тся неизменяемая привязка, которую нельзя перезаписать. В другом случае создется изменяемая привязка, которая не удаляется. После этого текущий контекст выполнения переходит в лексическое окружение цыкла. Вычисляется объявление let / const в голове цыкла. Если его завершение обрывистое, цыкл заканчивается, возвращая результат вычисления let / const. В ином случае вычисляется итерация. Если обьявление не константное (let)  Для каждого элемента имен привязок лексического объявления,  После вычисления let / const запускается итерация, при этом </p>
        
    </div>
    
    
           <p>А теперь небольшое отступление о модулях. Модуль это универсальная штука, где можно хранить кусок кода для других модулей и скриптов, используя его многократно, чтобы не дублировать. Таким образом, если надо внести изменения одним махом в тех местах, где этот кусок используется, то достаточно залезть в конкретный модуль и сделать все там. Так что весьма удобно по возможности разбить код программы на модули.</p>
           
</body> 
</html>