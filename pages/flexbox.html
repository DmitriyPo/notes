<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Flexbox</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
   
    <section>
        
        <header>
            
            <h1>Гибкая модель разметки</h1>
            
        </header>

        <p>Итак, я недавно прочел спецификацию по <a href="https://www.w3.org/TR/css-flexbox-1/">гибкой блочной модели разметки</a>. Учитывая, что она написана на английском, к которому я испытываю огромную любовь, мне, наверное, надо ее перечитывать снова и снова, чтобы в мой высохший мозг наконец начала литься информация. И не только литься, а и обрабатываться в нем.</p>

        <p>Сделаю для себя короткие заметки, которые будут мне понятны и лишены излишней многословности. Летс гоу теория.</p>

        <p>Чтобы превратить элемент в гибкий контейнер, ему нужно назначить свойство <em>display</em> со значением <em>flex</em> или <em>inline-flex</em>. Значение <em>flex</em> создает блочный гибкий контейнер, <em>inline-flex</em> - строчный. Те дочерние элементы, которые находятся в потоке этого контейнера, также становятся гибкими. И текст, содержащийся в этом контейнере, оборачивается в безымянный гибкий элемент. Под словом гибкий следует понимать, что контейнер и его дочерние элементы могут видоизменятся, менять свое направление и поток, при этом логика самого документа не затрагивается. Гибкий контейнер установливает гибкий контекст форматирования для контента внутри его. Круто ведь.</p>

        <p>Для понимания гибкой модели необходимо прошарить, что происходит с элементом, когда его превращают в гибкий контейнер. У этого контейнера появляются оси: основная (или главная, хуй его знает, как правильно) и поперечная. Та-да-да-дааамм. <strong>Основная ось</strong> та, вдоль которой размечены дочерние гибкие элементы контейнера. <strong>Поперечная ось</strong> перпендикулярна основной. Это раз. Два. В контейнере теперь существует <strong>два пространства</strong> соответственно: <strong>основное</strong> (или главное) и <strong>поперечное</strong>. Ясен хуй, что основное измерение то, в котором гибкие элементы простираются вдоль (барабанная дробь) основной оси. И с поперечным измерением все то же самое, только вместо основной оси поперечная. Дальше три. Гибкие элементы внутри контейнера имеют <strong>начало</strong>, что называют основным, и идут к <strong>концу</strong> контейнера, что также основное. Еще выделяются поперечное начало и конец: эти понятия нужны для работы с гибкими строками и обозначают их начало и конец соответсвенно (или направление к концу). Дальше мы прближаемся к финалу - четыре. В зависимости от того, в каком измерении находятся гибкие элементы, они имеют соответствующие <strong>размеры</strong>: основной и поперечный. Размер элемента определяется через свойства <em>width</em> и <em>height</em>.</p>

        <p>Вот иллюстрация того, о чем говорится выше, на примере гибкого контейнера, которому назначено свойство <em>flex-direction</em> со значением <em>row</em> (или <em>row-rewerse</em>):</p>
        
        <img src="https://i.gyazo.com/529501176cfb67aa96ec03e75f933458.png" alt="various directions and sizing terms as applied to a row flex container">

        <p>Если контейнер имеет для свойства <em>flex-direction</em> значение <em>column</em> (или <em>column-reverse</em>), тогда основная ось становится вертикальной, а поперечная - горизонтальной. Другими словами, все становится наоборот.</p>

        <p>Гибкая модель разметки имеет свои особенности, и некоторые свойства, что работают в блочной модели, не имеют силы в гибкой:</p>
        
        <ul class="list">
           
            <li><em>column-*</em> не имеет эфекта на гибкий контейнер;</li>
            
            <li><em>float</em> и <em>clear</em> не применимы к гибким дочерним элементам контейнера;</li>
            
            <li><em>vertical-align</em> также не имеет эфекта на дочерние гибкие элементы контейнера;</li>
            
            <li>к псевдолэлементам <em>::first-line</em> и <em>::first-letter</em> не применяются свойства гибкой модели (они не могут быть контейнерами).</li>
            
        </ul>

        <p>Следует помнить еще кое-что <a href="https://www.w3.org/TR/css-flexbox-1/#flex-items">важное</a> о гибких элементах контейнера: когда им назанчается свойство <em>display</em>, то его значения блокофицируются (даже если они строчные). На этом важное не заканчивается:</p>
        
        <ul class="list">
           
            <li>Абсолютно позиционируемые гибкие элементы не учавствуют в гибкой разметке, ведь они вылетают из потока документа вообще.</li>
            
            <li>Внешние отступы дочерних гибких элементов-соседей не схлопываются.</li>
            
            <li>Следует избегать давать процентные значения внешним и внутренним отступам для гибких элементов, поскольку это может послужить причиной разного поведения в различных браузерах.</li>
            
            <li>Порядок гибких элементв устанавливается свойством <em>order</em> вместо обычного порядка документа. Т.е. контент гибкого контейнера размечен в порядке документа, что изменяется.</li>
            
            <li>Когда даже статично позиционируемому гибкому элементу назначается свойство <em>z-index</em>, значение которого отличается от <em>auto</em>, создается контекст наложения.</li>
            
            <li>Когда гибкому элементу назначается свойство <em>visibility</em> со значением <em>collapse</em>, тогда происходит интересная фигня: гибкий элемент сжимается, не отображается при выводе, и все-таки остается сжатый элемент (как подпорка), что продолжает удерживать поперечный размер для гибкой строки. И эти сжатые элементы появляются в структуре форматирования (т.е. различные ефекты на них продолжают действовать: счетчики, анимации и другое). Все-таки есть тут один момент: такое сжатие элементов провоициует отчасти повторную проходку за гибким алгоритмом, что грузит движок. Поэтому, когда это не необходимо, лучше следует использовать <em>display: none</em>.</li>
            
            <li>Предполагаемый минимальный размер гибких элементов устанавливается как значение <em>auto</em> для свойств <em>min-width</em> и <em>min-height</em> (автоматический минимальный размер). Этот минимальный размер расчитывается на основании контента как для ширины, так и для высоты. Для свойства <em>min-width: auto</em> расчитываемым значением в основном будет выступать минимальная ширина контента (то же самое и для <em>min-height</em>). В случаях, когда гибкие размеры устанавливаются для основной области контента документа и когда его много, тогда вместо минимального размера, основанного на контенте, лучше использовать явно определенный минимальный размер (например, определяемый размер в соотношении к размеру шрифта контейнера в <em>em</em> единицах, что, в принципе, удобно, поэтому можно взять на вооружение).</li>
            
        </ul>

        <footer>
            
            <p>Ну, я наеюсь, что мой перевод и интерпретация не настолько печальны.</p>

            <p>Дальше пойдет информация по секциям, в которых будет показана работа гибкой модели.</p>
            
        </footer>
    
    </section>
    
    <section>
    
        <header>
            
            <h3><a href="https://www.w3.org/TR/css-flexbox-1/#flow-order">Порядок и ориентация</a></h3>
            
        </header>

        <p>Контент гибкого контейнера может быть размечен в любом направлении и порядке, что достигается с помощью свойств <em>flex-direction</em>, <em>flex-wrap</em> и <em>order</em>. Способность гибкой модели измененять порядок элементов влияет только на визуальное отображение, оставляя порядок изложения и навигации на основе исходника.</p>

        <div>

            <header>
                
                <h4>Свойство <a href="https://www.w3.org/TR/css-flexbox-1/#flex-direction-property"><em>flex-direction</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/2a3a91a03a0af3177688572f35c5ddd5.png" alt="flex-direction feauters">

            <p>Это свойство определяет, как гибкие элементы размещаются в гибком контейнере, устанавливая направление главной оси (т.е. определяется направление, в котором размечены элементы).</p>

            <p>Характеристика значений этого свойства:</p>

            <ul class="list">
               
                <li><em>row</em>: основная ось имеет ту же ориентацию, как ось строки текущего режима записи (это значение по умолчанию);</li>
                
                <li><em>row-reverse</em>: отличие от предыдущего в том, что основное начало и конец меняются местами;</li>
                
                <li><em>column</em>: основная ось имеет ориентацию, как у блочной оси текущего режима записи;</li>
                
                <li><em>column-reverse</em>: отличие от предыдущего в том, что основное начало и конец меняются местами.</li>
                
            </ul>

            <p>Противоположные значения меняют только направление потока - порядок не затрагивается.</p>

        </div>

        <div>

            <header>
                
                <h4>Свойство <a href="https://www.w3.org/TR/css-flexbox-1/#flex-wrap-property"><em>flex-wrap</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/f20cd9118fa2969bc97d6167dda7e462.png" alt="flex-wrap feauters">

            <p>Это свойство управляет тем, является ли гибкий контейнер однострочным, или многострочным, и еще направлением поперечной оси, определяя, как новые строки размещаются в стеке.</p>

            <p>Характеристика значений этого свойства:</p>

            <ul class="list">
               
                <li><em>nowrap</em>: гибкий контейнер однострочный (это значение по умолчанию);</li>
                
                <li><em>wrap</em>: гибкий контейнер многострочный;</li>
                
                <li><em>wrap-reverse</em>: как и предыдущее значение с тем отличием, что поперечное начало и конец меняются местами.</li>
                
            </ul>

        </div>

        <div>

            <header>
                
                <h4>Свойство <a href="https://www.w3.org/TR/css-flexbox-1/#flex-flow-property"><em>flex-flow</em></a> (краткая запись)</h4>
                
            </header>

            <img src="https://i.gyazo.com/8da51693f7949dcdeb85c9fef45242dd.png" alt="flex-flow feauters">

            <p>Это короткая запись для установления свойств <em>flex-direction</em> и <em>flex-wrap</em>, которые поределяют главную и поперечную оси гибкого контейнера.</p>

            <p>Направления для этого свойства чувствительны к режиму записи, которое в свою очередь может устанавливатся свойством <em>writing-mode</em>.</p>

        </div>

        <div>

            <header>
                
                <h4>Свойство <a href="https://www.w3.org/TR/css-flexbox-1/#order-property"><em>order</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/33564cda7497c338a938c861bf6d3b42.png" alt="order feauters">

            <p>Это свойство используется для изменения порядка, в котором гибкие элементы появляются в исходном документе. Другими словами, оно контролирует порядок, в котором появляются дочерние элементы гибкого контейнера, назначая им порядковый номер группы (значением есть целое число). Все кажется малёха сложнааа, вот только нет: представь ось Х с целочисловыми делениями направо и влево от 0, и тогда очевидно, что гибкий элемент со значением этого свойства равным -1 будет расположен первым, а элементы со значениями 0 и выше будут идти за ним. Т.е. элементы размечены, начиная с наименьшего порядкового номера группы, и если два элемента имеют равные друг другу порядковые номера, тогда они размечаются в том порядке, который в исходном документе.</p>

            <p>Это свойство следует использовать для визуального, а не логического изменения порядка контента.</p>

        </div>
    
    </section>
    
    <section>
        
        <header>
            
            <h3><a href="https://www.w3.org/TR/css-flexbox-1/#flex-lines">Гибкие строки</a></h3>
            
        </header>

        <p>Гибкие элементы в контейнере размечены и выровнены внутри гибких строк. Про строки уже говорилось, когда описывалось свойство <em>flex-wrap</em>. Напрягнем память и вспомним, что гибкий контейнер может быть или одно-, или многострочным, в зависимости от значения свойства <em>flex-wrap</em>. <strong>Однострочный</strong> гибкий контейнер размечает свои дочерние элементы в одной строке, даже если контент может выйти за пределы контейнера. <strong>Многострочный</strong> контейнер в свою очередь разбивает гибкие элементы на множество строк и когда создаются дополнительные строки, они складываются вдоль его поперечной оси согласно свойству <em>flex-wrap</em>.</p>

        <p>Когда контент разбивается на строки, каждая строка размечена независимо; гибкая длина, свойства <em>justify-content</em> и <em>align-self</em> рассматривают элементы только в одной строке за один раз.</p>

        <p>В многострочном гибком контейнере строки выравниваются с помощью свойства <em>align-content</em>. Для однострочного контейнра выравнивание строк с помощью этого свойства не имеет эфекта, поскольку поперечный размер строки равен поперечному размеру контейнера. Основной размер строки всегда равен основному размеру контейнера.</p>
        
    </section>
    
    <section>
        
        <header>
            
            <h3><a href="https://www.w3.org/TR/css-flexbox-1/#flexibility">Гибкость</a></h3>
            
        </header>

        <p>Под гибкостью стоит понимать способность изменять ширину/высоту элемента, чтобы заполнить доступное пространство в основном (главном) измерении. И эта бодяга достигается с помощью свойства <a href="https://www.w3.org/TR/css-flexbox-1/#flex-property"><em>flex</em></a>, которое является краткой записью.</p>

        <div>

            <img src="https://i.gyazo.com/8c98b423781710e2b7bb060ada812e11.png" alt="flex feauters">

            <p>Свойство <em>flex</em> определяет компоненты гибкой длины: гибкий индекс увеличения, гибкий индекс сжимания и гибкий базис. Когда оно определено, значения этого свойства принимаются во внимание вместо свойства основного размера, чтобы определить сей основной размер элемента. Вот так. А теперь изложим эти компоненты вкратце:</p>

            <ul class="list">
               
                <li>свойство <a href="https://www.w3.org/TR/css-flexbox-1/#flex-grow-property"><em>flex-grow</em></a> (длинная запись): определяет, насколько гибкий элемент увеличится относительно остальных элементов в контейнере, когда распределяется положительное свободное пространство. Другими словами, устанавливает числовое значение гибкого индекса увеличения (негативные числа не принимает в качестве значения). В случае упущения, для него устанавливается значение 1 по умолчанию.
                   
                    <img src="https://i.gyazo.com/64d8bc01da9c784828fffabb6cc8a000.png" alt="flex-frow feauters">
                    
                </li>

                <li><a href="https://www.w3.org/TR/css-flexbox-1/#flex-shrink-property"><em>flex-shrink</em></a>: определяет, насколько гибкий элемент сожмется относительно остальных элементов в гибком контейнере, когда распределяется негативное свободное пространство. Другими словами, устанавливает числовое значение гибкого индекса сжимания (негативные числа в качестве значений не принимаются). В случае упущения, для него устанавливается значение 1 по умолчанию. Гибкий индекс сжимания умножается на гибкий базовый размер, когда распределяется негативное пространство.
                   
                    <img src="https://i.gyazo.com/99c33f4ca05ac88670efd81bd67aa9cb.png" alt="flex-shrink feauters">
                    
                </li>

                <li><a href="https://www.w3.org/TR/css-flexbox-1/#flex-basis-property"><em>flex-basis</em></a>: начальный основной размер гибкого элемента перед тем, как свободное пространство будет распределено согласно гибким индексам. Другими словами, устанавливает гибкий базис.
                   
                    <img src="https://i.gyazo.com/82ce7560d6063ea728d1f9ff5cbaa60e.png" alt="flex-basis feauters">
                    
                    <p>Не будет лишним еще изложить особенности значений для этого компонента:</p>
                    
                    <ul class="list">
                       
                        <li><em>auto</em>: извлекает значение свойства основного размера элемента, как используемый гибкий базис. Если у основного размера до этого было свойство также <em>auto</em> (<em>width: auto</em>), тогда используемым значением для гибкого базиса будет <em>content</em>;</li>
                        
                        <li><em>content</em>: указывает автоматическое определение размера, что основано на контенте гибкого элемента;</li>
                        
                        <li><em>width</em>: для остальных значений это свойство обрабатывается так же, как и свойства <em>width</em> и <em>height</em>.</li>
                        
                    </ul>
                    
                </li>

                <li><em>none</em>: расширяется к <em>0 0 auto</em>.</li>
                
            </ul>

            <p>Свойство <em>flex</em> есть абсолютное и относительное: в первом случае <em>flex-basis: 0</em> и тогда все пространство распределяется (элементы получают определенную пропорцию свободного пространства в гибком контейнере), во втором <em>flex-basis: auto</em> - дополнительное пространство распределяется (когда размер элементов определен, тогда каждое положительное свободное пространство будет равномерно распределено между этими элементами). Изображение внизу для наглядности.</p>

            <img src="https://i.gyazo.com/ade07767c6c01d846248f32f8b9036a9.png" alt="absolute and relative flex">

            <p>Краткая запись <em>flex</em> может лучше приспосабливаться к большинсту общих случаев, чем ее отдельные компоненты. Это факт.</p>

            <p><a href="https://www.w3.org/TR/css-flexbox-1/#flex-common">Базовые значения</a> свойства <em>flex</em>, что наиболее распостранены:</p>

            <ul class="list">
               
                <li><em>flex: initial</em> - эквивалент <em>flex: 0 1 auto</em>;</li>
                
                <li><em>flex: auto</em> - эквивалент <em>flex: 1 1 auto</em>;</li>
                
                <li><em>flex: none</em> - эквивалент <em>flex: 0 0 auto;</em></li>
                
                <li><em>'positive number'</em> - эквивалент <em>flex: 'positive number' 1 0</em>.</li>
                
            </ul>

            <p>По умолчанию, элементы не сжимаются менее, чем установлено их минимальным размером контента (будь это длинное слово или фиксированный размер). Чтобы изменить это, следует установить для элемента свойство <em>min-width</em> и <em>min-height</em>.</p>

        </div>
        
    </section>
    
    <section>
        
        <header>
            
            <h3><a href="https://www.w3.org/TR/css-flexbox-1/#alignment">Выравнивание</a></h3>
            
        </header>

        <p>Элементы могут быть наконец выровнены внутри гибкого контейнера, когда им установлена гибкость и их измерения приобрели окончательную форму.</p>

        <div>

            <header>
                
                <h4><a href="https://www.w3.org/TR/css-flexbox-1/#auto-margins">Выравнивание с помощью внешних отступов</a> со значением <em>auto</em></h4>
                
            </header>

            <p>Особенности:</p>

            <ul class="list">
               
                <li>Во время рачсета гибкого базиса и гибкой длины внешние отступы со значением <em>auto</em> обрабатываются как 0;</li>
                
                <li>До момента выравнивания через свойства <em>justify-content</em> и <em>align-self</em> каждое положительное свободное пространство распределяется среди внешних отступов со значеним <em>auto</em> в этом измерении (если свободное пространство распределено среди внешних отступов со значением <em>auto</em>, свойства выравнивания в этом измерении не имеют никакого эфекта, потому что внешние отступы забирают все свободное оставшееся пространство после установления гибкости);</li>
                
                <li>Переполненные элементы игнорируют свои внешние отступы со значением <em>auto</em> и выходят за пределы в конце своего направления.</li>
                
            </ul>

        </div>

        <div>

            <header>
                
                <h4>Выравнивание по основной (главной) оси: <a href="https://www.w3.org/TR/css-flexbox-1/#justify-content-property">свойство <em>justify-content</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/e75ea19fd73e7c25cec5bc67b8d863c0.png" alt="justify-content feauters">

            <p>Это свойство выравнивает гибкие элементы вдоль основной оси текущей строки контейнера, распределяя дополнительное свободное пространство, что осталось после определения гибкости элементов и установления внешних отступов со значением <em>auto</em>. Это свойство также указывает некоторый контроль на выравнивание элементов, когда они выходят за пределы строки. Значения для этого свойства следующие:</p>

            <ul class="list">
               
                <li><em>flex-start</em>: гибкие элементы расположены у основного начала границы строки;</li>
                
                <li><em>flex-end</em>: гибкие элементы расположены у основного конца границы строки;</li>
                
                <li><em>center</em>: гибкие элементы расположены в центре основной оси внутри строки;</li>
                
                <li><em>space-between</em>: гибкие элементы равномерно распределены в строке основной оси. Первый элемент в строке размещается у основного начала ее границы, а последний - у основного конца. Если оставшееся свободное пространство негативное или в строке существует только один элемент, тогда это значение идентично <em>flex-start</em>;</li>
                
                <li><em>space-around</em>: гибкие элементы с пространством в пол размера с обеих сторон равномерно распределены в строке основной оси. Если оставшееся свободное пространство негативное или в строке существует только один элемент, тогда это значение идентично <em>center</em>.</li>
                
            </ul>

            <p>Иллюстрция внизу для наглядности, поскольку нет смысла тут все расписывать слово в слово. Я и так хотел сделать короткие записки, а получается то, что я практически фигачу сюда все то, что в спецификации. Сокращаю, ясен хуй, вот только отсебятины тут капиздюшка.</p>

            <img src="https://i.gyazo.com/0a7614ca02622db3f5eaea1629055824.png" alt="justify-content keywords">

        </div>

        <div>

            <header>
                
                <h4>Выравнивание по поперечной оси: <a href="https://www.w3.org/TR/css-flexbox-1/#align-items-property">свойства <em>align-items</em> и <em>align-self</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/e3c5f67f55f07c213b58d7e047579c75.png" alt="align-items feauters">

            <img src="https://i.gyazo.com/45cc0bd8dc09ae2129a7abc421b399ff.png" alt="align-self  feauters">

            <p>Свойство <em>align-items</em> устанавливает выравнивание для гибких элементов вдоль поперечной оси текущей строки контейнера, включая анонимные (безымянные) гибкие элементы. Свойство <em>align-self</em> устанавливает выравнивание для отдельного гибкого элемента, переопределяя значения свойства <em>align-items</em> (безымянные элементы выравниваются только через свойство <em>align-items</em>). Если какой-то из внешних отступов определенного элемента в поперечной оси имеет значение <em>auto</em>, тогда свойство <em>align-self</em> не будет воздействовать на него. Значения для этого свойства следующие:</p>

            <ul class="list">
               
                <li><em>flex-start</em>: гибкие элементы расположены у поперечного начала границы строки;</li>
                
                <li><em>flex-end</em>: гибкие элементы расположены у поперечного конца границы строки;</li>
                
                <li><em>center</em>: гибкие элементы расположены в центре поперечной оси внутри строки;</li>
                
                <li><em>baseline</em>: все гибкие элементы выровнены по их базовым линиям шрифтов. Если строчная ось такая же, как поперечная, тогда это значение идентично <em>flex-start</em>;</li>
                
                <li><em>stretch</em>: если свойство поперечного размера гибкого элемента расчитывается к <em>auto</em>, и ни один из внешних отступов элемента в поперечной оси не имеет значения <em>auto</em>, тогда этот гибкий элемент вытягивается. Его используемым значением является длина, необходимая, чтобы сделать поперечный размер границ блока элемента таким же, как и для строки, принимая во внимание ограничения, усановленные свойствами <em>min-height/min-width/max-height/max-width</em>. Карочи, элемент вытягиватеся на всю высоту строки (поперечный размер элемента приближается к поперечному размеру строки). Воооооот.
                   
                    <p>Если высота контейнера ограничена, это значение может стать причиной того, что контент способен выйти за пределы элемента.</p>
                    
                </li>
                
            </ul>

            <img src="https://i.gyazo.com/bfd4d50850c1a713356a88c0431840c8.png" alt="align-items keywords">

        </div>

        <div>

            <header>
                
                <h4>Укладывание гибких строк: <a href="https://www.w3.org/TR/css-flexbox-1/#align-content-property">свойство <em>align-content</em></a></h4>
                
            </header>

            <img src="https://i.gyazo.com/6e3c5fd7f5540bc445fbcccf80bc5209.png" alt="align-content feauters">

            <p>Свойство <em>align-content</em> выравнивает строки внутри гибкого контейнера, когда существует дополнителное пространство в его поперечной оси. Это свойство применяется только к многострочному гибкому контейнеру, поскольку только он может иметь свободное прострнство. Значения для этого свойства следующие:</p>

            <ul class="list">
               
                <li><em>flex-start</em>: гибкие строки расположены у поперечного начала контейнера;</li>
                
                <li><em>flex-end</em>: гибкие строки расположены у поперечного конца контейнера;</li>
                
                <li><em>center</em>: гибкие строки расположены в центре поперечной оси контейнера;</li>
                
                <li><em>space-between</em>: гибкие строки равномерно распределены по поперечной оси в контейнере. Если оставшееся свободное пространство негативное, тогда это значение идентично <em>flex-start</em>;</li>
                
                <li><em>space-around</em>: гибкие строки с пространством в пол размера с обеих сторон равномерно распределены по поперечной оси в контейнере. Если оставшееся свободное пространство негативное, тогда это значение идентично <em>center</em>;</li>
                
                <li><em>stretch</em>: строки вытягиваются, чтобы захватить оставшееся пространство. Если оставшееся пространство негативное, это значение идентично <em>flex-start</em>. В другом случае, свободное пространство делится равномерно между всеми строками, увеличивая их поперечный размер.</li>
                
            </ul>

            <img src="https://i.gyazo.com/9f4afe71f4a5af7b2d864cdfb6dfcebb.png" alt="align-content keywords">

        </div>
        
    </section>
    
    <footer>
        
        <p>Есть еще алгоритм гибкой модели разметки. Эта секция в спецификации остается информативной. Вот и пусть. На этом для гибкой модели разметки все. Тут я наебенил теорию вродь бы понятным языком, так что нужно теперь брать и пользоваться.</p>
        
    </footer>
    
</body>
</html>