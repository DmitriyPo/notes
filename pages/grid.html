<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Grid</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    
    <section>
        
        <header class="header">
            
            <h1>Сеточная модель разметки</h1>
            
        </header>
        
        <p>Я прочел <a href="https://www.w3.org/TR/css-grid-1/">спецификацию</a>, и с первого раза я нихера не понял. Сириусли. Прошелся еще разок. Итааак, сеточная разметка, дамы и господа. Начнемс.</p>
        
        <p>Она поддерживается сейчас не всюду, поскольку новая фича. Даю <a href="https://caniuse.com/#feat=css-grid">ссыль</a> и пикчу, в каких браузерах есть поддержка сетки:</p>
        
        <img src="https://gyazo.com/3f086b61190a9159f6fa4e1d69d3617a.png" alt="grid in browsers">
        
        <p>В дополнение, сюда еще будут включаться разные статьи с их дополняющей инфой. Ссылки на них будут даны в самом днище.</p>
        
        <p>Как и у гибкой модели разметки, сеточная имеет свою <a href="https://www.w3.org/TR/css-grid-1/#grid-concepts">концепцию</a>. Разметка контента тут происходит путём его размещения и выравнивания внутри сетки (воу, как неожиданно). Сетка представляет из себя набор вертикальных и горизонтальных линий, которые пересекаются, находясь внутри контейнера. Эти линии разделяют пространство контейнера на области, и внутри них  могуть быть расположены его дочерние элементы (прямые потомки, так сказать, олицетворяющие контент). С этим понятно. Есть линии сетки, которые определяют колонки и простираются вдоль оси блока (вертикальные), и перпендикулярные им, что определяют ряды и простираются вдоль оси строки (горизонтальные). Сетка изображена на изображении ниже:</p>
        
        <img src="https://i.gyazo.com/bae5a4d1892055a41493a021f5af58de.png" alt="Grid lines">
        
        <p>В общем, в сетке есть горизонтальные и вертикальные разделяющие <a href="https://www.w3.org/TR/css-grid-1/#grid-line-concept">линии</a>. На эти линии можно сослаться: или по индексу, или по имени, которое определил автор. Элемент сетки ссылается на линии, чтобы определить свою позицию внутри нее, используя соответствующие свойства для размещения,  о которых написано ниже.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-track-concept">Дорожки</a> (треки) сетки это обобщенный термин для ряда или колонки. Другими словами, это простанство между двумя соседними линиями сетки (которые параллельны) и меж которыми располагается контент (а то и промежутки между треками (гуттеры) тоже представляют из себя пространство меж двумя линиями-соседами, только это пространство пустое). Каждый трек сетки назначается функции, что определяет размер (проще говоря, трекам назначается значение, которое определяет расстояние), и это служит для того, чтобы контролировать, насколько может увеличиться ряд/колонка (колонка в ширину, ряд - в высоту), и, таким образом, насколько далеко друг от друга линии треков сетки.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-track-concept">Ячейка</a> сетки образуется путем пересечения колонки и ряда сетки. Это наименьшая единица сетки, на которую можно сослаться при определении местоположения ее элементов.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-area-concept">Область</a> сетки является пространством, используемым для того, чтобы разместить один или более элементов, образовывая для них вмещающий блок. Она содержит в себе одну или более соседних ячеек сетки и охватывает треки вместе с промежутками (гуттерами). Эта область связывется четырьмя линиями сетки (по одной с каждой стороны области) и участвует в определении размера треков сетки, которые ее пересекают. Области сетки может быть явным образом дано имя с помощью свойства <em>grid-template-areas</em> контейнера (самые простые имена, к примеру: <em>header, main, article, sidebar, footer...</em>, - что позволяет создать интуитивно понятную сетку), или неявно на нее можно сослаться за связывающими ее линиями (вот те четыре, о которых уже упоминалось). Элементы сетки назначаются области с помощью соответствующих свойств размещения.</p>
        
        <p>Свойства сетки, с помощью которых автором определяется визуальный <a href="https://www.w3.org/TR/css-grid-1/#order-accessibility">порядок</a> элементов (свойства размещения в сетке, затрагиваюшие порядок отображения), не влияют на изначальный логический порядок изложения документа - только на его визуальное представление (визуальный и логический порядок независимы).</p>
        
    </section>
    
    <section>
        
        <header class="header">
            
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-containers">Контейнер сетки</a></h3>
            
        </header>
        
        <p>Для того, чтобы сделать из элемента контейнер, в котором будет размещаться сетка, ему нужно назначить свойство <em>display</em> со значением <em>grid</em> или <em>inline-grid</em>. Первое значение превращает элемент в контейнер блочного уровня, а второе - в контейнер строчного уровня.</p>
        
        <p>Контейнер сетки устанавливает новый контекст форматирования для своего контента: разметка контента происходит внутри сетки, линии которой формируют границы вмещающего блока каждого элемента сетки.</p>
        
        <p>Некоторые приколы CSS в сетке не работают или работают с определенными особенностями. И это следующие:</p>
        
        <ul class="list">
            
            <li>Внешние отступы элементов сетки и контейнера не схлопываются.</li>
            
            <li>Свойства серии <em>column-*</em> не имеют эфекта на контейнер.</li>
            
            <li>Свойства <em>float</em> и <em>clear</em> не влияют на элемент сетки.</li>
            
            <li>Со свойством <em>vertical-align</em> та же история.</li>
            
            <li>Псевдоэлементы <em>:first-line</em> и <em>:first-letter</em> не применяются к контейнеру сетки, и контейнер сетки не участвует в их форматировании.</li>
            
            <li>Контейнеру сетки устанавливается <a href="https://www.w3.org/TR/css-grid-1/#intrinsic-sizes">размер</a>, исходя из правил контекста форматирования, в котором он участвует: блочный контекст форматирования или строчный. В обоих случаях значение <em>auto</em> это максимальный размер контента.</li>
            
            <li>Если охват области выходит за пределы сетки (в общем, когда происходит <em>overflow</em> сетки), тогда он зажимается к последней линии сетки. А если область полностью размещается за пределами сетки, тогда охват того, что вышло за пределы, будет <a href="https://www.w3.org/TR/css-grid-1/#overlarge-grids">усечен</a> до 1, создав последний дополнительный трек с соответствующей стороны, и область повторно определит свое расположение в последнем треке с определенной стороны сетки (переводчик от Бога, бля).</li>
            
        </ul>
        
    </section>
    
    <section>
        
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-items">Элементы</a> сетки</h3>
            
        </header>
        
        <p>Элементом сетки является дочерний элемент контейнера, который представляет его контент. Текст, что находится в контейнере сетки и ни во что не обернут, оборачивается в анонимный элемент сетки, который наследует стили от родителя. Элемент сетки устанавливает новый контекст форматирования для контента и участвует только в контексте форматирования сетки контейнера. Как и в случае с гибкими элементами, значения свойства <em>display</em> для элемента сетки <a href="https://www.w3.org/TR/css-grid-1/#grid-item-display">блокофицируются</a>.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-item-sizing">Размер элемента сетки</a> устанавливается внутри вмещающей его области. Есть один прикол, и заключается он в том, что размер элемента сетки при назначении ему значения <em>auto</em> может отличаться в зависимости от того, какое значение имеет свойство самовыравнивания элемента. Мне впадлу все это расписывать, учитывая, что я могу еще и хуёво перевести, поэтому фигану сюда табличку (хоть и на инглише, да пох):</p>
        
        <img src="https://i.gyazo.com/ea70238b5b5bbc8888b907f4cb8a9fe5.png" alt="Summary of automatic sizing behavior of grid items">
        
        <p>Также к элементам сетки применяется свойство <a href="https://www.w3.org/TR/css-grid-1/#order-property"><em>order</em></a>.</p>
        
        <p>А еще внешние отступы соседних элементов сетки не <a href="https://www.w3.org/TR/css-grid-1/#item-margins">схлопываются</a>. И нужно держать очко прикрытым и не использовать процентные значения для внешних и внутренних отступов, потому что это может произвести к разному поведению в разных браузерах. С внешними отступами есть также такая фича, что при назначении им значения <em>auto</em> они как бы расширяются и поглощают дополнительное пространство в соответствующем измерении, и это может использоваться для выравнивания.</p>
        
        <p>Элементы сетки могут накладываться друг на друга, когда они размещены в пересекающихся областях, или даже тогда, когда они не расположены в пересекающихся областях сетки и при этом накладываются через отрицательные внешние отступы или позиционирование. И даже, когда для элемента сетки установлено <em>position: static</em>, для него можно использовать свойство <em>z-index</em> со значениями, что отличаются от <em>auto</em>, и это создаст <a href="https://www.w3.org/TR/css-grid-1/#z-order">контекст наложения</a>. Итак, свойство <em>z-index</em> может использоваться, чтобы контролировать порядок порядок расположения элементов сетки по <em>z</em>-оси.</p>
        
        <p>Теперь осталось упомянуть про <a href="https://www.w3.org/TR/css-grid-1/#min-size-auto">предполагаемый минимальный размер</a> элементов сетки. Для элементов сетки с <em>overflow: visible</em> и которые заполняют по крайней мере один трек, чья функция определения минималного размера трека установлена как <em>auto</em>, тогда и для свойств <em>min-width/min-height</em> элемента устанавливается значение <em>auto</em>, которое применяет автоматический минимальный размер. Тем не менее, если элемент сетки охватывает (заполняет) только те треки, что имеют фиксированную функцию определения максимального размера, тогда его определенный размер и размер контента в данном измерении будет установлен как значение меньшее или равное размеру области сетки, которая охватывает эти треки, в соответствующей оси (сука, как это, бля, перевести - the stretch fit). Я ебу, как перевести написанное в спецификации, щоб не терялся смысл. Та вроде тут он присутствует, ведь елемент не должен вылазить за пределы области сетки. Вооооот, поэтому если он подходит по размеру - заебись, не подходит - подгоняется так, шоб подошел.</p>
        
    </section>
    
    <section>
        
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-definition">Определение сетки</a></h3>
            
        </header>
        
        <p>Три этих свойства устанавливают <a href="https://www.w3.org/TR/css-grid-1/#explicit-grids">явно определенную сетку</a>: <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>. Чтобы не писать всю эту кучу свойств, существует краткая запись для них - свойство <em>grid</em>. Конечная сетка может оказаться больше из-за элементов, что расположены за пределами явно определенной сетки; в этом случае будут автоматически созданы неявные треки, размер которых будет определен свойствами <em>grid-auto-rows</em> и <em>grid-auto-columns</em>.</p>
        
        <p>Размер явно определенной сетки устанавливается через свойства <em>grid-template-rows</em>/<em>grid-template-columns</em>, с помощью которых определяются размеры треков, их количество и имена их линий, а с помощью свойства <em>grid-template-areas</em> можно создать такую себе карту сетки, в которой прописаны имена для треков и явно показано их количество, определяя тем самым области. Всякие ряды/колонки, выраженные с помощью свойства <em>grid-template-areas</em>, при этом размеры которых не были определены с помощью свойств <em>grid-template-rows</em>/<em>grid-template-columns</em>, берут свои размеры от свойств <em>grid-auto-rows</em>/<em>grid-auto-columns</em>. Ну, а если и таких нема, тогда ебашится значение <em>auto</em>.</p>
        
        <p>Числовые индексы в свойствах размещения в сетке считаются от границ явно определенной сетки. Существуют положительные и отрицательные значения для индексов в зависимости от того, с какой стороны сетки ведется подсчет.</p>
        
        <div>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#track-sizing">Явное определение размера треков</a>: свойства <em>grid-template-rows</em> <em>grid-template-columns</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/de508f8ce88ac6a05d32261dd9cee983.png" alt="grid-template-columns, grid-template-rows properties">
            
            <p>Эти свойства определяют имена линий сетки и размер треков, и вместе весь этот набор формирует список - трек-лист. Свойство <em>grid-template-rows</em> определяет трек-лист для рядов сетки (в общем, указываем имя и высоту для рядов), а <em>grid-template-columns</em> - для колонок сетки (а тут у нас, по сути, имя и ширина колонок).</p>
            
            <p>Значение этих свойств означает следующее:</p>
            
            <ul class="list">
                
                <li><em>none</em>: означает, что никакие явно определенные треки этим свойством не создаются (хотя явно определенные треки сетки могут быть созданы с помощью свойства <em>grid-template-areas</em>). В случае отсуствия явно определенной сетки образовывается неявная.</li>
                
                <li>'track-list/auto-track-list': устанавливает трек-лист функций определения размера треков и имен линий сетки. Каждая функция определения размера трека может быть установлена как: расстояние; процентное значение от размера контейнера сетки; размер, что отталкивается от контента, занимающего ряд или колонку; или часть свободного пространства в сетке. Это также может быть установлено как диапазон, используя функцию <em>minmax()</em>, которая может объединить в себе каждый из ранее упомянутых типов значений, чтобы определить диапазон от минимального до максимального размера трека сетки (надыбал статью о том, как работает <a href="https://bitsofco.de/how-the-minmax-function-works/"><em>minmax()</em></a>, и, кажись, это та штука, от которой мона кончить, так што уделю этому время).</li>
                
            </ul>
            
            <p>Трек-лист вмещает в себя дофига всякого, и выглядит это следующим образом:</p>
            
            <img src="https://i.gyazo.com/bc78893a226c73c691ba2dfb6dc1e43e.png" alt="syntax of a track list">
            
            <p>Где:</p>
            
            <ul class="list">
                
                <li><a href="https://drafts.csswg.org/css-values-4/#typedef-length-percentage"><em>'length-percentage'</em></a>: значение расстояния или процентное его выражение;</li>
                
                <li><a href="https://www.w3.org/TR/css-grid-1/#typedef-flex"><em>'flex'</em></a>: пространство с единицей измерения <em>fr</em>, что определяет долю свободного пространства в контейнере сетки (с его помощью разделяется оставшееся пространство в соответствующей треку пропорции);</li>
                
                <li><em>'max-content'</em>: представляет наибольшее максимальное значение контента элементов сетки, что занимают трек;</li>
                
                <li><em>'min-content'</em>: представляет наибольшее минимальное значение контента элементов сетки, что занимают трек;</li>
                
                <li><em>'minmax(min, max)'</em>: определяет диапазон, в котором первый аргумент соответствует функции определения минимального размера трека, а второй - функции определения максимального размера трека (устанавливает минимальный и максимальный размер для трека, позволяя сетке работать в этом диапазоне);</li>
                
                <li><em>'auto'</em>: как максимум, идентично максимальному размеру контента (т.е. во всех случаях обрабатывается как 'max-content'). А как минимум, представляет наибольший минимальный размер элементов сетки, что занимают трек (этот размер определяется свойствами <em>min-width/min-heigh</em>);</li>
                
                <li><em>'fit-content('length-percentage')'</em>: представляет формулу <em>min(max-content, max(auto, argument))</em>, что расчитывается подобно <em>'auto'</em> (<em>minmax(auto, max-content)</em>), за исключением того, что размер трека фиксируется в аргументе, если он больше, чем минимальное значение для <em>'auto'</em>.</li>
                
            </ul>
            
            <article>
                
                <header class="header header--center">
                    
                    <h4>Работа функции <a href="https://bitsofco.de/how-the-minmax-function-works/">minmax()</a></h4>
                    
                </header>
                
                <p>Эта функия принимает два аргумента: минимальное и максимальное значение. Трек не станет меньше определенного значения в первом аргументе и не займет пространства больше, чем значение, которое определено во втором аргументе. (Заметка: если для второго параметра было определено значение, которое является меньше минимального значения в первом, тогда второй игнорируется и функция обрабатывается, как представляющая исключительно минимальное значение.) Функция <em>minmax()</em> принимает 6 типов значений:</p>
                
                <ol class="list">
                   
                    <li><strong>Расстояние</strong>.
                    
                        <img src="https://i.gyazo.com/f8fd32c297a85ae8866715a6406a29fb.png" alt="example#1">
                    
                    </li>
                    
                    <li><strong>Процентное выражение</strong>.
                    
                        <img src="https://i.gyazo.com/f12b00a706d02b3ae9cd3b9e5e1dcf62.png" alt="example#2">
                    
                    </li>
                    
                    <li><strong>Гибкое расстояние</strong>. Это расстояние использует единицу <em>fr</em>, которая представляет долю свободного пространства в контейнере сетки. На даный момент эта единица может использоваться только как макисмальное значение в функции <em>minmax()</em> (в спецификации пообещали, что в будущем это измениться, и даный тип значений будет применим и для минимального значения).
                    
                        <img src="https://i.gyazo.com/44367affa3bd1ed72a087e3d66af9f77.png" alt="example#3">
                    
                    </li>
                    
                    <li><strong>max-content</strong>. Это наименьшее возможное значение, которое может иметь ячейка, при этом ячейка идеально подгоняется под размер контента. Т.е. берется наибольшее возможное значение для ячейки (например, если в ячейке дано целое предложение, то ширина ячейки будет соответсвовать этому предложению). 
                    
                        <img src="https://i.gyazo.com/65f499f821944358c8d9533420c6f6e9.png" alt="example#4">
                    
                    </li>
                    
                    <li><strong>min-content</strong>. Это наименьшее возможное значение, которое не приводит к переполнению ячейки, если только таково не является неизбежным. Т.е. берется наименьшее возможное значение для ячейки (например, если в ячейке дано предложение, то ее ширина будет соответствовать длиннейшему слову).
                    
                        <img src="https://i.gyazo.com/1c3541ef0d0121b39066135253697e98.png" alt="example#5">
                    
                    </li>
                    
                    <li><strong>auto</strong>. Это значение имеет разный смысл в зависимости от того, используется ли оно как минимальное или как максимальное значение в функции <em>minmax()</em>. Если используется как максимум, тогда это значение эквивалентно <strong>max-content</strong>, а если как минимум, тогда оно представляет наибольшее минимальное значение для ячейки, что устанавливается как <em>min-width/min-height</em> и не является эквивалентом <strong>min-content</strong>.
                    
                        <img src="https://i.gyazo.com/96cf9733c909eaa69e23f019f45e82b5.png" alt="example#6">
                    
                    </li>
                    
                </ol>
                
                <p>Эта функция позволяет построить адаптивный дизай сетки без медиа-запросов.</p>
                
                <img src="https://i.gyazo.com/0da85af4aae7a897ff001fd5769de901.png" alt="example#7">
                
                <p>Функция <em>repeat()</em> позволяет установить одинаковое значение для множества треков (колонок, в нашем случае) и принимает два значения: первое - количество повторений, а второе - значение, которое повторяется. <em>auto-fit</em> используется как количество повторений и гибко может менять количество треков, которые повторяются, в зависимости от даного им размера (в нашем случае, это ширина колонок). Есть и ограничение: это работает, когда треки имеют одинаковый размер.</p>
                
                
            </article>
            
            <p>Итак, что касается определения размеров в сетке, то есть фиксированные (расстояние и процентное его выражение ('length-percentage')), свойственные (<em>'min-content', 'max-content', 'auto', 'fit-content()'</em>) и гибкие ('flex') функции определения размера.</p>
            
            <p>Заметка: размер сетки не целиком состоит из размеров треков сетки, потому что сюда еще вмешиваются следующие свойства: <em>grid-row-gap, grid-column-gap, justify-content, align-content</em>, так как они могут добавить дополнительное пространство между треками.</p>
            
            <p>Чтобы понять прикол, я тут еще проиллюстрирую примеры, поскольку не все на первый взгляд ясно-понятно. Вверху по картинке с составлящими трек-листа видно, что трек-лист являет собой список, где значения разделены не запятыми, а пробелами. Поэтому когда мы будем прописывать значения размера трека в нашем трек-листе, это будет выглядеть так:</p>
            
            <img src="https://i.gyazo.com/bfd5e86e6c025b8543b48d94d6a614d8.png" alt="grid-template-columns example">
            
            <p>Тут были взяты просто размеры треков, без имен для линий сетки. Каждое значение размера трека создает колонку, поэтому количество линий сетки, на которые можно сослаться, определяется так: количество колонок + 1 (что логично). Итак, согласно этому примеру были созданы 4 колонки с помощью пяти линий сетки, между которыми пространство распределяется согласно значениям размеров треков.</p>
            
            <p>Есть еще один момент: если сумма фиксированных и свойственных размеров треков (<em>100px, max-content, min-content</em>) больше, чем размер сетки, тода гибкие размеры (<em>1fr</em>) обрабатываются как нулевое значение, и конечная линия сетки будет находится на расстоянии суммы этих фиксированных и свойственных размеров от начальной линии сетки. А если сумма этих элементов меньше размера сетки, тогда конечная линия сетки будет находится у границы, где сетка заканчивается, и свободное пространство распределяется между данными гибкими размерами.</p>
            
            <p>И еще немного примеров валидных определений для треков сетки:</p>
            
            <img src="https://i.gyazo.com/c4021dea77570812e8a2ed8777728e9c.png" alt="Additional examples of valid grid track definitions">
            
            <article>
                
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#named-lines">Именуемые</a> линии сетки: синтаксис <em><a href="https://drafts.csswg.org/css-values-4/#identifier-value">'custom-ident'</a></em></h4>
                    
                </header>
                
                <p>На линии сетки можно сослаться за их числовым индексом, а еще им можно назначить имя, что более понятно и проще отлаживать. Имена линиям сетки можно явно назначить с помощью свойств <em>grid-template-rows</em> и <em>grid-template-columns</em>, или неявно, создавая именованые области сетки с помощью свойства <em>grid-template-areas</em>.</p>
                
                <p>Проще тут навести еще один пример, который дает осмысленные имена для всех линий сетки (у некоторых линий несколько имен) и показывает их числовые индексы:</p>
                
                <img src="https://i.gyazo.com/b61829235b8451f798feb50e45a04eb2.png" alt="Code for Named Grid Lines">
                
                <img src="https://i.gyazo.com/ea9ce379c2abc17367b5a752ba94a629.png" alt="Named Grid Lines">
                
                <p>И следует заметить, что линиям сетки не может быть назначено имя <em>'span'</em>.</p>
                
            </article>
            
            <div>
                
                <header class="header header--center">
                   
                    <h4>Повторяющиеся колонки и ряды: обозначение <a href="https://www.w3.org/TR/css-grid-1/#repeat-notation"><em>repeat()</em></a></h4>
                    
                </header>
                
                <p>Обозначение <em>repeat()</em> представляет повторяющийся фрагмент трек-листа, позволяя большому числу колонок и рядов, что выдают повторяющийся шаблон, быть прписаными в более компактной форме. Без примера тут не обойтись, поэтому вот:</p>
                
                <img src="https://i.gyazo.com/3d8c8ca5c187a0e7d36c8b3a628c4f40.png" alt="repeat() notation">
                
                <p>Этот пример создает четыре колонки, которые окружают межстолбцовые промежутки (gutters) в <em>10px</em>.</p>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4 class="header__item header__item--notbold"><a href="https://www.w3.org/TR/css-grid-1/#repeat-syntax">Синтаксис <em>repeat()</em></a></h4>
                            
                    </header>
                    
                    <p>Обычная форма обозначения <em>repeat()</em>:</p>
                    
                    <img src="https://i.gyazo.com/750b4cd54f90ed63708cd823de8d3309.png" alt="repeat() form">
                    
                    <p>Первый аргумент определяет число повторений, а второй - трек-лист, который повторяется определенное в первом аргументе количество раз. Есть некоторые ограничения: обозначения <em>repeat()</em> не могут быть вложенными друг в друга и автоматические повторения не могут быть со всех сторон объеденены с присущими (<em>min-content, max-content, auto, fit-content()</em>) или гибкими (<em>'flex'</em>) размерами (т.е. будет использоваться только фиксированный тип значений, а если используется функция <em>minmax()</em>, то один из ее аргументов обязательно будет иметь фиксированный тип значения).</p>
                    
                    <img src="https://i.gyazo.com/041f3800c81fe43ab8db50502614b0ad.png" alt="fixed size">
                    
                    <p>Таким образом, точный синтаксис обозначения repeat() имеет несколько форм:</p>
                    
                    <img src="https://i.gyazo.com/1ab76f160936dff3845ef0d9d2020ad2.png" alt="repeat() notation forms">
                    
                    <p>Первый вариант <em>track-repeat</em> может представить повторение каждого размера трека, при этом он ограничен установленным количеством повторений. <em>auto-repeat</em> может повторять размер трека, чтобы до победного заполнить пространство, при этом треубет фиксированные явно определенные размеры для треков, поэтому число повторений можно расчитать, и в трек-листе это обозначение может появится только один раз, хотя тот же трек-лист может вмещать в себе обозначение <em>fixed-repeat</em>.</p>
                    
                    <p>Если функция <em>repeat()</em> сводится к тому, что размещаются две именованные линии, соседние друг другу, тогда список имен объединяется (<em>'repeat(2, [a] 1fr [b])'</em> эквивалентно <em>'[a] 1fr [b a] 1fr [b]'</em>).</p>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4 class="header__item header__item--notbold"><a href="https://www.w3.org/TR/css-grid-1/#auto-repeat">Повторение до полного заполнения: <em>auto-fill</em> и <em>auto-fit</em></a></h4>
                            
                    </header>
                    
                    <p>Когда <em>auto-fill</em> дано как число повторений трека, и если контейнер сетки имеет явно определенный размер, или максимальный размер в определенной оси, тогда оно является наибольшим возможным числом, которое не позволит сетке переполнить свой контейнер с учетом того, что каждый трек получает свой размер (в общем, с определенными размерами для треков происходит заполнение контейнера сетки до усёру); а если любое число повторений переполнит контейнер, тогда будет только 1 повторение (заметочка: каждый трек рассматривается как имеющий функцию определения максимального размера, если это явно определено; в случае, когда трек рассматривается как имеющий функцию определения минимального размера, тогда в расчет дополнительно берется свойство <em>grid-gap</em> с его значениями). В случае, если контейнер сетки имеет явно определенный минимальный размер в соответствующей оси, тогда число повторений это наименьшее возможное число, что удовлетворяет это минимальное требование размеру сетки (если удовлетворения этому требованию не происходит, тогда трек-лист повторяется тоолько один раз).</p>
                    
                    <p><em>auto-fit</em> ведет себя почти одинаково, только с тем различием, что после размещения элемента сетки любой пустой повторяющийся трек схлопывается. Пустой трек такой, что не имеет размещенных в своем потоке элементов, или элементов, занимающих трек вдоль него.</p>
                    
                    <p>Схлопнутый трек рассматривается, как имеющий фиксированную функцию определения размера <em>0px</em>, и промежутки с каждой его стороны схлопываются (включая каждое пространство, что выделено для распределенного выравнивания).</p>
                    
                    <p>Еще <em>auto-fill</em> хорошо сочетается с <em>minmax()</em>, поскольку это придает больше уверености, что контейнер будет заполнен максимально. Почему? А потому, что <em>auto-fill</em> будет репитить треки, значение которых будет равно первому (минимальному) аргументу <em>minmax()</em>, до тех пор, пока не будет создано их максимальное количество, которые потом расширяются вплоть до максимального значения (что равно второму аргументу), чтобы заполнить контейнер под завязку.</p>
                </article>
                
            </div>
            
            <article>
            
                <header class="header header--center">

                    <h4><a href="https://www.w3.org/TR/css-grid-1/#fr-unit">Гибкое расстояние</a>: единица измерения <em>'fr'</em></h4>

                </header>

                <p>Гибкое расстояние или <em>'flex'</em> это значение, что измеряется в фракционных (т.е. разбивающих на части) единицах <a href="https://www.w3.org/TR/css-grid-1/#algo-find-fr-size"><em>fr</em></a>, которые представляют долю свободного (доступного) пространства в контейнере сетки.</p>
                
                <img src="https://i.gyazo.com/a501c9ead796b394584a865a0b28dd67.png" alt="example">
                
                <p>Эта хрень означает, что берется пространство контейнера сетки, которое потом разделяется на сумму этих фракционных единиц (<em>4fr</em>) и, таким образом, находится расстояние равное <em>1fr</em>. Далее получившееся расстояние умножается на присущее каждому треку гибкое расстояние, в результате чего свободное пространство контейнера пропорционально разделяется среди треков. В результате получается, что первый трек займет половину доступной ширины, а остальные два - по четверти от этой ширины.</p>
                
                <p>Рассмотрим еще пример. Допустим, есть такое обьявление:</p>
                
                <img src="https://i.gyazo.com/c2fa6f4b7e55e55cd97d0b11cabf8d8b.png" alt="example">
                
                <p>Cначала все функции определения размера должны достигнуть своего максимального значения: находятся фисированные и свойственные (<em>intrinsic</em>) размеры. Тога сумма таких размеров (<em>300px + 20%</em>) для треков извлекается из общего пространства, и создается свободное, которое потом разделяется на сумму гибких единиц (<em>1fr + 3fr</em>) и распределяется пропорционально среди оставшихся треков (определяются размеры для фракционных треков). Формула расчета следующая:</p>
                
                <img src="https://i.gyazo.com/d6065d6e39bca17b71adae693267d7d7.png" alt="fr formula">
                
                <p>Есть некоторые ограничение в использовании фракционных единиц: их нельзя использовать в функции <em>calc()</em>.</p>

                <p>Если сумма гибких коэффциентов меньше, чем 1, тогда она записывается к 1 и свободное пространство распределяется на соответствующие доли (подобно тому, как это происходит в гибкой модели разметки).</p>

                <p>В том случае, когда свободное пространство безграничное (контейнер сетки в этом случае имеет неопределенную ширину или высоту), гибкие треки сетки определяют свой размер согласно контенту, сохраняя в это время соответствующие пропорции. Используемый размер каждого гибкого трека сетки расчитывается путем определения их максимального размера контента (<em>max-content</em>) и разделения этого размера на соотвествующий гибкий коэффициент, чтобы определить гипотетический размер <em>1fr</em>. Максимальное из этих значений используется как обработанное расстояние <em>1fr</em> (гибкая доля), которое потом умножается на каждый гибкий коэффициент трека сетки, чтобы определить конечный размеркаждого трека. Хммм...</p>

            </article>

            <article>

                <header class="header header--center">

                    <h4><a href="https://www.w3.org/TR/css-grid-1/#resolved-track-list">Обрабатываемые значения</a></h4>

                </header>

                <p><em>grid-template-rows</em> и <em>grid-template-columns</em> являются свойствами со значениями, что обрабатываются по особенному. Обрабатываемые значения этих свойств для контейнера сетки это используемые значения, что упорядочены следующим образом:</p>

                <ul class="list">

                    <li>определяется каждый явно или неявно созднный трек;</li>

                    <li>каждый размер трека дается как расстояние в пикселях, независимо от функции определения размера;</li>

                    <li>прилегающий пробег двух или более треков, что имеют одинаковый размер и связанные имена линий может быть упорядоченый с помощью <em>repeat()</em>.</li>

                </ul>

                <p>В ином случае, когда элемент не является контейнером сетки или имеет свойство <em>display: none</em>, обрабатываемые это просто расчитанные значения. Пока хз, чем эта инфа может быть полезной.</p>

            </article>
            
        </div>
        
        <div>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-template-areas-property">Именуемые области</a>: свойство <em>grid-template-areas</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/f05089e7b6adfdda0594b1ebbf8ff8de.png" alt="grid-template-areas-property">
            
            <p>Это свойство определяет именованную область сетки, которая не связана с каким либо определенным элементом сетки, при этом на нее можно ссылаться с помощью свойств размещения в сетке. Синтаксис этого свойства предоставляет визуализацию структуры сетки. Значения имеют такое смысловое содержание:</p>
            
            <ul class="list">
               
                <li><em>none</em>: именованных областей сетки не определено;</li>
                
                <li><em>'string +'</em>: ряд создается каждой отдельной строкой, определенной свойством <em>grid-template-areas</em>, а колонка создается для каждой ячейки в этой строке, которая обрабатывется следующим образом:
                
                    <ul class="list">
                        
                        <li>Строка разбивается на токены, такие как:
                        
                            <ul class="list">
                                
                                <li>токен именованной ячейки, что состоит из последовательности <a href="https://www.w3.org/TR/css-syntax-3/#name-code-point">кодовых точек имени</a> (name code point) и создает именованную область сетки с таким же именем. Несколько токенов именованых ячеек внутри и между рядами создают одну именованную область сетки, которая охватывает соответствующие ячейки сетки;
                                
                                    <img src="https://i.gyazo.com/710995e6e30346e2b54b891dcc7f7d51.png" alt="grid-template-areas example">
                                
                                </li>
                                
                                <li>токен нулевой ячейки, что представлен последовательностью одной или более "." и обозначает безымянную область в контейнере сетки;</li>
                                
                                <li>последовательность пробелов, которые ничего не представляют;</li>
                                
                                <li>"мусорный" токен, который представляет из себя последовательность других символов, является синтаксической ошибкой и делает обьявление недействительным.</li>
                                
                            </ul>
                        
                        </li>
                        
                        <li>Все строки должны иметь одинаковое число колонок, а иначе обьявление недействительное. Если именованная область сетки охватывает несколько ячеек сетки, и при этом они не формирует единственный заполненный прямоугольник, тогда обьявление недействительное.</li>
                        
                    </ul>
                
                </li>
                
            </ul>
            
            <article>
               
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-named-lines">Неявно именованые линии</a></h4>
                    
                </header>
                
                <p>Свойство <em>grid-template-areas</em> создает неявно именованые линии от именованых областей сетки. Типа, именованная область с именем 'blyat' создает именованые линии 'blyat-start', 'blyat-end' для горизонтальных замыкающих линий области (меж ними размещаются ряды) и 'blyat-start', 'blyat-end' для вертикальных замыкающих линий области колонки (меж этими размещаются колонки).</p>
                
            </article>
            
            <article>
                
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-named-areas">Неявно именованые области</a></h4>
                    
                </header>
                
                <p>Так как на именованые области сетки ссылаются с помощью неявно именованых линий, которые они производят, явно добавленные замыкающие линии с именем такой же формы (<em>'blyat-start'/'blyat-end'</em> в двух осях для четырех линий, которые создадут прямоугольник) формируют именованную область сетки ('blyat'). На эти неявно именованые области сетки можно ссылаться через свойства размещения в сетке.</p>
                
            </article>
            
        </div>
        
        <article>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#explicit-grid-shorthand">Краткая запись явно определенной сетки</a>: свойство <em>grid-template</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/c1d14415d44893e8a0a4f68e5afc95d6.png" alt="grid-template">
            
            <p>Это свойство для краткой записи свойств <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>. Поскольку это краткая запись для трех свойств, то и значения тут не в рот ебись, поэтому рассмотрм этот адский синтаксис:</p>
            
            <ul class="list">
            
                <li><em>none</em>: устанавливает значения все трех свойств к их начальному значению <em>none</em>;</li>
                
                <li><em>'grid-template-rows'/'grid-template-columns'</em>: записывает определенные значения для свойств <em>grid-template-rows</em> и <em>grid-template-columns</em> соответственно, и устанавливает для свойства <em>grid-template-areas</em> значение <em>none</em>;
                
                    <p>Выглядит это так:</p>
                
                    <img src="https://i.gyazo.com/69992a2dac9f94eb28705a69b352d223.png" alt="first example of grid-template">
                    
                    <p>И это эквивалентно следующему:</p>
                    
                    <img src="https://i.gyazo.com/6903a7ec1aeb36a845311365784a2e7c.png" alt="equivalent to first exaple of grid-template">
                
                </li>
                
                <li><em>'[ 'line-names' ? 'string' 'track-size' ? 'line-names' ? ] + [ / 'explicit-track-list' ] ?'</em>:
                
                    <ul class="list">
                    
                        <li>устанавливает свойство <em>grid-template-areas</em> для перечисленных текстовых строк (<em>'string'</em>);</li>
                        
                        <li>устанавливает свойство <em>grid-template-rows</em> к значению размера трека (<em>'track-size'</em>), следуя за каждой строкой (заполняя пропущенные значения как <em>auto</em>), обьединяя каждый ряд с помощью именованых линий, определенных перед/после каждого размера (<em>'line-names'</em>);</li>
                        
                        <li>устанавливает свойство <em>grid-template-columns</em> к значению трек-листа (<em>'explicit-track-list'</em>), который определен после слэша (или <em>none</em>, если трек-лист не определен).</li>
                        
                    </ul>
                    
                    <p>Пример для наглядности:</p>
                    
                    <img src="https://i.gyazo.com/7030f4cda0a7aacfe59bf024374872f2.png" alt="second example of grid-template">
                    
                    <p>Что эквивалентно:</p>
                    
                    <img src="https://i.gyazo.com/2a2335137a9d2b7fb96f9a1c401e68ab.png" alt="equivalent to second exaple of grid-template">
                    
                    <p>И создает такую сетку:</p>
                    
                    <img src="https://i.gyazo.com/ea1ab9d3b5656f813b6c70308b93e6b5.png" alt="created grid from second exaple of grid-template">
                
                </li>
                
            </ul>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-grids">Неявно определенная сетка</a></h4>
                
            </header>
            
            <p>Свойства <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em> определяют фиксированное число треков, что формируют явно определенную сетку. Когда элементы сетки расположены вне этих ограничений, контейнер сетки создает неявно определенные треки сетки путем добавления неявных линий сетке. Эти линии вместе с явно определенной сеткой образовывает неявно определенную сетку. Свойства <em>grid-auto-rows</em>, <em>grid-auto-columns</em> устанавливают размер для этих неявно определенных треков.</p>
            
            <p>Свойство <em>grid-auto-flow</em> контролирует автоматическое расположение элементов сетки без их явно определенного размещения. Когда явно определенная сетка заполнена, или если ее не существует, тогда автоматическое размещение будет причиной образования неявно определенных треков сетки.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#auto-tracks">Установление размера</a> для неявно определенных треков сетки: свойтсва <em>grid-auto-rows</em> и <em>grid-template-columns</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/5c7fce79c17c81564e60fec228aea4de.png" alt="implicit grid tracks">
            
            <p>Если элемент сетки размещен в внутри ряда или колонки, размер которого явно не установлен с помощью свойств <em>grid-template-rows</em> и <em>grid-template-columns</em>, создаются неявно определенные треки, чтобы удержать его внутри себя. Это может произойти либо путем явного расположения внутри ряда или колонки, что находятся за пределами сетки, либо с помощью алгоритма автоматического размещения, создающего дополнительные ряды или колонки. Свойства <em>grid-auto-rows</em> и <em>grid-auto-columns</em> устанавливают размер таких неявно созданных треков.</p>
            
            <p>Пример для наглядности:</p>
            
            <img src="https://i.gyazo.com/9041c04c0c22d084437672bd7f8be3e3.png" alt="styles and layout">
            
            <p>И бралалалам! Получили такую вот сетку:</p>
            
            <img src="https://i.gyazo.com/49c568a9b4a81bfdf73b2dc315ebbdae.png" alt="grid from grid-auto-* properties">
            
        </article>
        
        <article>
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-auto-flow-property">Автоматическое размещение</a>: свойство <em>grid-auto-flow</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/07c869eb66f4f6a824e7cf4f6baca3ab.png" alt="grid-auto-flow property">
            
            <p>Элементы сетки, которые не размещены явно с помощью свойств, описанных выше, автоматически размещаются внутри незанятого пространства в контейнере сетки, в чем помогает <a href="https://www.w3.org/TR/css-grid-1/#grid-item-placement-algorithm">алгоритм автоматического размещения</a>. Свойство <em>grid-auto-flow</em> контролирует, как этот алгоритм работает, определяя, как именно элементы будут автоматически размещены в потоке сетки, осуществляя поиск вдоль рядов и добавляя их, или вдоль колонок и также добавляя их, если необходимо. Итак, это свойство принимает следующие значения:</p>
            
            <ul class="list">
               
                <li><em>'row'</em>: упомянутый алгоритм размещает элементы, заполняя каждый ряд поочереди, добавляя новые при необходимости. Заполнение треков, что определяют ряды, элементами происходит слева направо (в зависимости от режима направления) до того момента, пока не закончатся свободные колонки, и тогда происходит переход на следующий ряд. Если никакое значение не указано (<em>'row'</em> или <em>'column'</em>), предполягается, что это будет <em>'row'</em>;</li>
                
                <li><em>'column'</em>: алгоритм размещает элементы, заполняя каждую колонку поочереди, добавляя новые при необходимости. Заполнение треков, что определеяют колонки, элементами происходит сверху вниз до того момента, пока не закончатся свободные ряды, и тогда происходит переходит на следующую колонку;</li>
                
                <li><em>'dense'</em>: если это значение определено, тогда ауто-плейсед алгоритм использует плотный упаковочный алгоритм. (шо, бля?) Он делает попытку заполнить дыры в сетке, оставленные элементами покрупнее раньше, если позже появятся элементы поменьше. (...) Это может стать причиной появления элементов не по порядку и они при этом заполнят дыры, что были оставлены более крупными элементами. Вооооот. А если оно упущено, тогда используется по умолчанию неплотный (разреженный) алгоритм упаковки <em>'sparse'</em>, в котором ауто-плейсед алгоритм двигается вперед, когда размещает элементы в сетке, и не пытается заполнить дыры, ведь ему на них похуй, поскольку по умолчанию он движется последовательно и не возвращается назад, чтобы заполнить пространство. Это даст гарантию, что все элементы, размещенные таким образом, будут идти по порядку, и срать на то, что могут остаться дыры, которые могли бы быть позже заполнены элементами.</li>
                
            </ul>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-shorthand">Краткая запись определения сетки</a>: свойство <em>grid</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/6f250a73c9a623216c6145cc451b560f.png" alt="grid property">
            
            <p>Свойство <em>grid</em> это краткая запись, что записывает все свойства явно определенной сетки (<em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>), свойства неявно определенной сетки (<em>grid-auto-rows</em>, <em>grid-auto-columns</em> и <em>grid-auto-flow</em>) и свойства гуттеров (<em>grid-column-gap</em> и <em>grid-row-gap</em>) в одном объявлении. Свойства гуттеров единственные, которые могут быть сброшены; остальные субсвойства могут быть заданы либо через синтаксис <em>grid-template</em>, либо через дополнительную синтаксическую форму для определения сеток в автоматическом потоке. Суууукаааа. В общем объявление свойства <em>grid</em> строится на том, что может использоваться два варианта комбинаций, как это показано ниже:</p>
            
            <ul class="list">
                
                <li><em>'grid-template-rows' / [ auto-flow && dense ? ] 'grid-auto-columns' ?</em> - тут явно определенные ряды и неявно - колонки;</li>
                
                <li><em>[ auto-flow && dense? ] 'grid-auto-rows' ? / 'grid-template-columns'</em> - здесь уже имеем комбинацию неявно определенных рядов сетки и явно - колонок.</li>
                
            </ul>
            
            <p>Вот, что пишет спецификация: устанавливается автоматический поток, что делается с помощью записи явно определенных треков в какой-то  одной оси (т.е. через какое-то одно из двух свойств: либо <em>grid-template-rows</em>, либо <em>grid-template-columns</em>, - а оставшееся тогда записывается к значению <em>none</em>) и указания, как треки будут автоматически повторятся в другой оси (и опять таки записывается значение для одного из двух свойств, неявно определяющих треки: <em>grid-auto-rows</em> или <em>grid-auto-columns</em> - а то свойство, что осталось нетронутым, будет иметь значение <em>none</em>). Свойству <em>grid-auto-flow</em> также записываются значения либо <em>row</em>, либо <em>column</em> соответственно вместе с <em>dense</em>, если то определено.</p>
            
            <p>Все остальные субсвойства сбрасываются к их исходным значениям.</p>
            
            <p>Итак, можно указать только явно или неявно определенные свойства сетки для какой-то из осей в объявлении <em>grid</em>. Остальные свойства, что не были указаны, будут иметь свои исходные значения, а свойства для гуттеров сбрасываются этой краткой записью, даже если они и не могут быть ею установлены. Т.е. это свойство немножечко гандон.</p>
            
            <p>Ну и куда же без примеров. Тем более, что тут они полюбасу нужны. Вооооот:</p>
            
            <ul class="list">
               
                <li>запись <em>grid: auto-flow 1fr / 100px;</em> сотворит такое: 
                    
                    <img src="https://i.gyazo.com/cebfff8035f1257317ccc1f669cfe4c3.png" alt="example">
                    
                </li>
                
                <li>а эта <em>grid: none / auto-flow 1fr;</em> такое:
                
                    <img src="https://i.gyazo.com/c86c84b56feac955f4b0a6bfbde59807.png" alt="example">
                
                </li>
                
            </ul>
            
        </article>
        
        <p>И еще: сетка перерасчитывается каждый раз, когда страница перезагружается, вот только она себя так не ведет, когда меняется размер окна. Хууууухх... Идем дальше.</p>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#placement">Размещение</a> элементов сетки</h3>
            
        </header>
        
        <p>Каждый элемент сетки имеет область, что представляет из себя набор ячеек (именно их элементы и занимают). Эта область определяет вмещающий блок для элемента сетки, внутри которого свойства самовыравнивания (<em>justify-self</em> и <em>align-self</em>) устанавливают фактичскую позицию элементов. Ячейки сетки также влияют на определение размеров треков сетки.</p>
        
        <p>Местоположение области элемента внутри сетки определяется ее размещением, что состоит из положения (<em>grid position</em>) и охвата (<em>grid span</em>) в сетке:</p>
        
        <ul class="list">
           
            <li><em>grid position</em> - местоположение элемента в сетке. Положение может быть или явно указаным, или установленым автоматическим алгоритмом размещения;</li>
            
            <li><em>grid span</em> - сколько треков сетки занимает элемент (т.е. на сколько треков элемент распостраняется). Охват в сетке всегда определен, и по умолчанию обрабатывается как 1, если не установлено иное.</li>
            
        </ul>
        
        <p>Свойства размещения в сетке - их длинная запись: <em>grid-row-start</em>, <em>grid-row-end</em>, <em>grid-column-start</em>, <em>grid-column-end</em> - и краткая запись: <em>grid-row</em>, <em>grid-column</em> и <em>grid-area</em> - позволяют установить размещение элемента сетки, предоставляя любую (или никакую) из следующих кусков информацию:</p>
        
        <img src="https://i.gyazo.com/9e32eeea269ec88baeb7cc0e46d631ff.png" alt="values for grid-placement properties">
        
        <p>Следующая табличка резюмирует условия, под которым позиция или охват в сетке определены, или же автоматические:</p>
        
        <img src="https://i.gyazo.com/662b1431f4e950e49dc67d5b6199cf39.png" alt="table in which grid position or span is definite or automatic">
        
        <div>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses">Общие модели</a> для размещения в сетке</h4>
                
            </header>
            
            <p>Если взять свойства размещения в сетке и организовать их краткие формы записи, тогда получим вот такую пирамиду на подобие Маслоу:</p>
            
            <img src="https://i.gyazo.com/e5f58b3ed7b0d9883fc83caef0505dea.png" alt="shorthands for grid-placement propeties">
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-named-areas">Именованые области</a></h4>
                    
                </header>
                
                <p>Элемент может быть размещен внутри именованой области сетки, устанавливая имя области в свойстве <em>grid-area</em> (похожим макаром это делается и с помощью <em>grid-template-areas</em>). Также элемент может быть частично выровнен в сетке внутри именованой области, располагаясь у каждой отдельной линиии, что представляет грань этой области.</p>
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-numeric">Числовые индексы и соединения</a></h4>
                    
                </header>
                
                <p>Элементы сетки могут быть размещены и их размер может быть определен за числовым индексом, который особенно полезен для разметки, основанной на сценариях (script-driven, блин). По умолчанию охват для элемента сетки назначается как 1, при этом его значения могут быть явно определены. Нуууу, тут не мешает навести примеры:</p>
                
                <img src="https://i.gyazo.com/413742fd603b0bffaaff9243149c665f.png" alt="first example">
                
                <img src="https://i.gyazo.com/b04c43bd5639d4f1449d9079b519f00d.png" alt="second example">
                
                <img src="https://i.gyazo.com/0df2a02972e259c2a27eaa8dd355c27b.png" alt="third example">
                
                <p>Разберем значения для охвата, которые пишутся через слэш. Если первое значение (перед слэшем) числовой индекс линии, то это обозначает, откуда будет начинаться охват рядов или колонок (в зависимости от того, какому свойству назначено это значение: <em>grid-row</em> или <em>grid-column</em>), а если последнее (после слэша) числовой индекс - где он будет заканчиваться; если значение дано как <em>span 'number'</em> (не важно, первое оно или последнее), это обозначает сколько рядов или колонок будет охвачено в зависимости от того, опять-таки, какому свойству оно назначается. Вродь, понятно пояснил.</p>
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-named-lines">Именованые линии и соединения</a></h4>
                    
                </header>
                
                <p>Так же можно ссылаться не только на числовые индексы линий сетки, а и на их имена (если они им даны). При назначении имени линии она сохраняет свои числовые индексы, на которые тоже можно ссылаться. Заметка: если именованая область сетки имеет то же имя, что и линия, тогда алгоритм размещения будет давать предпочтение для использования именованой области сетки вместо линий. И если есть несколько линий, которые имеют одинаковое имя, тогда они устанавливают именованый набор линий сетки, на которые можно сослаться непосредственно, обрабатывая размещение за именем этих линий. И одна линия может принимать несколько имен (<em>[main-end footer-start row-5]</em>). Много слов, надо больше картинок:</p>
                
                <img src="https://i.gyazo.com/ce91c45a1b62afe312322f0f8544cfcd.png" alt="first example">
                
                <img src="https://i.gyazo.com/1be32db6ca374e44e5e28b05996c9d3b.png" alt="second example">
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-auto-placement">Автоматическое размещение</a></h4>
                    
                </header>
                
                <p>Элемент сетки может быть автоматически размещен в следующей доступной пустой ячейке сетки, увеличивая сетку, если нет оставшегося пространства. Автоматическое размещение может быть объеденено вместе с явно определенным охватом, если элементу следует занять более одной ячейки.</p>
                
                <img src="https://i.gyazo.com/dbf32284a2a9b629e5688c72bfdd331d.png" alt="first example">
                
            </article>
            
        </div>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#placement-a11y">Размешение элемента сетки и исходный порядок</a></h4>
                
            </header>
            
            <p>Способности свойств размещения в сетке позволяют контенту быть свободно организованными и переопределить порядок внутри сетки, таким образом, визуальное представление отделяется от лежащего в основе исходного порядка документа. Они не заменяют правильное исходное определение порядка и влияют только на его визуальное представление (знак восклицания еще ебанем)!</p>
            
        </article>
        
        <div>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#line-placement">Размешение, основанное на линиях</a>: свойства <em>grid-row-start</em>, <em>grid-column-start</em>, <em>grid-row-end</em> и <em>grid-column-end</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/4ededa19e86cc3f40e8e8b9ec78dfa95.png" alt="line-placement">
            
            <p>Для размещения элементов сетки, что основано на линиях, используются такие значения:</p>
            
            <img src="https://i.gyazo.com/3cc4e9de8739023bb6ae7c2069b6c50a.png" alt="line-placement values">
            
            <p>Итак, свойства <em>grid-row-start</em>, <em>grid-column-start</em>, <em>grid-row-end</em> и <em>grid-column-end</em> определяют размер элементов сетки и их местоположение, через участие в размещении линий, охватов (спаны), или нихуя (что равно значению <em>auto</em>), тем самым устанавливая границы начала строки, начала блока, конца строки и конца блока той области сетки, в которой располагается элемент.</p>
            
            <p>Значения этих свойств имеют такой смысл:</p>
            
            <ul class="list">
               
                <li><em>'custom-ident'</em>: попытка сопоставить границу области сетки с именованной областью - если есть именованная линия с имеменем <em>'custom-ident'-start (для grid-*-start) / 'custom-ident'-end (для grid-*-end)</em>, тогда первая такая линия участвует в размещении элемента сетки. 
                
                    <p>Уже упоминалось о том, что именованные области сетки создают неявно именованные линии, поэтому назначение <em>grid-row-start: foo</em> выберет начальную границу этой области (если только перед этим не была указана другая линия с именем <em>foo-start</em>).</p>
                
                    <p>В другом случае это следует обработать так, будто задано целое число '1' вместе с 'custom-ident' (типа, как следующий тип значений внизу);</p>
                    
                </li>
                
                <li><em>'integer && custom-ident'</em>: N-ная линия сетки участвует в размещении элемента. Если дано отрицательное целое число, тогда линии считаются с конечной границы явно определенной сетки.
                
                    <p>Если имя дано как <em>'custom-ident'</em>, тогда линии только с этим именем учитываются. И если линий с этим именем недостаточно, тогда предполагается, что все неявные линии сетки имеют это имя для того, чтобы определить позицию. Т.е. достаточно мощный индикатор для линии.</p>
                    
                    <p>Если целому числу будет назначено '0', тогда обьявление недействительно.</p>
                
                </li>
                
                <li><em>'span && [integer || custom-ident]'</em>: охват сетки участвует в размещении элемента таким образом, что соответствующая граница области элемента сетки находится на расстоянии N-линий от ее противоположной границы в соответствующем направлении. Допустим, что какому-то свойству <em>grid-*-start/grid-*-end</em> дано значение <em>span 'integer'</em>, и тогда берется та граница, к которой относится соответствующиее свойство (начальное или конечное), и добавляется заданое целым числом количество линий, существующих в сетке (а если нет, то сгенерируемых), которые будут охвачены нашим элементом, указывая, от какой границы и в каком направлении они были добавлены.
                
                    <p>И если имя дано как <em>'custom-ident'</em>, тогда линии только с этим именем учитываются и элемент будет охватывать линии до тех пор, пока не встретит первое совпадение для заданого имени. И если линий с этим именем недостаточно, тогда предполагается, что все неявные линии на стороне явно определенной сетки, соответствующие направлению поиска, имеют это имя для того, чтобы определить вычисление этого охвата.</p>
                    
                    <p>Пример был бы в тему. Итак, представим себе сетку, которая имеет только линии 1 и 2, и поиграемся с ней:</p>
                    
                    <img src="https://i.gyazo.com/72c487ba53c5fd012a4a1ea2992af900.png" alt="example">
                    
                    <p>Это превратит нашу сетку в такую вот, у которой сгенерируются неявные линии:</p>
                    
                    <img src="https://i.gyazo.com/94cc183837f43d07508775ced34cb493.png" alt="result">
                    
                    <p>Если числовое значение упущено, тогда по умолчанию оно имеет '1'. Отрицательные числовые значения и '0' недействительны.</p>
                
                </li>
                
                <li><em>'auto'</em>: это значение никак не участвует в размещении элемента сетки, указывая на автоматическое размещение или охват, значение которого равно по умолчанию '1'.</li>
                
            </ul>
            
            <p>'custom-ident' исключает ключевое слово <em>span</em>.</p>
            
            <article id="conflict_handling">
               
                <header class="header">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-placement-errors">Решение конфликтов</a> при размещении в сетке</h4>
                    
                </header>
                
                <p>Если размещение элемента сетки содержит две линии, и начальная линия ближе к концу, чем конечная, тогда они меняются местами. Если начальная линия равна конечной, тогда конечная удаляется.</p>
                
                <p>Если размещение вмещает два охвата, удаляется тот, который участвует в свойствах размещения, определяющих конечные границы.</p>
                
                <p>Если размещение вмещает только охват для именованной линии, он заменяется на имеющий значение '1'.</p>
                
            </article>
            
        </div>
        
        <article>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#placement-shorthands">Краткая запись</a> для свойств размещения в сетке: свойства <em>grid-row</em>, <em>grid-column</em> и <em>grid-area</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/fe34985a0f91865d1caffe0afcfc8d4e.png" alt="Placement Shorthands">
            
            <p><em>grid-row</em> это краткая запись для <em>grid-row-start</em> и <em>grid-row-end</em>, а <em>grid-column</em> - для свойств <em>grid-column-start</em> и <em>grid-column-end</em>.</p>
            
            <p>Когда второе значение упущено, и если первое значение <em>'custom-ident'</em>, тогда <em>grid-row-end/grid-column-end</em> также записыаются к этому 'custom-ident'; в противном случае это записывается к <em>auto</em>.</p>
            
            <img src="https://i.gyazo.com/f63e0a494263703cdc56e61988e82ab8.png" alt="grid-area">
            
            <p>Порядок для этой краткой записи такой: <em>grid-row-start / grid-column-start / grid-row-end / grid-column-end</em>.</p>
            
            <p>Когда <em>grid-column-end</em> упущено, и если <em>grid-column-start</em> имеет значение <em>'custom-ident'</em>, тогда <em>grid-column-end</em> также записывается к этому значению; в противном случае это записывается к <em>auto</em>.</p>
            
            <p>Когда <em>grid-row-end</em> упущено, и если <em>grid-row-start</em> имеет значение <em>'custom-ident'</em>, тогда <em>grid-row-end</em> также записывается к этому значению; в противном случае это записывается к <em>auto</em>.</p>
            
            <p>Когда <em>grid-column-start</em> упущено, и если <em>grid-row-start</em> имеет значение <em>'custom-ident'</em>, тогда все значения для этих четырех свойств длинной записи записываются к этому значению; в противном случае это записывается к <em>auto</em>.</p>
            
        </article>
        
        <p>В спецификации еще описывается <a href="https://www.w3.org/TR/css-grid-1/#auto-placement-algo">алгоритм размещения</a>. Только я его трогать не буду.</p>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#abspos">Абсолютное позиционирование</a></h3>
            
        </header>
        
        <article id="abspos_items">
           
            <header class="header">
               
                <h4>Контейнер сетки как <a href="https://www.w3.org/TR/css-grid-1/#abspos-items">вмещающий блок</a></h4>
                
            </header>
            
            <p>Если вмещающий блок абсолютно позиционируемого элемента генерируется контейнером сетки, тогда вмещающий блок соответствует области сетки, что определена свойствами размещения внутри нее. Абсолютно-позиционируемый элемент может выравниваться внутри контейнера по линиям сетки, при этом такой элемент не забирает пространство и не участвует в разметке сетки.</p>
            
            <p>Еще интересно себя ведет значение <em>'auto'</em> в свойствах размещения, которые применяются для абсолютно позиционируемых элементов. Т.е. размещение тут построено не на автоматическом алгоритме, а на участии специальных линий, чьи позиции соответствуют границе внутреннего отступа контейнера сетки (в общем, границы самого контейнера и будут образовывать границы внутренних отступов). Таким образом, вмещающий блок абсолютно-позиционируемого элемента будет соответствовать границам внутренних отступов контейнера сетки, образовывая дополненную сетку.</p>
            
            <img src="https://i.gyazo.com/1cb888586aaf83c84231f7877e65a711.png" alt="abspos example">
            
            <p>И когда свойства размещения ссылаются на линии сетки, которых нет, либо охватывают так, что выходят за пределы существующей неявно определенной сетки, тогда они обрабатываются как такие, которые имеют свойство <em>'auto'</em> (вместо создания неявных линий сетки они ссылаются на границы внутреннего отступа контейнера). И если размещение содержит в себе только охват сетки, тогда оно заменяется двумя линиями, которые применяются при значении <em>'auto'</em>, в этой оси.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4>Контейнер сетки как <a href="https://www.w3.org/TR/css-grid-1/#static-position">родительский</a></h4>
                
            </header>
            
            <p>Абсолютно-позиционируемый дочерний элемент контейнера сетки вне потока и не является элементом сетки и поэтому не влияет на размещение других элементов в сетке и на определение размеров сетки.</p>
            
            <p>Позиция абсолютного элемента определяется так, будто он единственный в области сетки, чьи границы совпадают с границами внутренних отступов контейнера сетки. Тем не менее, если родитель-контейнер сетки также генерирует вмещающий блок для абсолютно-позиционируемого элемента, тогда используется область сетки, которая была определена <a href="#abspos_items">выше</a>. На эти элементы влияют значения свойств <em>justify-self и align-self</em>, при этом они никак не влияют на размер вмещающего блока или разметку его контента.</p>
            
        </article>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#alignment">Выравнивание и создание промежутков</a></h3>
            
        </header>
        
        <p>После того, как размер треков сетки был определен и измерения элементов сетки были закончены, эти элементы могуть быть выровнены внутри области сетки.</p>
        
        <p>Для выравнивания могут использоваться и свойства внешних отступов. Также элементы сетки признают свойства выравнивания внутри <a href="http://www.w3.org/TR/css-align/">блока</a>, которые позволяют выровнять элементы с помощью ключевых слов по оси рядов и столбцов.</p>
        
        <p>Элементы сетки по умолчанию растягиваются, чтобы заполнить свою область. И тем не менее, если свойства <em>justify-self и align-self</em> расчитывают значения иные, чем <em>stretch</em>, или внешним отступам назначено значение <em>auto</em>, тогда размер элементов сетки определится автоматически, чтобы соответствовать своему контенту.</p>
        
        <p>Дополнительное свободное пространство расчитывается по такой формуле:</p>
        
        <img src="https://i.gyazo.com/78e5dac235d736eedb506e8538d254e9.png" alt="extra-space">
        
        <article>
           
            <header class="header">
               
                <h4><a href="">Промежутки</a>: свойства <em>grid-column-gap, grid-row-gap и grid-gap</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/2e8936882a15ffa02880c0a3a9b4a6f8.png" alt="gutters">
            
            <p>Эти свойства определяют промежутки между рядами и колонками соответственно (между линиями сетки образовывается пространство определенной ширины). Для определения размера трека каждый промежуток рассматривается как дополнительный пустой трек. Отрицательные значения не действительны.</p>
            
            <p>Если сетка рассегментирована между треками, тогда промежутки между ними должны быть уменьшенными. И эти промежутки могут быть только в неявно определенной сетке; и нет промежутков перед первым треком и после последнего. В частности, нет промежутков между первым/последним треком в неявной сетке и <em>'auto'</em> линиями в дополненной сетке. И когда треки схлопываются, то и промежутки эти тоже хляп.</p>
            
            <img src="https://i.gyazo.com/d7abf10bdca68c9c5a232014c34370c9.png" alt="grid-gap">
            
            <p>Это свойство является краткой записью для предыдущих двух. Если <em>grid-column-gap</em> упущено, тогда у него будет значение <em>grid-row-gap</em>.</p>
            
            <img src="https://i.gyazo.com/63e46bc99696d469962b79c8708e56db.png" alt="examples">
            
            <p><em>grid-gap</em> является единственным компонентом видимого промежутка, созданного между областями сетки. Внешние и внутренние отступы, или использование распределенного выравнивания могут увеличить видимое разделение между элементами сетки за пределами того, что определено промежутком, как показано выше.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4>Выравнивание с помощью <a href="https://www.w3.org/TR/css-grid-1/#auto-margins">внешних отступов <em>'auto'</em></a></h4>
                
            </header>
            
            <ul class="list">
               
                <li>На протяжении расчетов размеров треков сетки автоматические внешние отступы рассматриваются как 0;</li>
                
                <li>Внешние отступы <em>'auto'</em> поглощают положительное свободное пространство до момента выравнивания через <a href="https://www.w3.org/TR/css3-align/#box-alignment-properties">свойства выравнивания внутри блока</a>;</li>
                
                <li>Переполняющие элементы игнорируют свои внешние отступы <em>'auto'</em>.</li>

            </ul>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#row-align">Выравнивание по оси рядов</a>: свойства <em>justify-self и justify-items</em></h4>
                
            </header>
            
            <p>Элементы сетки могут быть выровнены в измерении строки с помощью свойств <a href="https://www.w3.org/TR/css3-align/#propdef-justify-self"><em>justify-self</em></a>, которое применяется индивидуально к элементу, и <a href="https://www.w3.org/TR/css3-align/#propdef-justify-items"><em>justify-items</em></a>, которое применяется к контейнеру в целом.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#row-align">Выравнивание по оси столбцов</a>: свойства <em>align-self и align-items</em></h4>
                
            </header>
            
            <p>Элементы сетки могут быть выровнены в измерении блока (что перпендикулярно строке) с помощью свойств <a href="https://www.w3.org/TR/css3-align/#propdef-align-self"><em>align-self</em></a>, которое применяется индивидуально к элементу, и <a href="https://www.w3.org/TR/css3-align/#propdef-align-items"><em>align-items</em></a>, которое применяется к контейнеру в целом.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#row-align">Выравнивание сетки</a>: свойства <em>justify-content и align-content</em></h4>
                
            </header>
            
            <p>Если внешние границы сетки не соответствуют границам контента контейнера сетки, треки сетки выравниваются внутри блока, содержащего контент, с помощью свойств <a href="https://www.w3.org/TR/css3-align/#propdef-justify-content"><em>justify-content</em></a>, которое применяется для выравнивания по оси рядов, и <a href="https://www.w3.org/TR/css3-align/#propdef-align-content"><em>align-content</em></a>, которое применяется для выравнивания по оси столбцов.</p>
            
            <img src="https://i.gyazo.com/76c5fdf6143256352bfcc1947a76cf3f.png" alt="example">
            
            <img src="https://i.gyazo.com/50da34692cf4d30e12c64e87fbe79689.png" alt="result">
            
            <p>При отсуствии треков сетки линии по каждой оси выравниваются с начальной границей контейнера.</p>
            
            <p>Следует заметить, что некоторые значения этих свойств приводят к тому, что треки сетки могут распологаться на расстоянии друг от друга  (<a href="https://www.w3.org/TR/css-flexbox-1/#valdef-justify-content-space-around"><em>space-around</em></a>, <a href="https://www.w3.org/TR/css-flexbox-1/#valdef-justify-content-space-between"><em>space-between</em></a> и <a href="https://www.w3.org/TR/css3-align/#valdef-align-content-space-evenly"><em>space-evenly</em></a>), или может быть изменен их размер (<a href="https://www.w3.org/TR/css3-align/#valdef-align-content-stretch"><em>stretch</em></a>). Если сетка рассфрагментирована между треками, тогда каждое такое дополнительное определение пространства между этими треками должно быть уменьшеным.</p>
            
            <img src="https://i.gyazo.com/39b9d85627e85f0997c6c756787071e6.png" alt="example">
            
            <img src="https://i.gyazo.com/181212f5a1a1f5d47f10468084f3b80c.png" alt="grid before">
            
            <img src="https://i.gyazo.com/929fe6da53ad34515817ea0328fdfa76.png" alt="grid after">
            
            <p>Выравнивание происходит после того, как размер треков определен, поэтому, если размер трека определяется контентом элемента, который охватывает несколько треков сетки, тогда он получит излишнее пространство на этапе выравнивания, чтобы обеспечить пространство для выравнивания.</p>
            
        </article>
        
        <p>Еще в этой секции описывают <a href="https://www.w3.org/TR/css-grid-1/#grid-baselines">базовые линии контейнера сетки</a>, только это все описывать не буду. К этому вернемся, когда будет нужно.</p>
        
        <p>Еще бы тут не мешало все-таки описать все те свойства, описание которых у меня заняло несколько слов и вместо чего я тупо бахнул ссылку. Да, нет мне тут оправдания. С другой стороны, я, кажись, не овладел еще исскуством отсеивать лишнюю инфу, и, по ходу, из всего тут мной написанного кое-что можно откинуть, поскольку не пригодится, или же можно упростить. Поэтому принимается решение вернуться к описыванию всех тех свойств и их значений по необходимости, когда приспичит их использовать. Вооооот.</p>
        
    </section>
    
    <footer>
       
        <header class="header">

           <h3>Полезные ссылки</h3>

        </header>
        
        <div>
        
            <a href="https://webdesign.tutsplus.com/series/understanding-the-css-grid-layout-module--cms-1079">Понимание сетки от Иана Ятса</a>
            
        </div>
        
        <div>
        
            <a href="https://bitsofco.de/how-the-minmax-function-works/">Как работает <em>minmax()</em></a>
            
        </div>
        
    </footer>
    
</body>
</html>