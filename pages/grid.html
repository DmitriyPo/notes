<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Grid</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
    
    <section>
        
        <header class="header">
            
            <h1>Сеточная модель разметки</h1>
            
        </header>
        
        <p>Читая впервые <a href="https://www.w3.org/TR/css-grid-1/">спецификацию</a>, я нихера не понял. Сириусли. Эт пиздос, как она написана. Сложилось ощущение, что даже человек, который шарит инглишь, и у которого он родной, или чуть ли не родной, с первого раза не выкупит, шо ж там такое. Я попробую. Итааак, сеточная разметка, дамы и господа. Начнемс.</p>
        
        <p>Как и у гибкой модели разметки, сеточная имеет свою <a href="https://www.w3.org/TR/css-grid-1/#grid-concepts">концепцию</a>. Контент тут размечается путём размещения и выравнивания в сетке (как неожиданно). Шо ж имеется в виду? Сетка представляет из себя набор вертикальных и горизонтальных линий, что пересекаются и разделяют пространство своего контейнера на области, внутри которых дочерние элементы этого контейнера, представляющие его контент, могуть быть расположены. Ну, это понятно. Есть линии сетки, что определяют колонки и простираются вдоль блочной оси (ось колонки), и перпендикулярные им, что определяют ряды и простираются вдоль оси строки (ось ряда). Сетка изображена на изображении ниже:</p>
        
        <img src="https://i.gyazo.com/bae5a4d1892055a41493a021f5af58de.png" alt="Grid lines">
        
        <p>В общем, в сетке есть горизонтальные и вертикальные разделяющие <a href="https://www.w3.org/TR/css-grid-1/#grid-line-concept">линии</a>. На эти линии можно сослаться: или за индексом, или за определенным автором именем. Элемент сетки ссылается на линии, чтобы определить свою позицию внутри сетки, используя свойства для размещения в сетке.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-track-concept">Дорожки</a> (треки) сетки это обобщенный термин для ряда или колонки сетки. Другими словами, это простанство между двумя соседними линиями сетки (которые параллельны). Каждый трек сетки назначается функции, определяющей размер, которая контролирует, насколько широко или высоко колонка или ряд может увеличиться, и, таким образом, насколько далеко друг от друга линии треков сетки.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-track-concept">Ячейка</a> сетки образуется путем пересечения колонки и ряда сетки. Это наименьшая единица сетки, на которую можно сослаться при определении местоположения ее элементов.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-area-concept">Область</a> сетки является пространством, используемым для того, чтобы разметить один или более элементов, образовывая для них вмещающий блок. Она содержит в себе одну или более соседних ячеек сетки. Эта область связывется четырьмя линиями сетки (по одной с каждой стороны области) и участвует в определении размера треков сетки, которые ее пересекают. Области сетки может быть явным образом дано имя с помощью свойства <em>grid-template-areas</em> контейнера, или неявно на нее можно сослаться за связывающими ее линиями. Элементы сетки назначаются области с помощью свойств размещения в сетке.</p>
        
        <p>Свойства сетки, с помощью которых автором определяется визуальный <a href="https://www.w3.org/TR/css-grid-1/#order-accessibility">порядок</a> элементов (<em>order</em> свойства размещения в сетке), не влияют на изначальный логический порядок изложения документа - только на его визуальное представление.</p>
        
    </section>
    
    <section>
        
        <header class="header">
            
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-containers">Контейнер сетки</a></h3>
            
        </header>
        
        <p>Для того, чтобы сделать из элемента контейнер, в котором будет размещаться сетка, ему нужно назначить свойство <em>display</em> со значением <em>grid</em> или <em>inline-grid</em>. Первое значение превращает элемент в контейнер блочного уровня, а второе - строчного уровня.</p>
        
        <p>Контейнер сетки устанавливает новый контекст форматирования для своего контента: контент контейнера размечается внутри сетки с линиями, что формируют границы вмещающего блока каждого элемента сетки.</p>
        
        <p>Некоторые приколы CSS в сетке не работают или работают с определенными особенностями. И это следующие:</p>
        
        <ul class="list">
            
            <li>Внешние отступы элементов сетки и контейнера не схлопываются.</li>
            
            <li>Свойства серии <em>column-*</em> не имеют эфекта на контейнер.</li>
            
            <li>Свойства <em>float</em> и <em>clear</em> не влияют на элемент сетки.</li>
            
            <li>Со свойством <em>vertical-align</em> та же история.</li>
            
            <li>Псевдоэлементы <em>:first-line</em> и <em>:first-letter</em> не применяются к контейнеру сетки, и контейнер сетки не участвует в их форматировании.</li>
            
            <li>Контейнеру сетки устанавливается <a href="https://www.w3.org/TR/css-grid-1/#intrinsic-sizes">размер</a>, исходя из правил контекста форматирования, в котором он участвует: блочный контекст форматирования или строчный. В обоих случаях значение <em>auto</em> это максимальный размер контента.</li>
            
            <li>Если сетка выходит за пределы своего лимита, тогда то, что выходит за пределы, <a href="https://www.w3.org/TR/css-grid-1/#overlarge-grids">усекается</a> или ужимается. Тут я обломался переводить, ибо формулировка в спецификации меня сбила с толку, так что вернусь к этому, когда будет нужно.</li>
            
        </ul>
        
        <p>Переводчик от Бога, бля.</p>
        
    </section>
    
    <section>
        
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-items">Элементы</a> сетки</h3>
            
        </header>
        
        <p>Элементом сетки является дочерний элемент в потоке контейнера, что представляет его контент. Текст, что находится в контейнере сетки и ни во что не обернут, оборачивается в анонимный элемент сетки, который наследует стили от родителя. Элемент сетки устанавливает новый контекст форматирования для своего контента и участвует только в контексте форматирования сетки контейнера. Как и в случае с гибкими элементами, значения свойства <em>display</em> для элемента сетки <a href="https://www.w3.org/TR/css-grid-1/#grid-item-display">блокофицируются</a>.</p>
        
        <p><a href="https://www.w3.org/TR/css-grid-1/#grid-item-sizing">Размер элемента сетки</a> устанавливается внутри вмещающей его области. Есть один прикол, и заключается он в том, что ширина элемента сетки при назначении ему значения <em>auto</em> может быть разной в зависимости от того, какое значение имеет свойство самовыравнивания элемента. Мне впадлу все это расписывать, учитывая, что я могу еще и хуёво перевести, поэтому фигану сюда табличку (хоть и на инглише, да пох):</p>
        
        <img src="https://i.gyazo.com/ea70238b5b5bbc8888b907f4cb8a9fe5.png" alt="Summary of automatic sizing behavior of grid items">
        
        <p>Также к элементам сетки применяется свойство <a href="https://www.w3.org/TR/css-grid-1/#order-property"><em>order</em></a>.</p>
        
        <p>А еще внешние отступы соседних элементов сетки не <a href="https://www.w3.org/TR/css-grid-1/#item-margins">схлопываются</a>. И нужно держать очко прикрытым и не использовать процентные значения для внешних и внутренних отступов, потому что это может произвести к разному поведению в разных браузерах. С внешними отступами есть также такая фича, что при назначении им значения <em>auto</em> они как бы расширяются и поглощают дополнительное пространство в соответствующем измерении, и это может использоваться для выравнивания.</p>
        
        <p>Элементы сетки могут накладываться друг на друга, когда они размещены в пересекающихся областях сетки, или даже тогда, когда они не расположены в пересекающихся областях сетки, накладываются через отрицательные внешние отступы или позиционирование. И даже, когда для элемента сетки установлено <em>position: static;</em> (значение оп умолчанию), для него можно использовать свойство <em>z-index</em> со значениями, что отличаются от <em>auto</em>, и это создаст <a href="https://www.w3.org/TR/css-grid-1/#z-order">контекст наложения</a>. Итак, свойство <em>z-index</em> может использоваться, чтобы контролировать порядок <em>z</em>-оси элементов сетки.</p>
        
        <p>Теперь осталось упомянуть про <a href="https://www.w3.org/TR/css-grid-1/#min-size-auto">предполагаемый минимальный размер</a> элементов сетки. Для элементов сетки с <em>overflow: visible</em> и которые заполняют по крайней мере один трек, чья функция определения минималного размера трека установлена как <em>auto</em>, значение <em>auto</em> для свойств <em>min-width/min-height</em> применяет автоматический минимальный размер в определенной оси, что подобно тому, как это происходит в гибких элементах. Тем не менее, если элемент сетки заполняет только те треки, что имеют фиксированную функцию определения максимального размера трека, тогда его определенный размер и размер контента в данном измерении будет установлен как значение меньшее или равное размеру области сетки в соответствующей оси (сука, как это, бля, перевести -  the stretch fit). Я ебу, как перевести написанное в спецификации, щоб не терялся смысл. Та вроде тут он присутствует, ведь елемент не должен вылазить за пределы области сетки. Вооооот, поэтому если он подходит по размеру - заебись, не подходит - подгоняется так, шоб подошел.</p>
        
    </section>
    
    <section>
        
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#grid-definition">Определение сетки</a></h3>
            
        </header>
        
        <p>Три этих свойства устанавливают <a href="https://www.w3.org/TR/css-grid-1/#explicit-grids">явно определенную сетку</a>: <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>. Чтобы не писать всю эту кучу свойств, существует краткая запись для них - свойство <em>grid</em>. Конечная сетка может оказаться больше из-за элементов, что расположены за пределами явно определенной сетки; в этом случае будут созданы неявные треки, размер которых будет определен свойствами <em>grid-auto-rows</em> и <em>grid-auto-columns</em>.</p>
        
        <p>Размер явно определенной сетки устанавливается большим числом рядов/колонок, что выражается с помощью свойства <em>grid-template-areas</em>, и числом рядов/колонок, размер которых определяется свойствами <em>grid-template-rows</em>/<em>grid-template-columns</em>. Всякие ряды/колонки, выраженные с помощью свойства <em>grid-template-areas</em>, при этом размеры которых не были определены с помощью свойств <em>grid-template-rows</em>/<em>grid-template-columns</em>, берут свои размеры от свойств <em>grid-auto-rows</em>/<em>grid-auto-columns</em>. Ну, а если и таких нема, тогда ебашится значение <em>auto</em>.</p>
        
        <p>Числовые индексы в свойствах размещения в сетке считаются от границ явно определенной сетки. Существуют положительные и отрицательные значения для индексов в зависимости от того, с какой стороны сетки ведется подсчет.</p>
        
        <div>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#track-sizing">Явное определение размера треков</a> (треков): свойства <em>grid-template-rows</em> <em>grid-template-columns</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/de508f8ce88ac6a05d32261dd9cee983.png" alt="grid-template-columns, grid-template-rows properties">
            
            <p>Эти свойства определяют имена линий сетки и функции определения размера треков сетки, что формирует список - трек-лист. Свойство <em>grid-template-rows</em> определяет трек-лист для рядов сетки, а <em>grid-template-columns</em> - для колонок сетки.</p>
            
            <p>Значение этих свойств означает следующее:</p>
            
            <ul class="list">
                
                <li><em>none</em>: означает, что никакие явно определенные треки не создаются этим свойством (хотя явно определенные треки сетки могут быть созданы с помощью свойства <em>grid-template-areas</em>). В случае отсуствия явно определенной сетки образовывается неявная.</li>
                
                <li>'track-list/auto-track-list': определяет трек-лист функций определения размера треков сетки и имен их линий. Каждая функция определения размера треков может быть установлена как расстояние, процентное значение размера контейнера сетки, размер контента, занимающего ряд или колонку, или часть свободного пространства в сетке. Это также может быть установлено как диапазон, используя обозначение <em>minmax()</em>, которое может объединять в себе каждый из ранее упомянутых механизмов, чтобы определить минимальную и максимальную функции определения размера трека сетки для колонки или ряда (надыбал статью о том, как работает <a href="https://bitsofco.de/how-the-minmax-function-works/"><em>minmax()</em></a>, и, кажись, это та штука, от которой мона кончить, так што уделю этому время).</li>
                
            </ul>
            
            <p>Трек-лист вмещает в себя дофига всякого, и выглядит это следующим образом:</p>
            
            <img src="https://i.gyazo.com/bc78893a226c73c691ba2dfb6dc1e43e.png" alt="syntax of a track list">
            
            <p>Где:</p>
            
            <ul class="list">
                
                <li><a href="https://drafts.csswg.org/css-values-4/#typedef-length-percentage"><em>'length-percentage'</em></a>: не отрицательное значение расстояния или процентное значение;</li>
                
                <li><a href="https://www.w3.org/TR/css-grid-1/#typedef-flex"><em>'flex'</em></a>: не отрицательное пространство с единицей измерения <em>fr</em>, что определяет гибкий коэффициент трека (с его помощью разделяется оставшееся пространство в треке в соответствующей этому коэффициенту пропорции);</li>
                
                <li><em>'max-content'</em>: представляет наибольшее максимальное значение контента элементов сетки, что занимают трек;</li>
                
                <li><em>'min-content'</em>: представляет наибольшее минимальное значение контента элементов сетки, что занимают трек;</li>
                
                <li><em>'minmax(min, max)'</em>: определяет диапазон размера большего или равного минимуму и меньшего или равного максимуму;</li>
                
                <li><em>'auto'</em>: как максимум, идентично максимальному размеру контента. А как минимум, представляет наибольший минимальный размер  элементов сетки, что занимают трек (размер этот определяется свойствами <em>min-width/min-heigh</em>);</li>
                
                <li><em>'fit-content( 'length-percentage' )'</em>: представляет формулу <em>min(max-content, max(auto, argument))</em>, что расчитывается подобно <em>'auto'</em>, за исключением того, что размер трека фиксируется в аргументе, если он больше, чем минимальное значение для <em>'auto'</em>.</li>
                
            </ul>
            
            <p>Заметка: размер сетки не целиком состоит из размеров треокв сетки, потому что сюда еще вмешиваются следующие свойства: <em>grid-row-gap, grid-column-gap, justify-content, align-content</em>, поскольку они могут добавить дополнительное пространство между треками.</p>
            
            <p>Чтобы понять прикол, я тут еще проиллюстрирую примеры, поскольку не все на первый взгляд ясно-понятно. Вверху по картинке с составлящими трек-листа видно, что трек-лист являет собой список, где значения разделены не запятыми, а пробелами. Поэтому когда мы будем прописывать значения размера трека в нашем трек-листе, это будет выглядеть так:</p>
            
            <img src="https://i.gyazo.com/bfd5e86e6c025b8543b48d94d6a614d8.png" alt="grid-template-columns example">
            
            <p>Тут были взяты просто размеры треков, без имен для линий сетки. Каждое значение размера трека создает колонку, поэтому количество линий сетки, на которые можно сослаться, определяется так: количество колонок + 1 (что логично). Итак, согласно этому примеру были созданы пять линий сетки, между которыми пространство распределяется согласно значениям размеров треков.</p>
            
            <p>Есть еще один момент: если сумма фиксированных размеров треков (<em>100px, max-content, min-content</em>) больше, чем размер сетки, тода гибкие размеры (<em>1fr</em>) обрабатываются как нулевое значение, и конечная линия сетки будет находится на расстоянии суммы этих фиксированных размеров от начальной линии сетки. А если сумма этих элементов меньше размера сетки, тогда конечная линия сетки будет находится у границы, где сетка заканчивается, и свободное пространство распределяется между данными гибкими размерами.</p>
            
            <p>И еще немного примеров валидных определений для треков сетки:</p>
            
            <img src="https://i.gyazo.com/c4021dea77570812e8a2ed8777728e9c.png" alt="Additional examples of valid grid track definitions">
            
            <article>
                
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#named-lines">Именуемые</a> линии сетки: синтаксис <em><a href="https://drafts.csswg.org/css-values-4/#identifier-value">'custom-ident'</a></em></h4>
                    
                </header>
                
                <p>На линии сетки можно сослаться за их числовым индексом, а еще им можно назначить имя, что более понятно и проще отлаживать. Имена линиям сетки можно явно назначить с помощью свойств <em>grid-template-rows</em> и <em>grid-template-columns</em>, или неявно, создавая именованые области сетки с помощью свойства <em>grid-template-areas</em>.</p>
                
                <p>Проще тут навести еще один пример, который дает осмысленные имена для всех линий сетки (у некоторых линий несколько имен) и показывает их числовые индексы:</p>
                
                <img src="https://i.gyazo.com/b61829235b8451f798feb50e45a04eb2.png" alt="Code for Named Grid Lines">
                
                <img src="https://i.gyazo.com/ea9ce379c2abc17367b5a752ba94a629.png" alt="Named Grid Lines">
                
                <p>И следует заметить, что линиям сетки не может быть назначено имя <em>'span'</em>.</p>
                
            </article>
            
            <div>
                
                <header class="header header--center">
                   
                    <h4>Повторяющиеся колонки и ряды: обозначение <a href="https://www.w3.org/TR/css-grid-1/#repeat-notation"><em>repeat()</em></a></h4>
                    
                </header>
                
                <p>Обозначение <em>repeat()</em> представляет повторяющийся фрагмент трек-листа, позволяя большому числу колонок и рядов, что выдают повторяющийся шаблон, быть прписаными в более компактной форме. Без примера тут не обойтись, поэтому вот:</p>
                
                <img src="https://i.gyazo.com/3d8c8ca5c187a0e7d36c8b3a628c4f40.png" alt="repeat() notation">
                
                <p>Этот пример создает четыре колонки, которые окружают межстолбцовые промежутки (gutters) в <em>10px</em>.</p>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4 class="header__item header__item--notbold"><a href="https://www.w3.org/TR/css-grid-1/#repeat-syntax">Синтаксис <em>repeat()</em></a></h4>
                            
                    </header>
                    
                    <p>Обычная форма обозначения <em>repeat()</em>:</p>
                    
                    <img src="https://i.gyazo.com/750b4cd54f90ed63708cd823de8d3309.png" alt="repeat() form">
                    
                    <p>Первый аргумент определяет число повторений, а второй - трек-лист, который повторяется определенное в первом аргументе количество раз. Есть некоторые ограничения: обозначения <em>repeat()</em> не могут быть вложенными друг в друга и автоматические повторения не могут быть объеденены с присущими (<em>min-content, max-content, auto, fit-content()</em>) или гибкими (<em>'flex'</em>) размерами (вот даже в пикче ниже обозначено для <em>auto-repeat</em> фиксированное значение во втором аргументе).</p>
                    
                    <p>Таким образом, точный синтаксис обозначения repeat() имеет несколько форм:</p>
                    
                    <img src="https://i.gyazo.com/1ab76f160936dff3845ef0d9d2020ad2.png" alt="repeat() notation forms">
                    
                    <p>Первый вариант <em>track-repeat</em> может представить повторение каждого размера трека, при этом он ограничен установленным количеством повторений. <em>auto-repeat</em> может повторять размер трека, чтобы заполнить пространство, при этом треубет явно определенные размеры для треков, поэтому число повторений можно расчитать, и в трек-листе это обозначение может появится только один раз, хотя тот же трек-лист может вмещать в себе обозначение <em>fixed-repeat</em>.</p>
                    
                    <p>Если функция <em>repeat()</em> сводится к тому, что размещаются две именованные линии, соседние друг другу, тогда список имен объединяется.</p>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4 class="header__item header__item--notbold"><a href="https://www.w3.org/TR/css-grid-1/#auto-repeat">Повторение до полного заполнения: <em>auto-fill</em> и <em>auto-fit</em></a></h4>
                            
                    </header>
                    
                    <p>Когда <em>auto-fill</em> дано как число повторений, и если контейнер сетки имеет явно определенный размер или максимальный размер в определенной оси, тогда число повторений является наибольшим числом, которое не позволяет сетке переполнить свой контейнер (рассматривая каждый трек как его функцию определения максимального размера, если это явно определено, или как функцию определения минимального размера, и берется в расчет свойство <em>grid-gap</em>); если любое число повторений переполнит контейнер, тогда только 1 повторение. В другом случае, если контейнер сетки имеет явно определенный минимальный размер в соответствующей оси, тогда число повторений это наименьшее число, что удовлетворяет это минимальное требование. В еще другом случае, трек-лист повторяется тоолько один раз. Еба, пришлось перевести весь параграф. За чтоооооо...</p>
                    
                    <p><em>auto-fit</em> ведет себя почти одинаково, только с тем различием, что после размещения элемента сетки любой пустой повторяющийся трек схлопывается. Пустой трек такой, что не имеет размещенных в своем потоке элементов, или элементов, занимающих трек вдоль него.</p>
                    
                    <p>Схлопнутый трек рассматривается, как имеющий фиксированную функцию определения размера <em>0px</em>, и промежутки с каждой его стороны схлопываются (включая каждое пространство, что выделено для распределенного выравнивания).</p>
                </article>
                
            </div>
            
            <article>
            
                <header class="header header--center">

                    <h4><a href="https://www.w3.org/TR/css-grid-1/#fr-unit">Гибкое расстояние</a>: единица измерения <em>'fr'</em></h4>

                </header>

                <p>Гибкое расстояние или <em>'flex'</em> это измерение, что измеряется в единицах <em>fr</em>, которые представляют долю свободного пространства в контейнере сетки. Эту единицу нельзя использовать в функции <em>calc()</em>. Распределение свободного пространства происходит после того, как все функции определения размера достигли своего максимального значения. Общий размер таких рядов и колонок извлекается с доступного пространства, создавая свободное, которое потом разделяется среди гибких рядов и колонок в пропорции к их гибкому коэффициенту. Формула расчета следующая:</p>

                <img src="https://i.gyazo.com/d6065d6e39bca17b71adae693267d7d7.png" alt="fr formula">

                <p>Если сумма гибких коэффциентов меньше, чем 1, тогда свободное пространство распределяется на соответствующие доли (подобно тому, как это происходит в гибкой модели разметки).</p>

                <p>В том случае, когда свободное пространство безграничное (контейнер сетки в этом случае имеет неопределенную ширину или высоту), гибкие треки сетки определяют свой размер согласно контенту, сохраняя в это время соответствующие пропорции. Используемый размер каждого гибкого трека сетки расчитывается путем определения их максимального размера контента и разделения этого размера на соотвествующий гибкий коэффициент, чтобы определить гипотетический размер <em>1fr</em>. Максимальное из этих значений используется как обработанное расстояние <em>1fr</em> (гибкая доля), которое потом умножается на каждый гибкий коэффициент трека сетки, чтобы определить конечный размер. Хммм... Хитромудина какая-то. Хотя, в принципе, это должно быть математически логично, и мне тупо лень вникнуть в эту логику.</p>

            </article>

            <article>

                <header class="header header--center">

                    <h4><a href="https://www.w3.org/TR/css-grid-1/#resolved-track-list">Обрабатываемые значения</a></h4>

                </header>

                <p><em>grid-template-rows</em> и <em>grid-template-columns</em> являются свойствами со значениями, что обрабатываются в особом случае. Обрабатываемые значения этих свойств для элемента со значениями <em>grid/inline-grid</em> свойства <em>display</em> это используемые значения, что упорядочены следующим образом:</p>

                <ul class="list">

                    <li>определяется каждый явно или неявно созднный трек;</li>

                    <li>каждый размер трека дается как расстояние в пикселях, независимо от функции определения размера;</li>

                    <li>прилегающий пробег двух или более треков, что имеют одинаковый размер и связанные имена линий может быть упорядоченый с помощью <em>repeat()</em>.</li>

                </ul>

                <p>В ином случае, когда элемент не является контейнером сетки или имеет свойство <em>display: none</em>, обрабатываемые значения это просто расчитанные значения.</p>

            </article>
            
        </div>
        
        <div>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-template-areas-property">Именуемые области</a>: свойство <em>grid-template-areas</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/f05089e7b6adfdda0594b1ebbf8ff8de.png" alt="grid-template-areas-property">
            
            <p>Это свойство определяет именованную область сетки, которая не связана с каким либо определенным элементом сетки, при этом на нее можно ссылаться с помощью свойств размещения в сетке. Синтаксис этого свойства предоставляет визуализацию структуры сетки. Значения имеют такое смысловое содержание:</p>
            
            <ul class="list">
               
                <li><em>none</em>: именованных областей сетки не определено;</li>
                
                <li><em>'string +'</em>: ряд создается каждой отдельной строкой, определенной свойством <em>grid-template-areas</em>, а колонка создается для каждой ячейки в этой строке, которая обрабатывется следующим образом:
                
                    <ul class="list">
                        
                        <li>Строка разбивается на токены, такие как:
                        
                            <ul class="list">
                                
                                <li>токен именованной ячейки, что состоит из последовательности <a href="https://www.w3.org/TR/css-syntax-3/#name-code-point">кодовых точек имени</a> (name code point) и создает именованную область сетки с таким же именем. Несколько токенов именованых ячеек внутри и между рядами создают одну именованную область сетки, которая охватывает соответствующие ячейки сетки;
                                
                                    <img src="https://i.gyazo.com/710995e6e30346e2b54b891dcc7f7d51.png" alt="grid-template-areas example">
                                
                                </li>
                                
                                <li>токен нулевой ячейки, что представлен последовательностью одной или более "." и обозначает безымянную область в контейнере сетки;</li>
                                
                                <li>последовательность пробелов, которые ничего не представляют;</li>
                                
                                <li>"мусорный" токен, который представляет из себя последовательность других символов, является синтаксической ошибкой и делает обьявление недействительным.</li>
                                
                            </ul>
                        
                        </li>
                        
                        <li>Все строки должны иметь одинаковое число колонок, а иначе обьявление недействительное. Если именованная область сетки охватывает несколько ячеек сетки, и при этом они не формирует единственный заполненный прямоугольник, тогда обьявление недействительное.</li>
                        
                    </ul>
                
                </li>
                
            </ul>
            
            <article>
               
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-named-lines">Неявно именованые линии</a></h4>
                    
                </header>
                
                <p>Свойство <em>grid-template-areas</em> создает неявно именованые линии от именованых областей сетки. Типа, именованная область с именем 'blyat' создает именованые линии 'blyat-start', 'blyat-end' для ряда и 'blyat-start', 'blyat-end' для колонки.</p>
                
            </article>
            
            <article>
                
                <header class="header header--center">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-named-areas">Неявно именованые области</a></h4>
                    
                </header>
                
                <p>Так как на именованые области сетки ссылаются с помощью неявно именованых линий, которые они производят, явно добавленные именованые линии такой же формы ('blyat-start'/'blyat-end') формируют именованную область сетки ('blyat'). На эти неявно именованые области сетки можно ссылаться через свойства размещения в сетке.</p>
                
            </article>
            
        </div>
        
        <article>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#explicit-grid-shorthand">Краткая запись явно определенной сетки</a>: свойство <em>grid-template</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/c1d14415d44893e8a0a4f68e5afc95d6.png" alt="grid-template">
            
            <p>Это свойство для краткой записи свойств <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>. Поскольку это краткая запись для трех свойств, то и значения тут не в рот ебись, поэтому рассмотрм этот адский синтаксис:</p>
            
            <ul class="list">
            
                <li><em>none</em>: устанавливает значения все трех свойств к их начальному значению <em>none</em>;</li>
                
                <li><em>'grid-template-rows'/'grid-template-columns'</em>: записывает определенные значения для свойств <em>grid-template-rows</em> и <em>grid-template-columns</em> соответственно, и устанавливает для свойства <em>grid-template-areas</em> значение <em>none</em>;
                
                    <p>Выглядит это так:</p>
                
                    <img src="https://i.gyazo.com/69992a2dac9f94eb28705a69b352d223.png" alt="first example of grid-template">
                    
                    <p>И это эквивалентно следующему:</p>
                    
                    <img src="https://i.gyazo.com/6903a7ec1aeb36a845311365784a2e7c.png" alt="equivalent to first exaple of grid-template">
                
                </li>
                
                <li><em>'[ 'line-names' ? 'string' 'track-size' ? 'line-names' ? ] + [ / 'explicit-track-list' ] ?'</em>:
                
                    <ul class="list">
                    
                        <li>устанавливает свойство <em>grid-template-areas</em> для перечисленных текстовых строк;</li>
                        
                        <li>устанавливает свойство <em>grid-template-rows</em> к значению размера трека (<em>'track-size'</em>), следуя за каждой строкой (заполняя пропущенные значения как <em>auto</em>), обьединяя каждый ряд с помощью именованых линий, определенных перед/после каждого размера;</li>
                        
                        <li>устанавливает свойство <em>grid-template-columns</em> к значению трек-листа, который определен после слэша (или <em>none</em>, если трек-лист не определен).</li>
                        
                    </ul>
                    
                    <p>Пример для наглядности:</p>
                    
                    <img src="https://i.gyazo.com/7030f4cda0a7aacfe59bf024374872f2.png" alt="second example of grid-template">
                    
                    <p>Что эквивалентно:</p>
                    
                    <img src="https://i.gyazo.com/2a2335137a9d2b7fb96f9a1c401e68ab.png" alt="equivalent to second exaple of grid-template">
                    
                    <p>И создает такую сетку:</p>
                    
                    <img src="https://i.gyazo.com/ea1ab9d3b5656f813b6c70308b93e6b5.png" alt="created grid from second exaple of grid-template">
                    
                    <p>Следует заметить, что функция <em>repeat()</em> в этом случае не используется, потому шо низзя.</p>
                
                </li>
                
            </ul>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#implicit-grids">Неявно определенная сетка</a></h4>
                
            </header>
            
            <p>Свойства <em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em> определяют фиксированное число треков, что формируют явно определенную сетку. Когда элементы сетки расположены вне этих ограничений, контейнер сетки создает неявно определенные треки сетки путем добавления неявных линий сетке. Эти линии вместе с явно определенной сеткой образовывает неявно определенную сетку. Свойства <em>grid-auto-rows</em>, <em>grid-auto-columns</em> устанавливают размер для этих неявно определенных треков.</p>
            
            <p>Свойство <em>grid-auto-flow</em> контролирует автоматическое расположение элементов сетки без их явно определенного размещения. Когда явно определенная сетка заполнена, или если ее не существует, тогда автоматическое размещение будет причиной образования неявно определенных треков сетки.</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#auto-tracks">Установление размера</a> для неявно определенных треков сетки: свойтсва <em>grid-auto-rows</em> и <em>grid-template-columns</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/5c7fce79c17c81564e60fec228aea4de.png" alt="implicit grid tracks">
            
            <p>Если элемент сетки размещен в внутри ряда или колонки, размер которого явно не установлен с помощью свойств <em>grid-template-rows</em> и <em>grid-template-columns</em>, создаются неявно определенные треки, чтобы удержать его внутри себя. Это может произойти либо путем явного расположения внутри ряда или строки, что находятся за пределами сетки, либо с помощью алгоритма автоматического размещения, создающего дополнительные ряды или колонки. Свойства <em>grid-auto-rows</em> и <em>grid-auto-columns</em> устанавливают размер таких неявно созданных треков.</p>
            
            <p>Пример для наглядности:</p>
            
            <img src="https://i.gyazo.com/9041c04c0c22d084437672bd7f8be3e3.png" alt="styles and layout">
            
            <p>И бралалалам! Получили такую вот сетку:</p>
            
            <img src="https://i.gyazo.com/49c568a9b4a81bfdf73b2dc315ebbdae.png" alt="grid from grid-auto-* properties">
            
        </article>
        
        <article>
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-auto-flow-property">Автоматическое размещение</a>: свойство <em>grid-auto-flow</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/07c869eb66f4f6a824e7cf4f6baca3ab.png" alt="grid-auto-flow property">
            
            <p>Элементы сетки, которые не размещены явно с помощью свойств, описанных выше, автоматически размещаются внутри незанятого пространства в контейнере сетки, в чем помогает <a href="https://www.w3.org/TR/css-grid-1/#grid-item-placement-algorithm">алгоритм автоматического размещения</a>. Свойство <em>grid-auto-flow</em> контролирует, как этот алгоритм работает, определяя, как именно элементы будут автоматически размещены в потоке сетки, осуществляя поиск вдоль рядов и добавляя их, или вдоль колонок и также добавляя их, если необходимо. Это свойство принимает следующие значения:</p>
            
            <ul class="list">
               
                <li><em>'row'</em>: упомянутый алгоритм размещает элементы, заполняя каждый ряд поочереди, добавляя новые при необходимости. Если никакое значение не указано (ряд или колонка), предполягается, что это будет ряд;</li>
                
                <li><em>'column'</em>: алгоритм размещает элементы, заполняя каждую колонку поочереди, добавляя новые при необходимости;</li>
                
                <li><em>'dense'</em>: если это значение определено, тогда ауто-плейсед алгоритм использует плотный упаковочный алгоритм. (шо, бля?) Он делает попытку заполнить дыры в сетке, оставленные элементами покрупнее раньше, если позже появятся элементы поменьше. (...) Это может стать причиной появления элементов не по порядку и они при этом заполнят дыры, что были оставлены более крупными элементами. Вооооот. А если оно упущено, тогда используется неплотный (разреженный) алгоритм упаковки, в котором ауто-плейсед алгоритм двигается вперед, когда размещает элементы в сетке, и не пытается заполнить дыры, ведь ему на них похуй, поскольку по умолчанию он движется последовательно и не возвращается назад, чтобы заполнить пространство. Это даст гарантию, что все элементы, размещенные таким образом, будут идти по порядку, и срать на то, что могут остаться дыры, которые могли бы быть  позже заполнены элементами.</li>
                
            </ul>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-shorthand">Краткая запись определения сетки</a>: свойство <em>grid</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/6f250a73c9a623216c6145cc451b560f.png" alt="grid property">
            
            <p>Свойство <em>grid</em> это краткая запись, что записывает все свойства явно определенной сетки (<em>grid-template-rows</em>, <em>grid-template-columns</em> и <em>grid-template-areas</em>), свойства неявно определенной сетки (<em>grid-auto-rows</em>, <em>grid-auto-columns</em> и <em>grid-auto-flow</em>) и свойства гуттеров (<em>grid-column-gap</em> и <em>grid-row-gap</em>) в одном объявлении. Свойства гуттеров единственные, которые могут быть сброшены; остальные субсвойства могут быть заданы либо через синтаксис <em>grid-template</em>, либо через дополнительную синтаксическую форму для определения сеток в автоматическом потоке. Суууукаааа. В общем объявление свойства <em>grid</em> строится на том, что может использоваться два варианта комбинаций, как это показано ниже:</p>
            
            <ul class="list">
                
                <li><em>'grid-template-rows' / [ auto-flow && dense ? ] 'grid-auto-columns' ?</em> - тут явно определенные ряды и неявно - колонки;</li>
                
                <li><em>[ auto-flow && dense? ] 'grid-auto-rows' ? / 'grid-template-columns'</em> - здесь уже имеем комбинацию неявно определенных рядов сетки и явно - колонок.</li>
                
            </ul>
            
            <p>Вот, что пишет спецификация: устанавливается автоматический поток, что делается с помощью записи явно определенных треков в одной оси (т.е. через какое-то одно из двух свойств: либо <em>grid-template-rows</em>, либо <em>grid-template-columns</em>, - а оставшееся тогда записывается к значению <em>none</em>) и указания, как треки будут автоматически повторятся в другой оси (и опять таки записывается значение для одного из двух свойств, неявно определяющих треки: <em>grid-auto-rows</em> или <em>grid-auto-columns</em> - а то свойство, что осталось нетронутым, будет иметь значение <em>none</em>). Свойству <em>grid-auto-flow</em> также записываются значения либо <em>row</em>, либо <em>column</em> соответственно вместе с <em>dense</em>, если то определено.</p>
            
            <p>Все остальные субсвойства сбрасываются к их исходным значениям.</p>
            
            <p>Итак, можно указать только явно или неявно определенные свойства сетки в одном объявлении <em>grid</em>. Остальные свойства, что не были указаны будут иметь свои исходные значения, а свойства для гуттеров сбрасываются этой краткой записью, даже если они и не могут быть ею установлены. Т.е. это свойство немножечко гандон.</p>
            
            <p>Ну и куда же без примеров. Тем более, что тут они полюбасу нужны. Вооооот:</p>
            
            <ul class="list">
               
                <li>запись <em>grid: auto-flow 1fr / 100px;</em> сотворит такое: 
                    
                    <img src="https://i.gyazo.com/cebfff8035f1257317ccc1f669cfe4c3.png" alt="example">
                    
                </li>
                
                <li>а эта <em>grid: none / auto-flow 1fr;</em> такое:
                
                    <img src="https://i.gyazo.com/c86c84b56feac955f4b0a6bfbde59807.png" alt="example">
                
                </li>
                
            </ul>
            
        </article>
        
        <p>Хууууухх... Идем дальше.</p>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#placement">Размещение</a> элементов сетки</h3>
            
        </header>
        
        <p>Каждый элемент сетки имеет область, представляющую из себя прямоугольный набор ячеек, которые эти элементы занимают. Эта область определяет вмещающий блок для элемента сетки, внутри которого свойства самовыравнивания (<em>justify-self</em> и <em>align-self</em>) устанавливают фактичскую позицию элементов. Ячейки сетки также влияют на определение размеров рядов и строк сетки.</p>
        
        <p>Местоположение области элемента внутри сетки определяется ее размещением, что состоит из положения (<em>grid position</em>) и охвата (<em>grid span</em>) в сетке:</p>
        
        <ul class="list">
           
            <li><em>grid position</em> - местоположение элемента в сетке. Положение может быть или явно указаным, или установленым автоматическим размещением;</li>
            
            <li><em>grid span</em> - сколько треков сетки занимает элемент. Охват в сетке всегда определен, и по умолчанию обрабатывается как 1, если ему не установлено иное.</li>
            
        </ul>
        
        <p>Свойства размещения в сетке - их длинная запись: <em>grid-row-start</em>, <em>grid-row-end</em>, <em>grid-column-start</em>, <em>grid-column-end</em> - и краткая запись: <em>grid-row</em>, <em>grid-column</em> и <em>grid-area</em> - позволяют установить размещение элемента сетки, предоставляя любую (или никакую) из следующих кусков информацию:</p>
        
        <img src="https://i.gyazo.com/9e32eeea269ec88baeb7cc0e46d631ff.png" alt="values for grid-placement properties">
        
        <p>Следующая табличка резюмирует условия, под которым позиция или охват в сетке определены, или же автоматические:</p>
        
        <img src="https://i.gyazo.com/662b1431f4e950e49dc67d5b6199cf39.png" alt="table in which grid position or span is definite or automatic">
        
        <div>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses">Общие модели</a> для размещения в сетке</h4>
                
            </header>
            
            <p>Если взять свойства размещения в сетке и организовать их краткие формы записи, тогда получим вот такую пирамиду на подобие Маслоу:</p>
            
            <img src="https://i.gyazo.com/e5f58b3ed7b0d9883fc83caef0505dea.png" alt="shorthands for grid-placement propeties">
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-named-areas">Именованые области</a></h4>
                    
                </header>
                
                <p>Элемент может быть размещен внутри именованой области сетки, устанавливая имя области в свойстве <em>grid-area</em> (похожим макаром это делается и с помощью <em>grid-template-areas</em>). Также элемент может быть частично выровнен в сетке внутри именованой области, располагаясь у каждой отдельной линиии, что представляет грань этой области.</p>
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-numeric">Числовые индексы и соединения</a></h4>
                    
                </header>
                
                <p>Элементы сетки могут быть размещены и их размер может быть определен за числовым индексом, который особенно полезен для разметки, основанной на сценариях (script-driven, блин). По умолчанию охват для элемента сетки назначается как 1, при этом его значения могут быть явно определены для разных значений. Нуууу, тут не мешает навести примеры:</p>
                
                <img src="https://i.gyazo.com/413742fd603b0bffaaff9243149c665f.png" alt="first example">
                
                <img src="https://i.gyazo.com/b04c43bd5639d4f1449d9079b519f00d.png" alt="second example">
                
                <img src="https://i.gyazo.com/0df2a02972e259c2a27eaa8dd355c27b.png" alt="third example">
                
                <p>Значения, означающие охват (<em>span</em>), пишутся через слэш. Если первое значение (перед слэшем) числовой индекс линии, то это обозначает, откуда будет начинаться охват рядов или колонок (в зависимости от того, какому свойству назначено это значение: <em>grid-row</em> или <em>grid-column</em>), а если последнее (после слэша) числовой индекс - где он будет заканчиваться; если значение дано как <em>span 'number'</em> (не важно, первое оно или последнее), это обозначает сколько рядов или колонок будет охвачено в зависимости от того, опять-таки, какому свойству оно назначается. Вродь, понятно пояснил.</p>
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-named-lines">Именованые линии и соединения</a></h4>
                    
                </header>
                
                <p>Так же можно ссылаться не только на числовые индексы линий сетки, а и на их имена (если они им даны). Заметка: если именованая область сетки имеет то же имя, что и линия, тогда алгоритм размещения будет давать предпочтение для использования именованой области сетки вместо линий. И если есть несколько линий, которые имеют одинаковое имя, тогда они устанавливают именованый набор линий сетки, на которые можно сослаться непосредственно, обрабатывая размещение за именем этих линий. Много слов, надо больше картинок:</p>
                
                <img src="https://i.gyazo.com/ce91c45a1b62afe312322f0f8544cfcd.png" alt="first example">
                
                <img src="https://i.gyazo.com/1be32db6ca374e44e5e28b05996c9d3b.png" alt="second example">
                
            </article>
            
            <article>
               
                <header class="header header--center">
                    
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#common-uses-auto-placement">Автоматическое размещение</a></h4>
                    
                </header>
                
                <p>Элемент сетки может быть автоматически размещен в следующей доступной пустой ячейке сетки, увеличивая сетку, если нет оставшегося пространства. Автоматическое размещение может быть объеденено вместе с явно определенным охватом, если элементу следует занять более одной ячейки.</p>
                
                <img src="https://i.gyazo.com/dbf32284a2a9b629e5688c72bfdd331d.png" alt="first example">
                
            </article>
            
        </div>
        
        <article>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#placement-a11y">Размешение элемента сетки и исходный порядок</a></h4>
                
            </header>
            
            <p>Способности свойств размещения в сетке позволяют контенту быть свободно организованными и переопределить порядок внутри сетки, таким образом, визуальное представление отделяется от лежащего в основе исходного порядка документа. Они не заменяют правильное исходное определение порядка и влияют только на его визуальное представление (знак восклицания еще ебанем)!</p>
            
        </article>
        
        <div>
           
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#line-placement">Размешение, основанное на линиях</a>: свойства <em>grid-row-start</em>, <em>grid-column-start</em>, <em>grid-row-end</em> и <em>grid-column-end</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/4ededa19e86cc3f40e8e8b9ec78dfa95.png" alt="line-placement">
            
            <p>Для размещения элементов сетки, что основано на линиях, используются такие значения:</p>
            
            <img src="https://i.gyazo.com/3cc4e9de8739023bb6ae7c2069b6c50a.png" alt="line-placement values">
            
            <p>Итак, свойства <em>grid-row-start</em>, <em>grid-column-start</em>, <em>grid-row-end</em> и <em>grid-column-end</em> определяют размер элементов сетки и их местоположение, через участие в размещении внутри сетке линий, охватов (спаны), или нихуя (что равно значению <em>auto</em>), тем самым устанавливая границы начала строки, начала блока, конца строки и конца блока области сетки, в которой располагается элемент.</p>
            
            <p>Значения этих свойств имеют такой смысл:</p>
            
            <ul class="list">
               
                <li><em>'custom-ident'</em>: попытка сопоставить границу области сетки с именованной областью - если есть именованная линия с имеменем <em>'custom-ident'-start (для grid-*-start) / 'custom-ident'-end (для grid-*-end)</em>, тогда первая такая линия участвует в размещении элемента сетки. 
                
                    <p>Уже упоминалось о том, что именованные области сетки создают неявно именованные линии, поэтому назначение <em>grid-row-start: foo</em> выберет начальную границу этой области (если только перед этим не была указана другая линия с именем <em>foo-start</em>).</p>
                
                    <p>В другом случае это следует обработать так, будто задано целое число '1' вместе с 'custom-ident' (типа, как следующий тип значений внизу);</p>
                    
                </li>
                
                <li><em>'integer && custom-ident'</em>: N-ная линия сетки участвует в размещении элемента. Если дано отрицательное целое число, тогда линии считаются с конечной границы явно определенной сетки.
                
                    <p>Если имя дано как <em>'custom-ident'</em>, тогда линии только с этим именем учитываются. И если линий с этим именем недостаточно, тогда предполагается, что все неявные линии сетки имеют это имя для того, чтобы определить позицию. Т.е. достаточно мощный индикатор для линии.</p>
                    
                    <p>Если целому числу будет назначено '0', тогда обьявление недействительно.</p>
                
                </li>
                
                <li><em>'span && [integer || custom-ident]'</em>: охват сетки участвует в размещении элемента таким образом, что соответствующая граница области элемента сетки находится на расстоянии N-линий от ее противоположной границы в соответствующем направлении. Допустим, что какому-то свойству <em>grid-*-start/grid-*-end</em> дано значение <em>span 'integer'</em>, и тогда берется та граница, к которой относится соответствующиее свойство, и добавляется заданое целым числом количество линий, существующих в сетке (а если нет, то сгенерируемых), которые будут захвачены нашим элементом, указывая, от какой границы и в каком направлении они были добавлены.
                
                    <p>И если имя дано как <em>'custom-ident'</em>, тогда линии только с этим именем учитываются. И если линий с этим именем недостаточно, тогда предполагается, что все неявные линии на стороне явно определенной сетки, соответствующие направлению поиска, имеют это имя для того, чтобы определить вычисление этого охвата.</p>
                    
                    <p>Пример был бы в тему. Итак, представим себе сетку, которая имеет только линии 1 и 2, и поиграемся с ней:</p>
                    
                    <img src="https://i.gyazo.com/72c487ba53c5fd012a4a1ea2992af900.png" alt="example">
                    
                    <p>Это превратит нашу сетку в такую вот, у которой сгенерируются неявные линии:</p>
                    
                    <img src="https://i.gyazo.com/94cc183837f43d07508775ced34cb493.png" alt="result">
                    
                    <p>Если числовое значение упущено, тогда по умолчанию оно имеет '1'. Отрицательные числовые значения и '0' недействительны.</p>
                
                </li>
                
                <li><em>'auto'</em>: это значение никак не участвует в размещении элемента сетки, указывая на автоматическое размещение или охват, значение которого равно по умолчанию '1'.</li>
                
            </ul>
            
            <p>'custom-ident' исключает ключевое слово <em>span</em>.</p>
            
            <article id="conflict_handling">
               
                <header class="header">
                   
                    <h4><a href="https://www.w3.org/TR/css-grid-1/#grid-placement-errors">Решение конфликтов</a> при размещении в сетке</h4>
                    
                </header>
                
                <p>Если размещение элемента сетки содержит две линии, и начальная линия ближе к концу, чем конечная, тогда меняются две линии. Если начальная линия равна конечной, тогда конечная удаляется.</p>
                
                <p>Если размещение вмещает два охвата, удаляется тот, который участвует в свойствах размещения, определяющих конечные границы.</p>
                
                <p>Если размещение вмещает только охват именованной линии, он заменяется на имеющий значение '1'.</p>
                
            </article>
            
        </div>
        
        <article>
            
            <header class="header">
               
                <h4><a href="https://www.w3.org/TR/css-grid-1/#placement-shorthands">Краткая запись</a> для свойств размещения в сетке: свойства <em>grid-row</em>, <em>grid-column</em> и <em>grid-area</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/fe34985a0f91865d1caffe0afcfc8d4e.png" alt="Placement Shorthands">
            
            <p><em>grid-row</em> это краткая запись для <em>grid-row-start</em> и <em>grid-row-end</em>, а <em>grid-column</em> - для свойств <em>grid-column-start</em> и <em>grid-column-end</em>.</p>
            
            <p>Когда второе значение упущено, и если первое значение <em>'custom-ident'</em>, тогда <em>grid-row-end/grid-column-end</em> также записыаются к этому 'custom-ident'; в противном случае это записывается к <em>auto</em>.</p>
            
            <img src="https://i.gyazo.com/f63e0a494263703cdc56e61988e82ab8.png" alt="grid-area">
            
            <p>Порядок для этой краткой записи такой: <em>grid-row-start / grid-column-start / grid-row-end / grid-column-end</em>.</p>
            
            <p>Когда <em>grid-column-end</em> упущено, и если <em>grid-column-start</em> имеет значение <em>'custom-ident'</em>, тогда <em>grid-column-end</em> также записывается к этому значению; в противном случае это записывается к <em>auto</em>.</p>
            
            <p>Когда <em>grid-row-end</em> упущено, и если <em>grid-row-start</em> имеет значение <em>'custom-ident'</em>, тогда <em>grid-row-end</em> также записывается к этому значению; в противном случае это записывается к <em>auto</em>.</p>
            
            <p>Когда <em>grid-column-start</em> упущено, и если <em>grid-row-start</em> имеет значение <em>'custom-ident'</em>, тогда все значения для этих четырех свойств длинной записи записываются к этому значнию; в противном случае это записывается к <em>auto</em>.</p>
            
        </article>
        
        <p>В спецификации еще описывается <a href="https://www.w3.org/TR/css-grid-1/#auto-placement-algo">алгоритм размещения</a>. Только я его трогать не буду.</p>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#abspos">Абсолютное позиционирование</a></h3>
            
        </header>
        
        <article id="abspos_items">
           
            <header class="header">
               
                <h4>Контейнер сетки как <a href="https://www.w3.org/TR/css-grid-1/#abspos-items">вмещающий блок</a></h4>
                
            </header>
            
            <p>Если вмещающий блок абсолютно позиционируемого элемента генерируется контейнером сетки, тогда вмещающий блок соответствует области сетки, что определена свойствами размещения внутри нее. Абсолютно-позиционируемый элемент может выравниваться внутри контейнера по линиям сетки, при этом такой элемент не забирает пространство и не участвует в разметке сетки.</p>
            
            <p>Еще интересно себя ведет значение <em>'auto'</em> в свойствах размещения, которые применяются для абсолютно позиционируемых элементов. Т.е. размещение тут построено не на автоматическом алгоритме, а на участии специальных линий, чьи позиции соответствуют границе внутреннего отступа контейнера сетки. Они становятся первой и последней линиями дополненной сетки, которая используется для позиционирования абсолютных элементов. Таким образом, вмещающий блок абсолютно-позиционируемого элемента будет соответствовать границам внутренних отступов контейнера сетки. И когда свойства размещения ссылаются на линии сетки, которых нет, либо охватывают так, что выходят за пределы существующей неявно определенной сетки, тогда они обрабатываются как такие, которые имеют свойство <em>'auto'</em>. И если размещение содержит в себе только охват сетки, тогда оно заменяется двумя линиями, которые применяются при значении <em>'auto'</em>, в этой оси (применяется <a href="#conflict_handling">второй вариант</a> решения конфликта при размещении в сетке).</p>
            
        </article>
        
        <article>
           
            <header class="header">
               
                <h4>Контейнер сетки как <a href="https://www.w3.org/TR/css-grid-1/#static-position">родительский</a></h4>
                
            </header>
            
            <p>Абсолютно-позиционируемый дочерний элемент контейнера сетки вне потока и не является элементом сетки и поэтому не влияет на размещение других элементов в сетке и на определение размеров сетки.</p>
            
            <p>Позиция абсолютного элемента определяется так, будто он единственный в области сетки, чьи границы совпадают с границами внутренних отступов контейнера сетки. Тем не менее, если родитель-контейнер сетки также генерирует вмещающий блок для абсолютно-позиционируемого элемента, тогда используется область сетки, которая была определена <a href="#abspos_items">выше</a>. На эти элементы влияют значения свойств <em>justify-self и align-self</em>, при этом они никак не влияют на размер вмещающего блока или разметку его контента.</p>
            
        </article>
        
    </section>
    
    <section>
       
        <header class="header">
           
            <h3><a href="https://www.w3.org/TR/css-grid-1/#alignment">Выравнивание и создание промежутков</a></h3>
            
        </header>
        
        <p>После того, как размер треков сетки был определен и измерения элементов сетки были закончены, эти элементы могуть быть выровнены внутри области сетки.</p>
        
        <p>Для выравнивания могут использоваться и свойства внешних отступов. Также элементы сетки признают свойства выравнивания внутри <a href="http://www.w3.org/TR/css-align/">блока</a>, которые позволяют выровнять элементы с помощью ключевых слов по оси рядов и столбцов.</p>
        
        <p>Элементы сетки по умолчанию растягиваются, чтобы заполнить свою область. И тем не менее, если свойства <em>justify-self и align-self</em> расчитывают значения иные, чем <em>stretch</em>, или внешним отступам назначено значение <em>auto</em>, тогда размер элементов сетки определится автоматически, чтобы соответствовать своему контенту.</p>
        
        <article>
           
            <header class="header">
               
                <h4><a href="">Промежутки</a>: свойства <em>grid-column-gap, grid-row-gap и grid-gap</em></h4>
                
            </header>
            
            <img src="https://i.gyazo.com/2e8936882a15ffa02880c0a3a9b4a6f8.png" alt="gutters">
            
            <p>Эти свойства определяют промежутки между рядами и колонками соответственно (между линиями сетки образовывается пространство определенной ширины). Для определения размера трека каждый промежуток рассматривается как дополнительный пустой трек. Отрицательные значения не действительны.</p>
            
            <p>Если сетка рассегментирована между треками, тогда промежутки между ними должны быть уменьшенными. И эти промежутки могут быть только в неявно определенной сетке; и нет промежутков перед первым треком и после последнего. В частности, нет промежутков между первым/последним треком в неявной сетке и <em>'auto'</em> линиями в дополненной сетке. И когда треки схлопываются, то и промежутки эти тоже хляп.</p>
            
            <img src="https://i.gyazo.com/d7abf10bdca68c9c5a232014c34370c9.png" alt="grid-gap">
            
            <p>Это свойство является краткой записью для предыдущих двух. Если <em>grid-column-gap</em> упущено, тогда у него будет значение <em>grid-row-gap</em>.</p>
            
            <img src="https://i.gyazo.com/63e46bc99696d469962b79c8708e56db.png" alt="examples">
            
            <p><em>grid-gap</em> является единственным компонентом видимого промежутка, созданного между областями сетки. Внешние и внутренние отступы, или использование распределенного выравнивания могут увеличить видимое разделение между элементами сетки за пределами того, что определено промежутком, как показано выше.</p>
            
        </article>
        
    </section>
    
</body>
</html>