<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ECMAScript</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  
    <header class="header">
        
        <h1>ECMAScript 2017</h1>
        
    </header>
    
    <p>Вот ссыль на <a href="https://www.ecma-international.org/ecma-262/">спецификацию</a> (самая свеженькая на даный момент - 8-ое издание), которую я рассмотрю здесь. Начнем с краткого обзора того, что такое ECMAScript (он же JavaScript).</p>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-overview">Краткий обзор</a></h2>
           
        </header>
           
        <p>ECMAScript это объектно-ориентированный язык программирования, что выполняется внутри своего окружения. <a href="https://www.ecma-international.org/ecma-262/#sec-web-scripting">Веб-браузер</a> предоставляет окружение для вычислений на стороне клиента (это объекты в виде окон, меню, диалоговых окон, фреймов, истории, куки, ввода/вывода, и другого разнообразия, а также способы для прикрепления кода к событиям мыши, отправки формы, загрузки страницы, ошибок, выбора и тд.). Веб-сервер предоставляет свое окружение для вычислений (а это объекты в виде запросов, клиентов, файлов, а также механизмы блокировки и обмена данными). Совместное выполнение скриптов на стороне браузера (клиента) и сервера  дает возможность распределить вычисление, предоставляя индивидуальный пользовательский интерфейс для веб-приложений. Каждый браузер и сервер вместе завершают окружение выполнения ECMAScript.</p>

        <div>

            <p>Перед тем, как дальше углубиться в дебри языка, рассмотрим в сжатом виде ECMAScript. Программа ECMAScript это набор взаимодействующих объектов, которые являются основой ECMAScript. Объект это собрание свойств, у которых есть атрибуты. Свойства же в свою очередь это контейнеры для других объектов, примитивных значений, или функций. Примитивным есть значение, что представляет один из следующих типов ECMAScript: <em>Undefined</em> (неопределенное), <em>Null</em> (значение для нихуя), <em>Boolean</em> (булевское значение true/false), <em>Number</em> (число), <em>String</em> (строка), и <em>Symbol</em> (символ). Объект это представитель типа <em>Object</em>, а функция - это вызываемый объект. Та функция, что связывается с объектом через свойство, зовется <em>методом</em>.</p>

            <p>Набор ECMAScript объектов включает в себя глобальный объект; основные объекты для динамической семантики (формальной модели) языка (<em>Object, Function, Boolean, Symbol, и Error</em>); объекты, что представляют и манипулируют числовыми значениями (<em>Math, Number, и Date</em>); объекты, обрабатывающие текст (<em>String и RegExp</em>); объекты, что являются пронумерованными наборами значений (<em>Array</em> и другие его виды); ключевые наборы (<em>Map и Set</em>); объекты, что поддерживают структурированные данные (<em>JSON, ArrayBuffer, SharedArrayBuffer, и DataView</em>); объекты, что поддерживают абстрактные понятия управления (<em>функции-генераторы и Promise</em>); отражающие объекты (<em>Proxy и Reflect</em>).</p>

            <p>Еще ECMAScript определяет набор операторов, среди которых унарные, запятые, логические, назначения, равенства, относительные и тд. Также большие програмы ECMAScript поддерживают модульность, что позволяет разделить программу на множество последовательностей из конструкций и объявлений. Да и синтаксис языка лайтовый (нет, например, строгой типизации), хоть в нем и существует возможность использовать строгий режим.</p>

            <!-- <article>

               <header class="header">

                   <h3><a href="https://www.ecma-international.org/ecma-262/#sec-objects"><em>Объекты</em></a></h3>

               </header>

               <p>Объекты ECMAScript не основаны на классах, хоть ECMAScript и имеет в себе синтаксис для их определения. Объекты могут быть созданы разными способами, включая возможность их создания через литеральное описание или через конструкторы (объекты от конструкторов инициализируются через назначение их свойствам начальных значений). Конструктор является функцией, что имеет свойство <em>'prototype'</em>, которое используется, чтобы реализовать наследование, основанное на прототипировании и разделяемых свойствах.</p>

               <p>Каждый объект, созданный с помощью конструктора, имеет неявную ссылку (что зовется прототипом объекта) на значение свойства <em>'prototype'</em> его конструктора. Более того, у прототипа так же может быть прототип, на который можно неявно сослаться, и так далее, - это называется цепочкой прототипов. Когда в объекте делается ссылка на свойство, она ссылается на свойство с таким именем в первом попавшемся в цепочке объекте, в котором оно содержится (имеется в виду, что будут рассматриваться объекты в цепочке прототипов до тех пор, пока не будет найден именно тот первый объект, содержащий данное искомое свойство, на которое ссылаются).</p>

               <img src="https://i.gyazo.com/2101c448bb59baac2ec207c0b6bb014b.png" alt="Object/Prototype Relationships">

               <p>В ECMAScript состояние и методы переносятся объектами, и в то же время структура, поведение и состояние наследуются. Объекты, которые не содержат в себе конкретное свойство, что содержится в их прототипе, разделяют это свойство и его значение (через наследование).</p>

            </article> -->

            <article>

               <header class="header">

                   <h3><a href="https://www.ecma-international.org/ecma-262/#sec-strict-variant-of-ecmascript">Строгий вариант ECMAScript</a></h3>

               </header>

               <p>ECMAScript определяет строгий вариант языка. Он исключает некоторые определенные синтаксические и семантические свойства обычного ECMAScript и меняет детализированную семантику некоторых его свойств. Строгий вариант также определяет дополнительные условия для ошибок, которые должны быть зарегистрированы путем выкидывания соответствующих исключений в ситуациях, которые не определены как ошибочные в не строгой форме языка.</p>

               <p>Строгий вариант языка обычно указывается как строгий режим (<em>strict mode</em>). Строгий режим налагает ограничения, что имеют только локальный эфект внутри синтаксической единицы ECMAScript (на индивидуальном уровне для этой единицы). Программа может состоять из синтаксических единиц ECMAScript, что написаны в строгом и не строгом режиме.</p>

            </article>

        </div>
              
   </section>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-data-types-and-values">Типы данных и значений в ECMAScript</a></h2>
           
       </header>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types">Типы языка ECMAScript</a></h3>
               
           </header>
           
           <p>Типы языка есть следующие: <em>Undefined (неопределенный), Null (нулевой), Boolean (для булевских значений), String (для значений в виде строки), Symbol (для символов), Number (для числовый значений), и Object (для объектов)</em>. Кратко рассмотрим каждый тип.</p>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-undefined-type">Неопределенный тип (Undefined)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>undefined</strong>. Каждая переменная, которой не было назначено какое-либо значение, будет иметь в качестве него <em>undefined</em>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-null-type">Нулевой тип (Null)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>null</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-boolean-type">Булев тип (Boolean)</a></h4>

               </header>
               
               <p>Булев тип (логический) служит для представления логической сущности, что имеет два значения: <strong>true</strong> и <strong>false</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-string-type">Строковый тип (String)</a></h4>

               </header>
               
               <p>Данный тип в основном используется для представления текстовой информации в программе ECMAScript, и в этом случае каждый элемент обрабатывается как значение единицы кода UTF-16 (UTF-16 это кодировка символов Юникода). Элемент тут рассматривается, как занимающий конкретную позицию внутри строки, а это последовательность из элементов. Эти позиции индексируются не отрицательными целыми числами: первый элемент будет иметь индекс 0, второй - 1, и тд. Длина строки это число элементов в ней (пустая строка имеет длину 0).</p>
               
               <p>Операции ECMAScript, интерпретирующие строковые значения, рассматривают каждый элемент как отдельную кодовую точку UTF-16. ECMAScript не накладывает никаких ограничений или требований на последовательность кодовых точек в значении строки. Операции, что не интерпретируют контент строки, обрабатывают ее, как универсальную нерасчлененную 16-битную целочисленную переменную без знака.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-symbol-type">Тип для символов (Symbol)</a></h4>

               </header>
               
               <p>Этот тип является набором значений, что могут быть использованы, как ключи свойства объекта. Каждое возможное значение этого типа уникальное и неизменное.</p>
               
               <p>Известные символы как правило используются в качестве ключей свойств, чьи значения служат как точки расширения алгоритма спецификации, и они наводятся в этой <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-1">таблице</a>.</p>
               
           </article>
           
           <article>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-number-type">Числовой тип (Number)</a></h4>

                </header>

                <p>Данный тип представляет значения, которые являются 64-битными формата IEEE 754-2008, и их количество составляет дохера (2<sup>64</sup>-2<sup>53</sup>+3). Среди них есть особенные. Первым особенным значением есть <strong>NaN</strong> (“Not-a-Number”, которое производится программным выражением <strong>NaN</strong>). В коде ECMAScript <em>NaN</em> значения не отличимы друг от друга, при этом в некоторых реализациях код способен обнаружить разницу между разными <em>NaN</em> значениями (а разные значения <em>NaN</em> не равны друг другу).</p>

                <p>Еще одними особенными значениями есть позитивная и отрицательная беснонечности, которые изображают с помощью символов <strong>+&#8734;</strong> и <strong>-&#8734;</strong> (оба они производятся программными выражениями <strong>+Infinity</strong> (или просто <strong>Infinity</strong>) и <strong>-Infinity</strong>).</p>

                <p>Остальные значения являются конечными, и половина из них это позитивные значения, а другая - отрицательные. Для каждого конечного числового значения существует соответствющее ему отрицательное по модулю.</p>

                <p>Также в ECMAScript не один ноль, а два: позитивный и отрицательный. Выражаются они символами <strong>+0</strong> и <strong>-0</strong> (два этих значения, выражающие по сути ноль, производятся программными выражениями <strong>+0</strong> (или просто <strong>0</strong>) и <strong>-0</strong>).</p>
                
                <p>Все положительные и отрицательные целые числа, величина которых по модулю не превышает 2<sup>53</sup>, представлены в типе чисел.</p>
               
           </article>
           
            <section>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-type">Объектный тип (Object)</a></h4>

                </header>

                <p>Объект это собрание свойств. Есть свойства данных и свойства доступа:</p>
                
                <ul class="list">
                    
                    <li><em>свойство данных</em> связывает свой ключ со значением ECMAScript и набором соответствующих атрибутов;</li>
                    
                    <li><em>свойство доступа</em> связывает свой ключ с функциями доступа и набором соответствующих атрибутов. Функция доступа используется для хранения или извлечения значения ECMAScript, которое связано со свойством.</li>
                    
                </ul>
                
                <p>Свойства идентифицируются, используя ключ значений. Ключом значения свойства есть либо строка, либо символ ECMAScript. Все строки и символы, включая пустую строку, это корректные ключи свойств. Ключ, что выражает имя свойства, является строкой. Еще вместо именованных свойств используются целочисленные индексы, которые являются ключами свойства строкового типа и чьё числовое значение находится в диапазоне от +0 до 2<sup>53</sup>-1 включительно. В массивах индексы имеют значения +0 <span>&#8804;</span> <em>i</em> <span>&#60;</span> 2<sup>32</sup>-1.</p>
                
                <p>Ключи используются, чтобы получить доступ к свойствам и их значениям. Существует два вида доступа к значениям свойств: получение (<em>get</em>) и запись (<em>set</em>), что соответствует либо операции извлечения значения, либо операции его назначения. Свойства, доступные через получение и запись, могут быть собственными или унаследованными от другого объекта (наследование в действии).</p>
                
                <p>Есть несколько форм объектов, что отличаются в своей семантике доступа и управления свойствами. Это обычные объекты и необычные, чья семантика свойств отличается от той, что предоставлена по умолчанию (массивы, например). Теперь рассмотрим объекты пристальней.</p>
                
                <article>
                    
                    <header class="header header--center">
                        
                        <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-attributes">Атрибуты свойства</a></h4>
                        
                    </header>
                    
                    <p>Атрибуты используются, чтобы определить и объяснить состояние свойств объекта. Свойство данных связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-2">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств данных</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="value_attr">
                           
                            <td>[[Value]] (значение)</td>
                            
                            <td>Любой тип ECMAScript</td>
                            
                            <td>Значение, что извлекается при получении доступа к свойству.</td>
                            
                        </tr>
                        
                        <tr id="write_attr">
                           
                            <td>[[Writable]] (перезаписи)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, возможно ли перезаписать значение атрибута [[Value]] соответствующего свойства. Если значением этого атрибута является <strong>false</strong>, тогда попытки изменить значение атрибута [[Value]], используя атрибут записи [[Set]], потерпят неудачу.</td>
                            
                        </tr>
                        
                        <tr id="enum_attr">
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, будет ли свойство объекта перечислено при применении цыкла. Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В ином случае, свойство является не перечислимым (т.е. циклы его пропустят).</td>
                            
                        </tr>
                        
                        <tr id="config_attr">
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, является ли свойтсво настраиваемым. Если значением этого атрибута является <strong>false</strong>, тогда попытки удалить или изменить свойство, чтобы оно стало свойством доступа, или изменить его атрибуты (кроме атрибута [[Value]] и/или [[Writable]] на <strong>false</strong>) потерпят неудачу.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Свойство доступа связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-3">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств доступа</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="get_attr">
                           
                            <td>[[Get]] (получение)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). У функции же в свою очередь есть внутренний метод вызова [[Call]], который вызывается с пустым списком аргументов каждый раз, когда используется атрибут свойства доступа [[Get]], чтобы извлечь значение (работу метода ([[Call]]) рассмотрим позже).</td>
                            
                        </tr>
                        
                        <tr id="set_attr">
                           
                            <td>[[Set]] (запись)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). Внутренний метод вызова функции [[Call]] вызывается со списком аргументов, что содержит присваиваемое значение, каждый раз, когда используется атрибут свойства записи [[Set]], чтобы записать (присвоить) новое значение.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В другом случае, свойство не перечислимое.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>false</strong>, тогда попытки удалить свойство, изменить его, чтобы оно стало свойством данных, или изменить его атрибуты, потерпят неудачу.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Значения по умолчанию для атрибутов свойств следующие:</p>
                    
                    <table>
                        
                        <caption>Значения атрибутов по умолчанию</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Значение по умолчанию</th>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Поддающийся записи ([[Writable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Перечислимый ([[Enumerable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Настраиваемый ([[Configurable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Значение ([[Value]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Получение ([[Get]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Запись ([[Set]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                    </table>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4><a href="https://www.ecma-international.org/ecma-262/#sec-object-internal-methods-and-internal-slots">Внутренние</a> методы объектов и слоты (ячейки)</h4>
                        
                    </header>
                    
                    <p>Внутренние методы это алгоритмы, что определяют фактическую семантику объектов (их поведение во время выполнения). Имена внутренних методов полиморфные, а это означает, что выполняются разные алгоритмы при вызове такого метода, если объект имеет для них разные значения. Если вызывается внутренний метод, который не поддерживается объектом, тогда программа выкинет исключение об ошибке <strong>TypeError</strong>. Внутренний метод возвращает завершающую запись и всегда имеет доступ к целевому объекту.</p>
                    
                    <p>Внутренние слоты соответствуют внутреннему состоянию, которое связано с объектами, и используются различными алгоритмами ECMAScript. Эти слоты не наследуются и являются частью создания объекта, при этом они не могут быть добавлены динамически. Внутреннее состояние может состоять из значений любого типа ECMAScript. Начальное значение внутреннего слота это <strong>undefined</strong>. ECMAScript не предоставляет прямого пути, чтобы связать внутренние слоты с объектом.</p>
                    
                    <p><a href="https://www.ecma-international.org/ecma-262/#table-5">Таблица</a> ниже обобщает важные внутренние методы, которые применимы ко всем объектам, что были созданы с помощью кода ECMAScript:</p>
                    
                    <table>
                        
                        <caption>Важные внутренние методы</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-get_proto">
                           
                            <td>[[GetPrototypeOf]]</td>
                            
                            <td>() <span>&#8594;</span> Object | Null</td>
                            
                            <td>Для своего объекта этот метод определяет тот объект, который предоставляет наследуемые свойства (иными словами, с его помощью определяется прототип). Значение <strong>null</strong> указывает, что нет никаких наследуемых свойств (это значение у того объекта, который не имеет прототипов в своей цепочке, поскольку он в ней первый). Цепь прототипов имеет конечную длину при том условии, если в ней не встречаются необычные объекты, которые не используют обыкновенное определение этого метода, ведь тогда это может призвести к бесконечному цыклу при попытке получить доступ к свойствам объекта-прототипа.</td>
                            
                        </tr>
                        
                        <tr id="internal-set_proto">
                           
                            <td>[[SetPrototypeOf]]</td>
                             
                            <td>(Object | Null) <span>&#8594;</span> Boolean</td>
                            
                            <td>Связывает свой объект с другим объектом, который предоставляет наследуемые свойства (записывает объекту прототип). Если в аргументе <strong>null</strong>, тогда оно указывает на то, что нет никаких наследуемых свойств. Если возвращаемое значение <strong>true</strong>, это указывает на успешное завершение операции, а если <strong>false</strong> - операция не была успешной.</td>
                            
                        </tr>
                        
                        <tr id="internal-isextensible">
                           
                            <td>[[IsExtensible]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Определяет, разрешается ли добавить дополнительные свойства объекту.</td>
                            
                        </tr>
                        
                        <tr id="internal_prev_exts">
                           
                            <td>[[PreventExtensions]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Контролирует могут ли новые свойства быть добавлены объекту. Если операция по превращению объекта в нерасширяемый прошла успешно, тогда этот метод вернет <strong>true</strong> (после этого дополнительные свойства не смогут быть добавлены объекту, и после этого метод [[IsExtensible]] вернет <strong>false</strong>), в противном случае - <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-get_prop_o">
                           
                            <td>[[GetOwnProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Undefined | Property Descriptor</td>
                            
                            <td>Возвращает значение <em>Property Descriptor</em> (описание) для собственного свойства объекта, если оно существует (ключ свойства передается тут в качетсве аргумента - <em>propertyKey</em>). А если возвращает <strong>undefined</strong>, тогда такого свойства не существует в этом объекте.</td>
                            
                        </tr>
                        
                        <tr id="internal-define_prop_o">
                           
                            <td>[[DefineOwnProperty]]</td>
                             
                            <td>(<em>propertyKey, Property Descriptor</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Создает или меняет свобственное свойство (его ключ определен в аргументе <em>propertyKey</em>), чтобы оно имело состояние, которое описывается во втором аргументе (Property Descriptor). Возвращает <strong>true</strong>, если свойство было создано/обновлено. В противном случае - <strong>false</strong>, если существует одно из следующих состояний: свойство не настраиваемое, объект не расширяемый или свойства не существует.</td>
                            
                        </tr>
                        
                        <tr id="internal-has_prop">
                           
                            <td>[[HasProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Возвращает булевское значение, указывая, имеет ли данный объект собственное, или наследуемое свойство, ключ которого - <em>propertyKey</em> (<strong>true</strong>), или не имеет (<strong>false</strong>).</td>
                            
                        </tr>
                        
                        <tr id="internal-get">
                           
                            <td>[[Get]]</td>
                             
                            <td>(<em>propertyKey, Receiver</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Возвращает значение свойства объекта (ключ свойства - <em>propertyKey</em>). Если для того, чтобы извлечь значение свойства, нужно выполнить код ECMAScript, аргумент <em>Receiver</em> используется как значение <strong>this</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-set">
                           
                            <td>[[Set]]</td>
                             
                            <td>(<em>propertyKey, value, Receiver</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Записывает значение, что соответсвует второму аргументу (<em>value</em>), свойству с ключом <em>propertyKey</em>. Если для того, чтобы записать значение свойства, нужно выполнить код ECMAScript, аргумент <em>Receiver</em> используется как значение <strong>this</strong>. Возвращает <strong>true</strong>, если значение свойства было записано, а в противном случае - <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-delete">
                           
                            <td>[[Delete]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Удаляет собственное свойство, ключ которого это <em>propertyKey</em>, из объекта. Возвращает <strong>false</strong>, если свойство не было удалено и все еще находится в объекте, и <strong>true</strong>, если оно было удалено и не находится в объекте. Если свойство не настраиваемое ([[Configurable]] <span>&#8594;</span> <strong>false</strong>), тогда этот метод вернет <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-prop_keys_o">
                           
                            <td>[[OwnPropertyKeys]]</td>
                             
                            <td>() <span>&#8594;</span> <em>List of properties</em></td>
                            
                            <td>Возвращает список, элементами которого есть все ключи значений собственных свойств объекта.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Существуют еще <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-6">дополнительные</a> внутренние методы для объектов. Объект функции поддерживает внутренний метод вызова ([[Call]]), а конструктор это функция, что поддерживает внутренний метод построения ([[Construct]]).</p>
                    
                    <table>
                        
                        <caption>Дополнительные важные внутренние мтоды объектов функции</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-call">
                           
                            <td>[[Call]]</td>
                            
                            <td>(<em>any, a List of any</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Выполняет код (тот, что внутри функции), связанный с объектом. Вызывается через выражение вызова функции. Аргументами внутреннего метода есть <strong>this</strong> значение и список, что содержит аргументы, которые были переданы функции через выражение вызова. Объекты, что реализовывают этот метод, вызываемые. В общем, берет аргументы функции, выполняет код в контексте конкретного объекта, который соответствует значению <strong>this</strong>, и возвращает результат.</td>
                            
                        </tr>
                        
                        <tr id="internal-construct">
                           
                            <td>[[Construct]]</td>
                             
                            <td>(<em>a List of any, Object</em>) <span>&#8594;</span> <em>Object</em></td>
                            
                            <td>Создает новый объект. Вызывается через операторы <strong>new</strong> и <strong>super</strong>. Первый аргумент этого метода это список из аргументов, что передаются выражению вызова конструктора через какой-то из операторов. Второй - объект, к которому первоначально применяется оператор <strong>new</strong>. Объекты, что реализовывают этот метод, называются конструкторами. В общем, этот метод берет список аргументов, как значения для свойств, и создает новый объект, прототипом которого является <em>Object</em> во втором аргументе.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Если какой-то из внутренних методов объекта не поддерживается реализацией, тогда выскочит <strong>TypeError</strong>.</p>
                    
                </article>
                
                <p>У внутренних методов есть определенные <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-invariants-of-the-essential-internal-methods">признаки</a>.</p>
                
                <p>Существует еще кучища известных встроенных объектов, и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-well-known-intrinsic-objects">тут</a> дается их перечень.</p>
               
           </section>
           
       </section>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-specification-types">Типы спецификации ECMAScript</a></h3>
               
           </header>
           
           <p>Существуют еще скрытые типы, которые используются алгоритмами языка. При выполнении вычслений запускаются внутренние алгоритмы, которые используют значения, что относятся к скрытым типам. Их значения используются внутри алгоритмов для описания семантики конструкций и типов ECMAScript, о которых упоминалось выше. К скрытым типам относятся Ссылка (Reference), Список (List), Завершение (Completion), Описание свойства (Property Descriptor), Лексическое окружение (Lexical Environment), Запись об окружении (Environment Record) и Блок данных (Data Block). Значения, что относятся к этим типам, являются "артефактами" и не могут хранится в свойствах объекта или в переменных ECMAScript.</p>
           
           <article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-list-and-record-specification-type">Типы списка и записи</a></h4>
                   
               </header>
               
               <p>Данный тип используется, чтобы обьяснить определения списков из аргументов в выражениях оператора <strong>new</strong>, в вызовах функциий и в других алгоритмах, где нужен простой упорядоченный список. Список является просто упорядоченной последовательностью элементов, которые содержат конкретные значения.</p>
               
               <p>Тип для записи используется, чтобы обьяснить агрегацию (обьединение) данных внутри алгоритмов. Данный тип содержит одно или более именованных полей. Значение каждого поля это либо значение ECMAScript, либо абстрактное значение. Имена полей используются для определения конкретных разновидностей агрегации.</p>
               
               <article>
               
                   <header class="header header--center">

                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completion-record-specification-type">Тип записи выполнения</a></h4>

                   </header>

                   <p>Тип записи выполнения используется, чтобы обьяснить распостранение значений внутри своей среды и порядок, в котором осуществляется поведение инструкций (<strong>break</strong>, <strong>continue</strong>, <strong>return</strong> и <strong>throw</strong>), что выполняют нелокальную передачу контроля.</p>

                   <p>Значения и поля типа для записи выполнения определены <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-8">ниже</a>:</p>

                   <table>

                            <caption>Поля записи выполнения</caption>

                            <colgroup>

                                <col />

                                <col />

                            </colgroup>

                            <tr>

                                <th>Поле</th>

                                <th>Значение</th>

                                <th>Смысл</th>

                            </tr>

                            <tr>

                                <td>[[Type]]</td>

                                <td>одно из значений <strong>normal</strong>, <strong>return</strong>, <strong>break</strong>, <strong>continue</strong> или <strong>throw</strong></td>

                                <td>Тип выполнения</td>

                            </tr>

                            <tr>

                                <td>[[Value]]</td>

                                <td>любое значение ECMAScript или <strong>empty</strong></td>

                                <td>Созданное значение</td>

                            </tr>

                            <tr>

                                <td>[[Target]]</td>

                                <td>любая строка ECMAScript или <strong>empty</strong></td>

                                <td>Метка передачи контроля</td>

                            </tr>

                        </table>

               </article>
               
           </article>
           
           <!--<article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-and-relation-specification-type">Типы набора и отношения</a></h4>
                   
               </header>
               
               <p>Тип для набора используется, чтобы обьяснить собрание неупорядоченных элементов для использования в модели памяти. Хитромудятину про модель памяти я разбирать не особо намерен.</p>
               
               <p>Тип для отношений используется, чтобы обьяснить ограничения в наборе.</p>
               
           </article>-->
           
           <section>
               
               <header class="header">
                   
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-reference-specification-type">Тип ссылки</a></h4>
                   
               </header>
               
               <p>Тип для ссылки используется, чтобы обьяснить поведение операторов <strong>delete</strong>, <strong>typeof</strong>, <strong>super</strong>, назначения и других фичей языка.</p>
               
               <p>Ссылка это обработанное имя или привязка свойства. Она состоит из трех компонентов (ссылка, что выражается через оператор <strong>super</strong>, состоит из четырех):</p>
               
               <ol class="list">
                   
                   <li>базового значения;</li>
                   
                   <li>имени, на которое ссылаются;</li>
                   
                   <li>и признака состояния строгости ссылки;</li>
                   
                   <li>в ссылке, что выражается через оператор <strong>super</strong>, имеется еще дополнительный компонент, что указывает на значение <strong>this</strong> - <em>thisValue</em>.</li>
                   
               </ol>
               
               <p>Базовое значение принимает <em>undefined</em>, объект, булевское значение, строку, символ, число, или запись окружения (базовое значение ссылки, что выражается через оператор <strong>super</strong>, не принимает в себе запись окружения). Если базовое значение <em>undefined</em>, это указывает на то, что ссылка не содержит в себе значения. Имя, на которое ссылаются, это либо строка, либо символ.</p>
               
               <p>Для работы с ссылкой используются некоторые абстрактные операции. Их важно рассмотреть, поскольку необходимо понимать, как значения излекаются и перезыписываются, когда на них ссылаются.</p>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-getvalue"><em>GetValue(V)</em></a></h4>
                       
                   </header>
                   
                   <p>Абстрактная операция <strong><em>GetValue(V)</em></strong> применяется, когда по ссылке должно быть извлечено значение.</p>
                   
                   <ol class="list">
                       
                       <li>Первый шаг - это <strong>ReturnIfAbrupt(V)</strong>, что возвращает запись выполнения (тип выполнения в данном случае будет <em>return</em> со значением <strong>V</strong>).</li>
                       
                       <li>Далее проверяется тип значения <strong>V</strong> <span>&#8594;</span> <strong>Type(V)</strong>. Если значение <strong>V</strong> это не ссылка, тогда оно возвращается и на этом все.</li>
                       
                       <li>В случае, когда значение <strong>V</strong> это ссылка, будет выполнена операция <strong>GetBase(V)</strong>, которая возвращает базовое значение (<strong>base</strong>).</li>
                       
                       <li>После возвращения базового значения ссылки (<strong>base</strong>) идет проверка <strong>IsUnresolvableReference(V)</strong>. Если базовое значение ссылки это <strong>undefined</strong>, тогда <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>, а это вызовет <span>&#8594;</span> <strong>ReferenceError</strong>, что закончит выполнение алгоритма. В ином случае, когда <strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>, выполнение алгоритма потопает дальше.</li>
                       
                       <li>Убедившись, что базовое значение ссылки не <strong>undefined</strong>, выполняется проверка <strong>IsPropertyReference(V)</strong>. Эта операция вернет <strong>true</strong>, когда подтвердится одно из двух условий: либо базовое значение ссылки (<strong>base</strong>) имеет тип <em>Object</em>, либо оно относится к одному из примитивных типов <em>Boolean, String, Symbol или Number</em> (без <em>Undefined и Null</em>).
                       
                           <ol class="list" type="a">
                               
                               <li>Принадлежность базового значения ссылки (<strong>base</strong>) к примитивному типу проверяется с помощью <strong>HasPrimitiveBase(V)</strong>. Если операция <strong>HasPrimitiveBase(V)</strong> возвращает <strong>true</strong>, это говорит о том, что базовое значение ссылки (<strong>base</strong>) относится к примитивному типу, и оно должно быть преобразовано в соответствующий объект. Такое превращение при этом сценарии сделает операция <a href="#toobject"><strong>ToObject(base)</strong></a>. Это необходимо для дальнейшего выполнения метода <a href="#internal_get"><strong>[[Get]]</strong></a>.</li>
                               
                               <li>Когда базовое значение ссылки (<strong>base</strong>) уже имеет тип <em>Object</em>, тогда алгоритм запустит внутренний метод <a href="#internal_get"><strong>[[Get]]</strong></a>. Имя ключа свойства объекта, на которое ссылаются, возвращает операция <strong>GetReferencedName(V)</strong>, а значение <strong>this</strong> для определения контекста выполнения - операция <a href="#getthisvalue"><strong>GetThisValue(V)</strong></a>. Итак, будет выполнено <span>&#8594;</span> <strong><em>base.[[Get]](GetReferencedName(V), GetThisValue(V))</em></strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернула <strong>false</strong>, тогда алгоритм приступит к последнему плацдарму. На этом этапе алгоритму ничего не остается, как признать базовое значение ссылки записью окружения (<strong>Environment Record</strong>). Для записи окружения будет применен внутренний метод <a href="#get_bind_value"><strong>GetBindingValue(N, S)</strong></a>, который возвращает значение привязки. Он получает имя привязки, на которое ссылаются (его возвращает операция <strong>GetReferencedName(V)</strong>), и булевское значение, которое будет либо <strong>true</strong>, либо <strong>false</strong> в зависимости от того, строгая ли данная привязка, или нет (этот признак возвращается с помощью операции <strong>IsStrictReference(V)</strong>, что определяет строгость семантики ссылки). Будет выполнено <span>&#8594;</span> <strong><em>base.GetBindingValue(GetReferencedName(V), IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-putvalue"><em>PutValue(V, W)</em></a></h4>
                       
                   </header>
                   
                   <p>Алгоритм тут перезаписывает существующее значение. Операции <strong><em>PutValue(V, W)</em></strong> передаются текущее значение (<strong>V</strong>) и то, которое его заменит (<strong>W</strong>).</p>
                   
                   <ol class="list">
                      
                       <li>Сперва алгоритм выполнит <strong>ReturnIfAbrupt(V)</strong> для текущего значения.</li>
                       
                       <li>Затем для значения, которое его заменит - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>После получения этих двух записей алгоритм проверит тип текущего значения <strong>V</strong> <span>&#8594;</span> <strong>Type(V)</strong> <span>&#8594;</span> чтобы определить, является ли оно ссылкой. Если нет, тогда программа выкинет <span>&#8594;</span> <strong>ReferenceError</strong>, закончив дальнейшее выполнение алгоритма.</li>
                       
                       <li>Получив подтверждение того, что <strong>V</strong> это ссылка, вернем базовое значение (<strong>base</strong>) с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Теперь алгоритм проверит ссылку с помощью <strong>IsUnresolvableReference(V)</strong>. Когда у ссылки базовое значение <strong>undefined</strong>, <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>. 
                          
                           <ol class="list" type="a">
                              
                               <li>Если разигрывется такой сценарий, тогда еще подключится проверка строгости ссылки с помощью операции <strong>IsStrictReference(V)</strong> (она определяет, имеет ли ссылка строгую семантику, или нет). Если <strong>IsStrictReference(V)</strong> вернет <strong>true</strong>, тогда <span>&#8594;</span> <strong>ReferenceError</strong>, ведь строгая семантика ссылки при отсуствии в ней значения - это несовместимое сочетание.</li>
                               
                               <li>В другом случае, когда семантика не является строгой <span>&#8594;</span> <strong>IsStrictReference(V)</strong> вернет <strong>false</strong> <span>&#8594;</span> тогда алгоритм выполнит операцию записи <a href="#set-abstr"><strong>Set</strong></a>. Для этого ему нужно выудить глобальный объект (<strong>globalObj</strong>), который будет использоваться в качестве целевого. Это выполнит операция <a href="#get_glob_obj"><strong>GetGlobalObject()</strong></a>.</li>
                               
                               <li>Обращение к глобальному объекту (<strong>globalObj</strong>) исходит из того, что он является хранилищем всех ссылок, которые находятся в его области видимости, в виде свойств. Потому берется имя ссылки (как ключ свойства), которое возвращает <strong>GetReferencedName(V)</strong>, и выполняется операция записи <strong><a href="#set-abstr">Set</a>(globalObj, GetReferencedName(V), W, false)</strong>, которая запишет значение <strong>W</strong> вместо <strong>undefined</strong> для целевого глобального объекта (<strong>globalObj</strong>) в его контексте выполнения. Булевское значение <strong>false</strong> (последний аргумент в списке) это признак строгости ссылки.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если <strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>, это говорит о том, что базовое значение ссылки имеет в себе значение иное от <strong>undefined</strong> и дальше нужно осуществить проверку того, к какому типу оно принадлежит. Это сделает операция <strong>IsPropertyReference(V)</strong>.
                       
                           <ol class="list" type="a">
                               
                               <li>Эта проверка напоминает матрешку, поэтому будет еще выполнена операция <strong>HasPrimitiveBase(V)</strong>. Когда <strong>HasPrimitiveBase(V)</strong> вернет <strong>true</strong>, тогда примитивное базовое значение ссылки будет преобразовано в соответствующий примитивному типу (<em>Boolean, String, Symbol, или Number</em>) объект с помощью операции <a href="#toobject"><strong>ToObject(base)</strong></a>.</li>
                               
                               <li>В случае, когда <strong>HasPrimitiveBase(V)</strong> возвращает <strong>false</strong>, тогда базовое значение ссылки уже имеет тип <em>Object</em>. Получив базовое значение в виде объекта, оно может использоваться как целевой объект для внутреннего метода <a href="#internal-set"><strong>[[Set]]</strong></a>. Он берет ключ свойства, что соответствует имени, на которое ссылаются (его вернет операция <strong>GetReferencedName(V)</strong>), и записывает ему новое значение <strong>W</strong> вместо текущего <strong>V</strong>, выполняя это в контексте значения <strong>this</strong> (его возвращает операция <strong>GetThisValue(V)</strong>). При успешном своем завершении метод <strong>[[Set]]</strong> вернет <strong>true</strong>. Тут еще подтянется проверка <strong>IsStrictReference(V)</strong>. На выходе это выглядит так: <strong><em>base.[[Set]](GetReferencedName(V), W, GetThisValue(V))</em></strong> (<em>succes</em>).</li>
                               
                               <li>При условии, когда внутрннему методу <a href="#internal-set"><strong>[[Set]]</strong></a> не удалось записать новое значение вместо текущего и он вернет <strong>false</strong>, а <strong>IsStrictReference(V)</strong> - <strong>true</strong>, тогда программа выкинет исключение <span>&#8594;</span> <strong>TypeError</strong>.</li>
                               
                               <li>В остальном, вернется результат выполнения <a href="#internal-set"><strong>[[Set]]</strong></a> (<em>succes</em>).</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернет <strong>false</strong>, тогда алгоритм приступит к последнему шагу. На этом этапе базовое значение ссылки будет соответствовать записи окружения (<strong>Environment Record</strong>). К ней будет применен внутренний метод <a href="#set_mut_bind"><strong>SetMutableBinding(N, V, S)</strong></a>, который записывает новое значение существующей привязке (ее имя вернет операция <strong>GetReferencedName(V)</strong>). Итогом будет выполнение: <strong><em>base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getthisvalue">GetThisValue(V)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция возвращает значение <strong>this</strong>, что является объектом, который определяет контекст выполнения.</p>
                   
                   <ol class="list">
                      
                       <li>Обязательное утверждение: ссылка <strong>V</strong> это объект (<strong>IsPropertyReference(V)</strong> возвращает <strong>true</strong>).</li>
                       
                       <li>Затем проверяется, имеет ли ссылка <strong>V</strong> компонент <em>thisValue</em>: выполняется операция <strong>IsSuperReference(V)</strong>. Если она его имеет <span>&#8594;</span> <strong>IsSuperReference(V)</strong> будет <strong>true</strong> <span>&#8594;</span> тогда возвращается значение этого компонента в качестве <strong>this</strong>.</li>
                       
                       <li>Если предыдущая проверка не подтвердилась, тогда возращается базовое значение ссылки (алгоритм выполнит <strong>GetBase(V)</strong>), которое и будет текущим контекстом выполнения - <strong>this</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <!--<article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-initializereferencedbinding">InitializeReferencedBinding(V, W)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция записывает новое значение <strong>W</strong> существующей, при это не инициализированной привязке, на которую ссылаются, в записи окружения, которая является ссылкой.</p>
                   
                   <ol class="list">
                      
                       <li>Сначала возвращается запись для начального значения - <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>После этого возвращается запись для нового значения - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>Обязательное утверждение: начальное значение <strong>V</strong> это ссылка, что подтверждает соответствующая проверка <strong>Type(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: ссылка является обрабатываемой (<strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>).</li>
                       
                       <li>Возвращается базовое значение ссылки с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: базовое значение ссылки является записью окружения (<em>Environment Record</em>).</li>
                       
                       <li>И теперь возвращается операция <strong>base.InitializeBinding(<em>GetReferencedName(V), W</em>)</strong>. К записи окружения применяется внутренний метод <strong>InitializeBinding(N, V)</strong>, что записывает значение <strong>W</strong> для существующей, при это не инициализированной привязки в записи окружения, имя которой возвращает <strong>GetReferencedName(V)</strong>.</li>
                       
                   </ol>
                   
               </article>-->
               
           </section>
           
           <section id="prop_desc">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-descriptor-specification-type">Тип описания свойства</a></h4>
                   
               </header>
               
               <p>Тип описания свойства используется, что объяснить управление и воплощение атрибутов свойств объекта. Значением типа описания свойств является запись. Имя поля это имя атрибута, а значение поля - это соответствующее значение атрибута.</p>
               
               <p>Значения описания свойства в дальнейшем могут быть классифицированы как описание свойств данных и описание свойств доступа, что основаны на существовании или использовании определенных полей. Описание свойства данных включает в себя поля с именами <strong>[[Value]]</strong> и <strong>[[Writable]]</strong> (либо одно из них, либо оба). Описание свойства доступа включает в себя поля с именами <strong>[[Get]]</strong> или <strong>[[Set]]</strong> (либо одно из них, либо оба). Каждое описание свойства имеет поля, имена которых <strong>[[Enumerable]]</strong> и <strong>[[Configurable]]</strong>. Есть еще общее и полное описание свойства, которое имеет все соответствующие поля.</p>
               
               <p>Существуют абстрактные операции для управления значениями описания свойства.</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isaccessordescriptor"><strong>IsAccessorDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства доступа.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isdatadescriptor"><strong>IsDataDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства данных.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isgenericdescriptor"><strong>IsGenericDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> общим описанием свойства.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-frompropertydescriptor"><strong>FromPropertyDescriptor(Desc)</strong></a> записывает значения соответствующих полей свойствам с теми же именами, что создаются для объекта, у которого собственных свойств нет, и возвращает этот объект.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-topropertydescriptor"><strong>ToPropertyDescriptor(Obj)</strong></a> возвращает описание свойства, у которого изначально не было соответствующих полей.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completepropertydescriptor"><strong>CompletePropertyDescriptor(Desc)</strong></a> возвращает полное описание свойства в зависимости от его типа, у которого отсуствуют соответствующие поля, записывая им значения по умолчанию.</li>
                   
               </ul>
               
           </section>
           
           <p>Есть еще типы <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">записи окружения</a>, <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">лексического окруженния</a> и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-data-blocks">блоки данных</a>.</p>
           
       </section>
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-operations">Абстрактные операции</a></h2>
           
       </header>
       
       <p>Существуют абстрактные операции, которые описывают семантику языка.</p>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-type-conversion">Преобразование типов</a></h3>
               
           </header>
           
           <p>ECMAScript неявно выполняет автоматическое преобразование типов при необходимости. Абстрактные операции преобразования типов принимают значения любого типа ECMAScript (при этом они не работают со значениями, что относятся к скрытым внутренним типам языка) и они полиморфные.</p>
           
           <p>Рассмотрим эти абстрактные операции.</p>
           
           <section id="toprimitive">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive">ToPrimitive ( input [ , PreferredType ] )</a></h4>
                   
               </header>
               
               <p>Абстрактная операция <strong>ToPrimitive</strong> преобразовывает входящий аргумент <strong>input</strong> к примитивному типу. Объект может быть преобразован в более чем один примитивный тип, поэтому используется дополнительное указание <strong>PreferredType</strong>, чтобы ткнуть пальцем на предпочтительный тип для преобразования. Эта операция выполняется согласно такому алгоритму:</p>
               
               <ol class="list">
                  
                   <li>Сначала утверждается, что <strong>input</strong> это значение любого типа ECMAScript.</li>
                   
                   <li>Далее проверяется тип входящего аргумента <strong>input</strong> <span>&#8594;</span> <strong>Type(input)</strong>. Если выдает, что <strong>input</strong> принадлежит к типу <em>Object</em>, тогда алгоритм выполнит следующие шаги:
                   
                       <ol class="list" type="a">
                           
                           <li>Сперва алгоритм должен узнать, к какому примитивному типу следует преобразовать объект <strong>input</strong>. Если аргументу <strong>PreferredType</strong> не было передано никакого указания, тогда ему по умолчанию запишется <strong>"default"</strong>.</li>
                           
                           <li>Если же аргументу <strong>PreferredType</strong> было передано указание на тип строки (<em>String</em>), тогда ему запишется <strong>"string"</strong>.</li>
                           
                           <li>В случае, когда аргументу <strong>PreferredType</strong> было передано указание на тип числа (<em>Number</em>), тогда он получит запись <strong>"number"</strong>.</li>
                           
                           <li>Когда вопрос с аргументом <strong>PreferredType</strong> решен, необходимо понять, с каким именно объектом алгоритм имеет дело: обычным или нет. <a href="https://www.ecma-international.org/ecma-262/#sec-built-in-exotic-object-internal-methods-and-slots">Необычные объекты</a> еще будут подробно рассматриваться. Если объект необычный, тогда алгоритм воспользуется операцией <strong>GetMethod(input, @@toPrimitive)</strong> (<em>exoticToPrim</em>), чтобы преобразовать его в примитивный тип. Сама по себе операция <strong>GetMethod (V, P)</strong> используется для получения значения свойства <strong>P</strong> объекта <strong>V</strong>. При этом данное значение ожидаемое как функция. И если оно не функция, тогда вылетит <strong>TypeError</strong>. В контексте этого алгоритма для операции <strong>GetMethod(input, @@toPrimitive)</strong> в итоге будет выполнено извлечение значения свойства (метода) с ключом <strong>@@toPrimitive</strong> целевого объекта <strong>input</strong>: <strong>input.[[Get]](@@toPrimitive, input)</strong>. Символ <strong>@@toPrimitive</strong> соответствует методу, который превращает объект в соответствующее примитивное значение (и вызывается он абстрактной операцией <strong><em>ToPrimitive</em></strong>). 
                           
                               <p>Итак, значением свойства <strong>@@toPrimitive</strong> есть функция, что превращает объект символа в примитивное значение. У этой функции есть имя - <strong>"Symbol.toPrimitive"</strong>. Она так же принимает в качетсве аргумента указание на тип преобразования (<em>hint</em>). И если извлеченным значением <strong>@@toPrimitive</strong> является не <strong>undefined</strong>, тогда будет выполнено еще несколько шагов:</p>
                               
                               <ol class="list" type="i">
                                   
                                   <li>Извлеченная функция метода <strong>@@toPrimitive</strong> (<em>exoticToPrim</em>) будет вызвана с помощью операции <strong> Call(exoticToPrim, input, "hint")</strong>. Эта операция используется для вызова извлеченной функции (<strong>exoticToPrim</strong>) в контексте выполнения объекта <strong>input</strong> с указанием на тип преобразования (<strong>"hint"</strong>) с помощью внутреннего метода <strong>[[Call]]</strong>. В итоге операция <strong>Call</strong> вернет: <strong>exoticToPrim.[[Call]](input, "hint")</strong>.</li>
                                   
                                   <li>Если полученный результат вызова извлеченной функции (<em>result</em>) выдержал проверку на не принадлежность к типу Object <span>&#8594;</span> <strong>Type(result)</strong> <span>&#8594;</span> тогда алгоритм вернет его,  окончив выполнение операции <strong><em>ToPrimitive</em></strong>.</li>
                                   
                                   <li>В противном случае вылетит птичка в виде <strong>TypeError</strong>.</li>
                                   
                               </ol>
                               
                            </li>
                            
                            <li>Если же объект обычный и в качестве указания аргумент <strong>PreferredType</strong> получил запись <strong>"default"</strong>, тогда это указание запишется к <strong>"number"</strong>. </li>
                            
                            <li>Когда объект является обычным, будет выполнена операция <a href="#ordinarytoprimitive"><strong>OrdinaryToPrimitive(input, hint)</strong></a>, что используется для преобразования обычных объектов в примитивное значение.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же проверка <strong>Type(input)</strong> выдает, что аргумент <strong>input</strong> не принадлежит к типу <em>Object</em>, тогда алгоритм вернет его.</li>
                   
               </ol>
               
               <p>Объекты типа <em>Date</em> и объекты символов (<em>Symbol</em>) единственные, которые переопределяют стандартное поведение операции <strong><em>ToPrimitive</em></strong>.</p>
               
               <p>Теперь не мешает разобрать, что представляет из себя абстрактная операция <strong>OrdinaryToPrimitive</strong>.</p>
               
               <article id="ordinarytoprimitive">
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive">OrdinaryToPrimitive ( O, hint )</a></h4>
                       
                   </header>
                   
                   <p>Эта операция используется для преобразования обычных объектов в примитивное значение. Алгоритм тут состоит из следующих шагов:</p>
                   
                   <ol class="list">
                      
                       <li>Для начала объявляется, что аргумент <strong>O</strong> это значение, которое имеет тип <em>Object</em> (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                       
                       <li>Аргумент <strong>hint</strong> является указанием для преобразования, который принимает в качестве значения строку либо <strong>"string"</strong>, либо <strong>"number"</strong> (<strong>Type(hint)</strong> <span>&#8594;</span> <em>String</em>).</li>
                       
                       <li>Если указанию <strong>hint</strong> было передано значение <strong>"string"</strong> для преобразования объекта <strong>O</strong> в строку, тогда алгоритм получит список из имен внутренних методов (<em>methodNames</em>), которые имеют такую последовательность: <strong>" 'toString', 'valueOf' "</strong>.</li>
                       
                       <li>Если же <strong>hint</strong> получил в качестве значения <strong>"number"</strong> для преобразования объекта <strong>O</strong> в число, тогда последовательность методов (<em>methodNames</em>) будет обратная: <strong>" 'valueOf', 'toString' "</strong>.</li>
                       
                       <li>Для каждого имени метода (<em>name</em>) за порядком списка (<em>methodNames</em>) будут выполнены такие шаги:
                       
                           <ol class="list" type="a">
                               
                               <li>Имя (<em>name</em>) используется как указатель на метод для выполнения операции <strong>Get(O, name)</strong> (<em>method</em>), которая извлекает значение данного метода, возвращая <strong>O.[[Get]](name, O)</strong>. Для объекта <strong>O</strong> эти методы достаются из глобального объекта через наследование, что реализовано цепочкой прототипов.</li>
                               
                               <li>Получив значение соответствующего метода, алгоритм выполнит проверку того, является ли оно функцией с внутренним методом вызова <strong>[[Call]]</strong> <span>&#8594;</span> <strong>IsCallable(method)</strong>. Если вернулось <strong>true</strong>, тогда:
                               
                                   <ol class="list" type="i">
                                       
                                       <li>Данный метод будет вызван для целевого объекта <strong>O</strong>. Этот вызов выполнит операция <strong>Call(method, O)</strong> (<em>result</em>), что вернет: <strong>method.[[Call]](O)</strong>.</li>
                                       
                                       <li>Если полученный результат (<em>result</em>) не относится к типу <em>Object</em> (тут будет выполнена проверка <span>&#8594;</span> <strong>Type(result)</strong>), тогда алгоритм вернет его. А если полученный результат все еще имеет тип <em>Object</em>, тогда запустится выполнение следующего метода (<em>name</em>) в списке (<em>methodNames</em>).</li>
                                       
                                   </ol>
                               
                               </li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если на предыдущем шаге в итоге случилась лажа, тогда вылетит <strong>TypeError</strong>.</li>
                       
                   </ol>
                   
                   <p>Итак, теперь важно понимать, какое значение имеет тут последовательность методов, когда алгоритм получил то, или иное указание для преобразования (<em>hint</em>). Когда указанию было передано значение <strong>"string"</strong>, сперва будет выполнен внутренний метод <strong>toString</strong>. Он возвращает строку формата <strong>"[object <em>tag</em>]"</strong>, где обозначением <em>tag</em> может быть: <strong>Undefined</strong>, <strong>Null</strong>, <strong>Array</strong>, <strong>String</strong>, <strong>Arguments</strong>, <strong>Function</strong>, <strong>Error</strong>, <strong>Boolean</strong>, <strong>Number</strong>, <strong>Date</strong>, <strong>RegExp</strong> и <strong>Object</strong>, - что зависит от особенностей объекта, к которому этот метод применяется. Вернув строку, очередь метода <strong>valueOf</strong> не наступит и алгоритм закончит свое выполнение.</p>
                   
                   <p>В случае, когда указанию (<em>hint</em>) было передано значение <strong>"number"</strong>, первым будет выполнен метод <strong>valueOf</strong>. Он возвращает операцию <strong>ToObject(O)</strong>, которая превращает в объект передаваемое ей в аргументе значение. Получив результат выполнения <strong>valueOf</strong> (<em>result</em>), алгоритм повторит цикл для метода <strong>toString</strong>, который будет применен к объекту, что произвел предыдущий метод. А он уже вернет соответствующую строку, которая и будет использоваться для дальнейшего преобразования в число.</p>
                   
               </article>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toboolean">ToBoolean ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в булевский тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в булевское значение <strong>ToBolean</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Если в аргументе дано <strong>+0</strong>, <strong>-0</strong> или <strong>NaN</strong>, тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Если в аргументе дано пустую строку (имеет нулевую длину), тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                </table>
               
           </section>
           
           <section id="tonumber">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber">ToNumber ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в числовой тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в числовое значение <strong>ToNumber</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>NaN</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>+0</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет 1; в случае, когда <strong>false</strong> - вернет 0.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber-applied-to-the-string-type">алгоритм преоразования</a>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint Number)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) будет значением для аргумента <strong>ToNumber</strong> <span>&#8594;</span> <strong>ToNumber(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Если аргументу было передано значение с типом <em>String</em>, что не может быть истолковано как числовой литерал, который дается в виде строки (<em>StringNumericLiteral</em>), тогда результатом выполнения операции <strong>ToNumber</strong> будет <strong>NaN</strong>. Итак, если строка, которую нужно преобразовать в число, имеет вид "трали-вали", тогда получим <strong>NaN</strong>. Если же строка является такой, что имеет вид десятичного, двоичного, восьмеричного или шестнадцатиричного числа, тогда она преобразуется в значение, что имеет тип <em>Number</em> ("123" <span>&#8594;</span> 123).</p>
                
                <p>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) имеет некоторые свои особенности, что отличают его от простого числового литерала (<em>NumericLiteral</em>):</p>
                
                <ul class="list">
                   
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя пробел, что начинает и/или завершает строку, и/или символы конца строки (т.е. " 123 " это норм и будет <span>&#8594;</span> 123).</li>
                    
                    <li>Десятичному числовому литералу в виде строки (<em>StringNumericLiteral</em>) может предшествовать любое количество нулей (т.е. "000000123" <span>&#8594;</span> 123, а это говорит о том, что нули являются незначительными).</li>
                    
                    <li>Десятичный числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя <strong>+ / -</strong>, чтобы указать свой знак (т.е. "-123" <span>&#8594;</span> -123).</li>
                    
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>), которая является пустой или имеет в себе только пробел, преобразовывется в <strong>+0</strong> (т.е. " " <span>&#8594;</span> 0).</li>
                    
                    <li>Значения <strong>Infinity</strong> и <strong>-Infinity</strong> распознаются как числовой литерал в виде строки (<em>StringNumericLiteral</em>), а не как просто числовой литерал (<em>NumericLiteral</em>), и преобразовываются в настолько огромедное число (10<sup>10000</sup>), что округляются к <strong>+&#8734;</strong> или <strong>-&#8734;</strong>.</li>
                    
                </ul>
                
                <p>Динамическая семантика преобразования того значения, что сидит в строке, к типу <em>Number</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-runtime-semantics-mv-s"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tostring">ToString ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в строку. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в строку <strong>ToString</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>"undefined"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>"null"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет <strong>"true"</strong>; в случае, когда <strong>false</strong> - вернет <strong>"false"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type">алгоритм преоразования</a> (вот, к примеру, <strong>NaN</strong> <span>&#8594;</span> <strong>"NaN"</strong>, <strong>+0 / -0</strong> <span>&#8594;</span> <strong>"0"</strong>, а <strong>+&#8734;</strong> <span>&#8594;</span> <strong>"Infinity"</strong>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) будет значением для аргумента операции <strong>ToString</strong> <span>&#8594;</span> <strong>ToString(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Динамическая семантика преобразования числа к типу <em>String</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section id="toobject">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toobject">ToObject ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) к типу <em>Object</em>. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в объект <strong>ToObject</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-boolean-objects">булевский объект</a>, чей внутренний слот <strong>[[BooleanData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-number-objects">числовой объект</a>, чей внутренний слот <strong>[[NumberData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-string-objects">строковый объект</a>, чей внутренний слот <strong>[[StringData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-symbol-objects">объект символа</a>, чей внутренний слот <strong>[[SymbolData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Возвращает свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                </table>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tointeger">ToInteger ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое числовое значение. Её алгоритм такой:</p>
               
               <ol class="list">
                  
                   <li>Сначала будет выполнена операция, что возвращает число - <a href="#tonumber"><strong>ToNumber(argument)</strong></a>.</li>
                   
                   <li>Если результат выполнения предыдущей операции (<em>number</em>) это <strong>NaN</strong>, тогда вернется ноль <strong>+0</strong>.</li>
                   
                   <li>Если результатом выполнения операции <a href="#tonumber"><strong>ToNumber(argument)</strong></a> (<em>number</em>) будет <strong>+0</strong>, <strong>-0</strong>, <strong>+&#8734;</strong> или <strong>-&#8734;</strong>, тогда он же (<em>number</em>) и вернется.</li>
                   
                   <li>В остальных случаях будет возвращатся число со своим знаком (<em>number</em>) и сводится к его абсолютному значению через выполнение <strong>floor(abs(number))</strong>. Разберем по порядку:
                   
                       <ol class="list" type="a">
                           
                           <li id="abs_number">Математическая функция <strong>abs(number)</strong> выдает абсолютное значение числа (<em>number</em>).</li>
                           
                           <li id="floor">Затем эта абсолютная величина округляется к наибольшему целому числу, которое при этом не больше входящего значения <strong>abs(number)</strong> - эту выдачу обеспечивает операция <strong>floor</strong> (т.е. 5.66666 тут будет <span>&#8594;</span> 5).</li>
                           
                       </ol>
                   
                   </li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-topropertykey">ToPropertyKey ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в то значение, которое может быть использовано в качестве ключа свойства. Алгоритм тут следующий:</p>
               
               <ol class="list">
                  
                  <li>Первое, что выполняется, это операция, которая сводит входящий аргумент (<em>argument</em>) к примитивному значению - <a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a>. Это полученное примитивное значение и будет ключом свойства (<em>key</em>).</li>
                  
                  <li>Если полученный ключ является символом (<strong>Type(key)</strong> <span>&#8594;</span> <em>Symbol</em>), тогда вернется этот символ как ключ свойства.</li>
                  
                  <li>В случае же, когда ключ свойства это не символ, тогда полученное примитивное значение, которое родилось на первом этапе (<em>key</em>), попадет в лапы операции, что трансформирует его и наверняка вернет строку - <a href="#tostring"><strong>ToString(key)</strong></a>. Она и будет ключом свойства. Вуа-ля.</li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tolength">ToLength ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое число, которое в дальнейшем используется как длина (число элементов) массивоподобного объекта. Алгоритм выполнения данной операции:</p>
               
               <ol class="list">
                  
                  <li>Для начала необходимо вернуть целое число (<em>len</em>), чем и займется операция <a href="#tointeger"><strong>ToInteger(argument)</strong></a>.</li>
                  
                  <li>Если полученный результат (<em>len</em>) меньше или равен нулю (<em>len</em> <span>&#8804;</span> <strong>+0</strong>), тогда вернется ноль <strong>+0</strong>.</li>
                  
                  <li>А если полученное число больше нуля, тогда оно и вернется. Вот только не так просто, а через функцию <strong>min(<em>len</em>, 2<sup>53</sup>-1)</strong>, которая возвращает наименьшее число в данном диапазоне. Диапазон тут дается потому, что длина массивоподобного объекта (<em>len</em>) не может быть больше 2<sup>53</sup>-1.</li>

               </ol>
               
           </section>
           
           <div>
              
               <p>Существует еще целый набор абстрактных операций, которые производят преобразование входящего значения. Кратко перечислим:</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toindex"><strong>ToIndex ( value )</strong></a> - эта операция возвращает корректное целое число для индекса.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-canonicalnumericindexstring"><strong>CanonicalNumericIndexString ( argument )</strong></a> - эта операция возвращает числовое значение, если оно является строковым представлением числа, произведенного операцией <a href="#tostring"><strong>ToString</strong></a>, или строкой <strong>"-0"</strong>. В ином случае вернет <strong>undefined</strong>.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint32"><strong>ToInt32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от -2<sup>31</sup> до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint32"><strong>ToUint32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от 0 до 2<sup>31</sup> - 1 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint16"><strong>ToInt16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от -32768 до 32767 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint16"><strong>ToUint16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от 0 до 2<sup>16</sup> - 1 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint8"><strong>ToInt8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от -128 до 127 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8"><strong>ToUint8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от 0 до 255 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8clamp"><strong>ToUint8Clamp ( argument )</strong></a> - то же определение, что и в предыдущей операции, только с измененным алгоритмом выполнения.</li>
                   
               </ul>
               
           </div>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-testing-and-comparison-operations">Операции тестирования и сравнения</a></h3>
               
           </header>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-requireobjectcoercible">RequireObjectCoercible ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция проверяет возможность преобразования значения аргумента (<em>argument</em>) в объект с помощью <a href="#toobject"><strong>ToObject</strong></a>. Если значение не поддатливое, тогда она вернет ошибку.</p>
               
               <table>

                    <caption>Результаты <strong>RequireObjectCoercible</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                </table>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isarray">IsArray ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли объект массивом (<em>Array</em>) или прокси-объектом (<em>Proxy</em>). Алгоритм проверки следующий:</p>
               
               <ol class="list">
                   
                   <li>Сначала проверяется тип значения в аргументе <span>&#8594;</span> <strong>Type(argument)</strong>. Если оно не принадлежит к типу <em>Object</em>, тогда вернется <strong>false</strong>.</li>
                   
                   <li>Если в аргументе массив (<em>Array</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если в аргументе прокси-объект (<em>Proxy</em>), тогда
                   
                   <ol class="list" type="a">
                       
                       <li>под прицел попадает значение внутреннего слота <strong>[[ProxyHandler]]</strong> аргумента (<em>argument</em>) <span>&#8594;</span> <strong>argument.[[ProxyHandler]]</strong>. Когда оно <strong>null</strong>, на выходе получим <strong>TypeError</strong>.</li>
                       
                       <li>А если не <strong>null</strong>, тогда аргументу будет передано значение <strong>argument.[[ProxyHandler]]</strong> (<em>target</em>).</li>
                       
                       <li>Итак, будет выполнено <strong>IsArray(target)</strong>.</li>
                       
                   </ol>
                   
                   
                   </li>
                   
                   <li>В остальных случаях, когда имеем какой-то другой объект, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="iscallable-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-iscallable">IsCallable ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) вызываемой функцией с внутренним методом <strong>[[Call]]</strong>. Алгоритм проверки такой:</p>
               
               <ol class="list">
                  
                   <li>В аргументе должен быть объект, иначе вернется <strong>false</strong> (выкупаем <span>&#8594;</span> <strong>Type(argument)</strong>).</li>
                   
                   <li>Если значение в аргументе имеет внутренний метод вызова <strong>[[Call]]</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>А если не имеет, тогда вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isconstructor">IsConstructor ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) функцией с внутренним методом <strong>[[Construct]]</strong>. Алгоритм проверки такой:</p>
               
               <ol class="list">
                  
                   <li>Если в аргументе не объект, тогда вернется <strong>false</strong> (выкупаем <span>&#8594;</span> <strong>Type(argument)</strong>).</li>
                   
                   <li>Если значение в аргументе имеет внутренний метод <strong>[[Construct]]</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>А если не имеет, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isextensible-o">IsExtensible ( O )</a></h4>
                   
               </header>
               
               <p>Эта операция используется для определения того, могут ли дополнительные свойства быть добавлены к объекту <em>O</em>. Выполняются такие шаги:</p>
               
               <ol class="list">
                  
                   <li>Проверка <strong>Type(O)</strong> <span>&#8594;</span> объект.</li>
                   
                   <li>Возвращает <strong>O.[[IsExtensible]]()</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isinteger">IsInteger ( argument )</a></h4>
                   
               </header>
               
               <p>Определяет, является ли значение в аргументе (<em>argument</em>) конечным целым числом. Алгоритм выполнения:</p>
               
               <ol class="list">
                   
                   <li>В аргументе должно быть значение числового типа <strong>Type(argument)</strong> <span>&#8594;</span> <strong>Number</strong>, или же вернется <strong>false</strong>.</li>
                   
                   <li>Если в аргументе <strong>NaN</strong>, <strong>+&#8734;</strong>, или <strong>-&#8734;</strong>, вернется <strong>false</strong>.</li>
                   
                   <li>Затем проверяется равенство <a href="#floor"><strong>floor(abs(argument))</strong></a> с <a href="#abs_number"><strong>abs(argument)</strong></a> <span>&#8594;</span> если они не равны другу другу (<span>&#8800;</span>), тогда вернется <strong>false</strong>.</li>
                   
                   <li>Дойдя до сюда, вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="ispropkey">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ispropertykey">IsPropertyKey ( argument )</a></h4>
                   
               </header>
               
               <p>Определяет, может ли значение в аргументе (<em>argument</em>) использоваться как ключ свойства. Алгоритм проверки:</p>
               
               <ol class="list">
                   
                   <li>Если <strong>Type(argument)</strong> <span>&#8594;</span> <strong>String</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(argument)</strong> <span>&#8594;</span> <strong>Symbol</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>В других случаях - <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isregexp">IsRegExp ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) регулярным выражением (<em>RegExp</em>). Алгоритм:</p>
               
               <ol class="list">
                  
                   <li>Если <strong>Type(argument)</strong> не <span>&#8594;</span> <strong>Object</strong>, тогда вернется <strong>false</strong>.</li>
                   
                   <li>Затем выполнится операция <strong>Get(argument, @@match)</strong> (<em>isRegExp</em>). Символ <strong>@@match</strong> соответствует методу, что подбирает строку под регулярное выраженние (вызывается методом <em>String.prototype.match</em>). Итак, к объекту в аргументе (<em>argument</em>) будет применен внутренний метод <strong>[[Get]]</strong>, чтобы извлечь значение свойства <strong>@@match</strong>.</li>
                   
                   <li>Если вернувшееся значение операции <strong>Get</strong> (<em>isRegExp</em>) не <strong>undefined</strong>, тогда будет выполнено <a href="#toboolean"><strong>ToBoolean(isRegExp)</strong></a>.</li>
                   
                   <li>Далее проверяется, имеет ли значение в аргументе (<em>argument</em>) внутренний слот <strong>[[RegExpMatcher]]</strong>. При его наличии вернется <strong>true</strong>.</li>
                   
                   <li>Если нет, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="samevalue">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevalue">SameValue ( x, y )</a></h4>
                   
               </header>
               
               <p>Эта операция сравнивает два значения, которые передаются ей в аргументе (<em>x</em> и <em>y</em>), и выдает булевский результат сравнения <strong>true / false</strong> в зависимости от того, являются ли они равны друг другу, или нет. Алгоритм сверки:</p>
               
               <ol class="list">
                   
                   <li>Если <strong>Type(x)</strong> выдал нечто иное от <strong>Type(y)</strong>, тогда <span>&#8594;</span> <strong>false</strong>.</li>
                   
                   <li>В случае, когда <strong>Type(x)</strong> возвращает <em>Number</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>если <strong>x</strong> это <strong>NaN</strong> и <strong>y</strong> тоже <strong>NaN</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>если <strong>x</strong> это <strong>+0</strong>, а <strong>y</strong> имеет <strong>-0</strong> (и наоборот), вернется <strong>false</strong>;</li>
                           
                           <li>если числовые значения <strong>x</strong> и <strong>y</strong> одинаковы, вернется <strong>true</strong>;</li>
                           
                           <li>в остальном будет <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же <strong>Type(x)</strong> это все, что угодно, кроме <em>Number</em>, тогда будет выполнена операция <a href="#samevaluenonnumber"><strong>SameValueNonNumber(x, y)</strong></a>.</li>
                   
               </ol>
               
               <div id="samevaluezero">
                  
                   <p>Существует еще операция <a href="https://www.ecma-international.org/ecma-262/#sec-samevaluezero"><strong>SameValueZero ( x, y )</strong></a>, которая повторяет алгоритм <strong>SameValue ( x, y )</strong>, вот только с тем отличием, что положительный и отрицательный ноль в ней равны друг другу. Т.е. если <strong>x</strong> это <strong>+0</strong>, а <strong>y</strong> - это <strong>-0</strong> (и наоборот), тогда вернется <strong>true</strong>.</p>
                   
               </div>
               
           </article>
           
           <article id="samevaluenonnumber">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevaluenonnumber">SameValueNonNumber ( x, y )</a></h4>
                   
               </header>
               
               <p>В этой операции сравниваемые значения (<em>x</em> и <em>y</em>) не принадлежат к типу <em>Number</em>. Алгоритм сравнения такой:</p>
               
               <ol class="list">
                   
                   <li><strong>Type(x)</strong> не вернет <em>Number</em>.</li>
                   
                   <li><strong>Type(x)</strong> имеет такой же тип, как и <strong>Type(y)</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Undefined</em>, вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Null</em>, вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>String</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда <strong>x</strong> и <strong>y</strong> это одинаковая последовательность кодовых единиц (имеют одинаковую длину и одинаковые кодовые единицы с соответствующими индексами), вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Boolean</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда оба <strong>x</strong> и <strong>y</strong> имеют одинаковое булевское значение <strong>true</strong> или <strong>false</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Symbol</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда оба <strong>x</strong> и <strong>y</strong> имеют одинаковое значение символа (<em>Symbol</em>), вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если <strong>x</strong> и <strong>y</strong> это один и тот же объект, вернется <strong>true</strong>; в ином случае вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="equality-comparison">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison">Равенство</a></h4>
                   
               </header>
               
               <p>Это сравнение имеет вид <em>x == y</em> и возвращает либо <strong>true</strong>, либо <strong>false</strong>, где <em>x</em> и <em>y</em> - сравниваемые значения. Алгоритм таков:</p>
               
               <ol class="list">
                  
                   <li>Если <em>x</em> и <em>y</em> имеют одинаковый тип (что проверит <strong>Type(x)</strong> и <strong>Type(y)</strong>), тогда вернется результат выполнения операции <a href="#strict-equality">строгого равенства</a>.</li>
                   
                   <li>Если <em>x</em> это <strong>null</strong>, а <em>y</em> - <strong>undefined</strong>, тогда вернется <strong>true</strong> (и если наоборот, то тоже вернется <strong>true</strong>).</li>
                   
                   <li>Если <em>x</em> имеет числовой тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Number</em>), а <em>y</em> - строковый (<strong>Type(y)</strong> <span>&#8594;</span> <em>String</em>), тогда вернется результат сравнения <strong>x == <a href="#tonumber">ToNumber(y)</a></strong>.</li>
                   
                   <li>Если же <em>x</em> имеет строковый тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>String</em>), а <em>y</em> - числовой (<strong>Type(y)</strong> <span>&#8594;</span> <em>Number</em>), тогда вернется результат сравнения <strong><a href="#tonumber">ToNumber(x)</a> == y</strong>.</li>
                   
                   <li>Если <em>x</em> имеет булевский тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда вернется результат сравнения <strong><a href="#tonumber">ToNumber(x)</a> == y</strong>.</li>
                   
                   <li>Если же <em>y</em> имеет булевский тип (<strong>Type(y)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда вернется результат сравнения <strong>x == <a href="#tonumber">ToNumber(y)</a></strong>.</li>
                   
                   <li>В случае, если значение <em>x</em> имеет строковый, числовой или символьный тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>String / Number / Symbol</em>), а <em>y</em> - объектный (<strong>Type(y)</strong> <span>&#8594;</span> <em>Object</em>), тогда вернется результат сравнения <strong>x == <a href="#toprimitive">ToPrimitive(y)</a></strong>.</li>
                   
                   <li>Если же значение <em>x</em> имеет объектный тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Object</em>), а <em>y</em> - строковый, числовой или символьный тип (<strong>Type(y)</strong> <span>&#8594;</span> <em>String / Number / Symbol</em>), тогда вернется результат сравнения <strong><a href="#toprimitive">ToPrimitive(x)</a> == y</strong>.</li>
                   
                   <li>В остальных случаях вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="strict-equality">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison">Строгое равенство</a></h4>
                   
               </header>
               
               <p>Это сравнение имеет вид <em>x === y</em> и возвращает либо <strong>true</strong>, либо <strong>false</strong>. Алгоритм имеет вид:</p>
               
               <ol class="list">
                   <li>Если сравниваемые значения <em>x</em> и <em>y</em> имеют разные типы (что выдаст <strong>Type(x)</strong> и <strong>Type(y)</strong>), тогда вернется <strong>false</strong>. Так что строгое сравнение применяется только "для своих" значений.</li>
                   
                   <li>Если <em>x</em> имеет числовой тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Number</em>), тогда 
                   
                       <ol class="list">
                           
                           <li>когда значение <em>x</em> это <strong>NaN</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>когда значение <em>y</em> это <strong>NaN</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>когда <em>x</em> и <em>y</em> это одинаковые числовые значения, вернется <strong>true</strong>.</li>
                           
                           <li>когда значение <em>x</em> это <strong>+0</strong>, а <em>y</em> - это <strong>-0</strong>, вернется <strong>true</strong> (и когда наоборот, тоже вернется <strong>true</strong>).</li>
                           
                           <li>в остальных случаях вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же мы имеем другие типы для значений <em>x</em> и <em>y</em>, тогда будет выполнена операция <a href="#samevaluenonnumber"><strong>SameValueNonNumber(x, y)</strong></a>.</li>
                   
               </ol>
               
               <p>Отличается от <a href="#samevalue"><strong>SameValue</strong></a> в обращении с нулями и <strong>NaN</strong>.</p>
               
           </article>
           
           <article id="relation_compare">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison">Относительное сравнение</a></h4>
                   
               </header>
               
               <p>Здесь, в общем, происходит сравнение одного значения с другим в плане "ху ис биггер": <em>x &#60; y</em> (или <em>x &#62; y</em>). Возвращается <strong>true</strong>, <strong>false</strong> или <strong>undefined</strong>. Эта операция дополнительно имеет булевский индикатор состояния <em>LeftFirst</em> в качестве параметра, который контролирует порядок выполнения операций над значениями <em>x</em> и <em>y</em>. В EcmaScript вычисление происходят слева направо и по дефолту <em>LeftFirst</em> принимает значение <strong>true</strong> (в этом случае сначала обработается тот параметр, что слева в выражении - <em>x</em>). Бывает и такое, что параметр <em>LeftFirst</em> имеет значение <strong>false</strong>, и в этом случае под внимание попадают сперва те параметры, что справа в выражении (т.е. сначала будет выполнен весь комплекс необходимых событий над параметром <em>y</em> и только потом над <em>x</em>). Алгоритм тут таков (и представлен он для выражения <em>x &#60; y</em>, так что обратный знак вернет другой результат):</p>
               
               <ol class="list">
                   
                   <li>Сначала смотрит, какое значение имеет <em>LeftFirst</em>. Если <strong>true</strong>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>первым под раздачу попадает параметр <em>x</em>, который будет приведен к примитивному значению <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(x, hint Number)</strong></a> (<em>px</em>);</li>
                           
                           <li>и только потом параметр <em>y</em>, который также преобразовывается в примитивное значение <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(y, hint Number)</strong></a> (<em>py</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>А если <strong>false</strong>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>первым обращенным в примитивное значение будет параметр <em>y</em> <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(y, hint Number)</strong></a> (<em>py</em>);</li>
                           
                           <li>затем параметр <em>x</em> <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(x, hint Number)</strong></a> (<em>px</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если случилось так, что полученные примитивные значения для <em>x</em> и <em>y</em> (<em>px</em> и <em>py</em> соответственно) строки (предполагается, что эти строки имеют уже нормализированную форму, дабы не вкатываться в дебри Юникода), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>если строка <em>y</em> (<em>py</em>) это приставка значения <em>x</em> (<em>px</em>), вернется <strong>false</strong>;</li>
                           
                           <li>если строка <em>x</em> (<em>px</em>) это приставка <em>y</em> (<em>py</em>), вернется <strong>true</strong>;</li>
                           
                           <li>если же ни одна из полученных строк не является приставкой для другой, значит, под прицел сравнения попадает символ строки, т.е. кодовая единица. Само значение этой кодовой единицы - целое число. И имеет данная кодовая единица наименьший не отрицательный индекс, который одинаковый в каждой из строк. Обязательное условие: под сравнение попадают только те кодовые единицы, что не равны друг другу. Так что, если символ с индексом 0 в кажой строке одинаковый, в оборот пойдет следующий символ с индексом 1 и тд. Поэтому, если целочисловое значение конкретной по индексу кодовой единицы в строке <em>x</em> (<em>px</em>) больше, или меньше, чем в строке <em>y</em> (<em>py</em>), тогда получим соответсвующий результат на выходе. Типа, вот кодовая единица строки <em>x</em> (<em>px</em>) - это <em>m</em>, а для строки <em>y</em> (<em>py</em>) - <em>n</em>. И, если действительно <em>m &#60; n</em>, тогда вернется <strong>true</strong> (в противном случае - <strong>false</strong>). К примеру, выражение <em>"ab" &#60; "az"</em> вернет <strong>true</strong>, поскольку символы <em>"а"</em> одинаковые и сравнение поднимется индексом выше, пока не найдет такие элементы строки, что не равны друг другу (как <em>"b"</em> и <em>"z"</em>). Если не найдет и обе строки одинаковые, будет <strong>false</strong>. И, кстати, операция сравнения заканчивается на первом попавшемся символе, что не равен другому. Т.е. выражение <em>"abz" &#60; "az"</em> вернет <strong>true</strong>, поскольку состыковка произошла с символами <em>"b"</em> и <em>"z"</em>, и <em>"z"</em> победил.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li> Если же полученные примитивные значения для <em>x</em> и <em>y</em> не строки, тогда
                       
                       <ol class="list" type="a">
                          
                           <li> примитивное значение для <em>x</em> (<em>px</em>) будет преобразовано в число <span>&#8594;</span> <a href="#tonumber"><strong>ToNumber(px)</strong></a> (<em>nx</em>);</li>
                           
                           <li>и примитивное значение <em>y</em> (<em>py</em>) тоже <span>&#8594;</span> <a href="#tonumber"><strong>ToNumber(py)</strong></a> (<em>ny</em>);</li>
                           
                           <li>если число <em>x</em> (<em>nx</em>) это <strong>NaN</strong>, вернется <strong>undefined</strong> (то же самое и для числа <em>y</em> (<em>ny</em>), если оно <strong>NaN</strong>);</li>
                           
                           <li>если числовое значение <em>x</em> (<em>nx</em>) такое же, как и <em>y</em> (<em>ny</em>), вернется <strong>false</strong>; </li>
                           
                           <li>если значение <em>x</em> (<em>nx</em>) это <strong>+0</strong>, а <em>y</em> (<em>ny</em>) - это <strong>-0</strong>, вернется <strong>false</strong> (и, если махнуть нули наоборот, тоже <strong>false</strong>);</li>
                           
                           <li>если значение <em>x</em> (<em>nx</em>) это <strong>+&#8734;</strong>, вернется <strong>false</strong>; а если <em>y</em> (<em>ny</em>) - это <strong>+&#8734;</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>если же значение <em>x</em> (<em>nx</em>) это <strong>-&#8734;</strong>, вернется <strong>true</strong>; а если <em>y</em> (<em>ny</em>) - это <strong>-&#8734;</strong>, вернется <strong>false</strong>;</li>
                           
                           <li>и если математическое значение <em>x</em> (<em>nx</em>) меньше <em>y</em> (<em>ny</em>) - они оба конечные и не нули, - вернется <strong>true</strong>. В противном случае - <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
               </ol>
               
           </article>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-operations-on-objects">Операции над объектами</a></h3>
               
           </header>
           
           <article id="get-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-get-o-p">Get ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы извлечь значение определенного свойства (<em>P</em>) объекта (<em>O</em>). И ключ свойства (<em>P</em>), и объект (<em>O</em>) передаются ей в качетсве аргументов. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>И ей всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get"><strong>[[Get]]</strong></a> <span>&#8594;</span> <strong>O.[[Get]](P, O)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="getv-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getv">GetV ( V, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы извлечь значение определенного свойства (<em>P</em>) значения EcmaScript (<em>V</em>). И если это значение EcmaScript не объект, тогда поиск свойства выполняется, используя объектную оболочку, что соответствует типу значения. Ключ свойства (<em>P</em>) и значение EcmaScript (<em>V</em>) передаются ей в качетсве аргументов. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Ей всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Чтобы выполнить поиск свойства, необходимо создать объектную оболочку (<em>O</em>) для значения (<em>V</em>) <span>&#8594;</span> <a href="#toobject"><strong>ToObject(V)</strong></a>.</li>
                   
                   <li>Дальше выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get"><strong>[[Get]]</strong></a> <span>&#8594;</span> <strong>O.[[Get]](P, V)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="set-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-o-p-v-throw">Set ( O, P, V, Throw )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы записать значение определенного свойства (<em>P</em>) объекта (<em>O</em>). И аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>), новое значение для свойства (<em>V</em>) и булевский флаг (<em>Throw</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>И флагу (<em>Throw</em>) передается только булевское значение (<strong>Type(Throw)</strong> <span>&#8594;</span> <em>Boolean</em>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-set"><strong>[[Set]]</strong></a> <span>&#8594;</span> <strong>O.[[Set]](P, V, O)</strong> (<em>succes</em>).</li>
                   
                   <li>Если запись нового значение (<em>success</em>) не прошла успешно, вернув <strong>false</strong>, а булевский флаг получил значение <strong>true</strong>, тогда вылетит <strong>TypeError</strong> (этот булевский флаг получает соответствующие значения в зависимости от того, в каком режиме выполняется код: если в строгом, тогда он получит <strong>true</strong>, а если нет - <strong>false</strong>).</li>
                   
                   <li>В остальных случаях вернется результат выполнения записи (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="create_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdataproperty">CreateDataProperty ( O, P, V )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Создается описание нового свойства (<em>newDesc</em>), поля которого получают такие значения <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Затем выполняетмя внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>Эта абстрактная операция создает свойство, чьи атрибуты записываются к тем же значениям по умолчанию, что используются для свойств, которые создаются оператором назначения в EcmaScript. В нормальных условиях, такого свойста еще не существует. А если оно существует, и это существующее свойство не настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>) или объект не расширяемый (<strong><a href="#internal-isextensible">[[IsExtensible]]</a>: false</strong>), <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> вернет <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createmethodproperty">CreateMethodProperty ( O, P, V )</a></h4>
                   
               </header>
            
               <p>Очень похоже на <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a>, только есть ньюансы. Эта операция тоже используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Важный момент: значением свойства (<em>V</em>) является функция. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Создается описание нового свойства (<em>newDesc</em>), поля которого получают такие значения <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: false, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Затем выполняетмя внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>Эта абстрактная операция создает метод, чьи атрибуты записывются к тем же значениям по умолчанию, которые используются для встроенных методов и методов, определенных с помощью синтаксиса классов. В нормальных условиях, такого метода еще не существует. А если он существует, и этот существующий метод не настраиваемый (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>) или объект не расширяемый (<strong><a href="#internal-isextensible">[[IsExtensible]]</a>: false</strong>), <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> вернет <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow ( O, P, V )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Она выкидывает <strong>TypeError</strong>, если создание нового свойства не может быть выполнено. Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется <a href="#create_prop-abstr"><strong>CreateDataProperty ( O, P, V )</strong></a> (<em>success</em>).</li>
                   
                   <li>Если <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит недовольный <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="define_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-definepropertyorthrow">DefinePropertyOrThrow ( O, P, desc )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы вызвать внутренний метод (<em>P</em>) объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> таким способом, что выкинет <strong>TypeError</strong>, если свойство нельзя обновить. Аргументы здесь это: целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и описание свойства (<em>desc</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, desc)</strong> (<em>success</em>).</li>
                   
                   <li>Если <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="delete_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-deletepropertyorthrow">DeletePropertyOrThrow ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы убрать определенное собственное свойство (<em>P</em>) объекта (<em>O</em>). Выкинет <strong>TypeError</strong>, если свойство не настраиваемое (<a href="#config_attr">[[Configurable]]</a>: false). В качестве аргументов тут целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-delete"><strong>[[Delete]]</strong></a> <span>&#8594;</span> <strong>O.[[Delete]](P)</strong> (<em>success</em>).</li>
                   
                   <li>Если <a href="#internal-delete"><strong>[[Delete]]</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#internal-delete"><strong>[[Delete]]</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="get_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getmethod">GetMethod ( V, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы получить значение, ожидаемое как функция, определенного свойства (<em>P</em>) значения EcmaScript (<em>V</em>). Для значения EcmaScript используется объектная оболочка для определенного типа значения. Вызывается она с такими аргументами, как значение EcmaScript (<em>V</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется операция <a href="#getv-abstr"><strong>GetV(V, P)</strong></a> (<em>func</em>).</li>
                   
                   <li>Если полученный результат <a href="#getv-abstr"><strong>GetV</strong></a> (<em>func</em>) это либо <strong>undefined</strong>, либо <strong>null</strong>, тогда вернется <strong>undefined</strong>.</li>
                   
                   <li>Затем проверяется, имеет ли то значение, которое вернула операция <a href="#getv-abstr"><strong>GetV</strong></a>, внутренний метод  вызова <a href="#internal-call"><strong>[[Call]]</strong></a> <span>&#8594;</span> <a href="#iscallable-abstr"><strong>IsCallable(func)</strong></a>. Если <a href="#iscallable-abstr"><strong>IsCallable</strong></a> вернула <strong>false</strong>, вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#getv-abstr"><strong>GetV</strong></a> (<em>func</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasproperty">HasProperty ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, имеет ли объект (<em>O</em>) свойство (<em>P</em>) с определенным ключом. Свойство может быть как собственным, так и унаследованным. Вызывается она с такими аргументами, как целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-has_prop"><strong>[[HasProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[HasProperty]](P)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop_o-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasownproperty">HasOwnProperty ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, имеет ли объект (<em>O</em>) собственное свойство (<em>P</em>) с определенным ключом. Вызывается она с такими аргументами, как целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[GetOwnProperty]](P)</strong> (<em>desc</em>).</li>
                   
                   <li>Если <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> вернет <strong>undefined</strong>, на выходе получим <strong>false</strong>.</li>
                   
                   <li>В ином случае - <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="call-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-call">Call ( F, V [ , argumentsList ] )</a></h4>
                   
               </header>
               
               <p>Эта операция вызывает внутренний метод объекта функции (<em>F</em>) <a href="#internal-call"><strong>[[Call]]</strong></a>. Вызывается с аргументами, среди которых объект функции (<em>F</em>), значение EcmaScript (<em>V</em>), которое является <strong>this</strong> для внутреннего метода <a href="#internal-call"><strong>[[Call]]</strong></a>, и список (<em>argumentsList</em>) из аргументов функции (<em>F</em>), что является необязательным. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если список (<em>argumentsList</em>) из аргументов функции (<em>F</em>) не был передан, поскольку их нет, тогда новый пустой список (<em>List</em>) будет записан и использоваться как значение (<em>argumentsList</em>) для соответствующего аргумента внутреннего метода <a href="#internal-call"><strong>[[Call]]</strong></a>.</li>
                   
                   <li>Если объект функции (<em>F</em>) не вызываемый (<a href="#iscallable-abstr"><strong>IsCallable(F)</strong></a> <span>&#8594;</span> <strong>false</strong>), вылетит <strong>TypeError</strong>.</li>
                   
                   <li>Когда все норм, выполняется внутренний метод объекта функции (<em>F</em>) <a href="#internal-call"><strong>[[Call]]</strong></a> <span>&#8594;</span> <strong>F.[[Call]](V, argumentsList)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="constr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-construct">Construct ( F [ , argumentsList [ , newTarget ]] )</a></h4>
                   
               </header>
               
               <p>Эта операция вызывает внутренний метод объекта функции (<em>F</em>) <a href="#internal-constr"><strong>[[Construct]]</strong></a>. Вызывается с аргументами, среди которых объект функции (<em>F</em>), список из аргументов функции (<em>F</em>) и целевой объект, к которому применяется оператор <strong>new</strong> (<em>newTarget</em>). Последние два аргумента для метода <a href="#internal-constr"><strong>[[Construct]]</strong></a> не являются обязательными. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если целевой объект (<em>newTarget</em>) не был передан, тогда объект функции (<em>F</em>) записывается как целевой (<em>newTarget</em>) и используется как значение для соответствующего аргумента внутреннего метода <a href="#internal-construct"><strong>[[Construct]]</strong></a>.</li>
                   
                   <li>Если список (<em>argumentsList</em>) из аргументов функции (<em>F</em>) не был передан, поскольку их нет, тогда новый пустой список (<em>List</em>) будет записан и использоваться как значение (<em>argumentsList</em>) для соответствующего аргумента внутреннего метода <a href="#internal-construct"><strong>[[Construct]]</strong></a>.</li>
                   
                   <li>Объект функции имеет внутренний метод <a href="#internal-construct"><strong>[[Construct]]</strong></a> (<a href="#isconstr-abstr"><strong>IsConstructor(F)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Целевой объект функции тоже имеет внутренний метод <a href="#internal-construct"><strong>[[Construct]]</strong></a> (<a href="#isconstr-abstr"><strong>IsConstructor(newTarget)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта функции (<em>F</em>) <a href="#internal-construct"><strong>[[Construct]]</strong></a> <span>&#8594;</span> <strong>F.[[Construct]](argumentsList, newTarget).</strong>.</li>
                   
               </ol>
               
           </article>
           
       </section>
       
   </section>
    
</body>
</html>