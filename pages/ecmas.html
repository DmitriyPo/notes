<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ECMAScript</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  
    <header class="header">
        
        <h1>ECMAScript 2017</h1>
        
    </header>
    
    <p>Вот ссыль на <a href="https://www.ecma-international.org/ecma-262/">спецификацию</a> (самая свеженькая на даный момент - 8-ое издание), которую я рассмотрю здесь. Начнем с краткого обзора того, что такое ECMAScript (он же JavaScript).</p>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-overview">Краткий обзор</a></h2>
           
        </header>
           
        <p>ECMAScript это объектно-ориентированный язык программирования. <a href="https://www.ecma-international.org/ecma-262/#sec-web-scripting">Веб-браузер</a> предоставляет окружение для вычислений на стороне клиента (это объекты в виде окон, меню, диалоговых окон, фреймов, истории, куки, ввода/вывода, и другого разнообразия, а также способы для прикрепления кода к событиям мыши, отправки формы, загрузки страницы, ошибок, выбора и тд.). Веб-сервер предоставляет свое окружение для вычислений (а это объекты в виде запросов, клиентов, файлов, а также механизмы блокировки и обмена данными). Совместное выполнение скриптов на стороне браузера (клиента) и сервера  дает возможность распределить вычисление, предоставляя индивидуальный пользовательский интерфейс для веб-приложений. Каждый браузер и сервер вместе завершают окружение выполнения ECMAScript.</p>

        <div>

            <p>Перед тем, как дальше углубиться в дебри языка, рассмотрим в сжатом виде ECMAScript. Программа ECMAScript это набор взаимодействующих объектов. Объект это собрание свойств, у которых есть атрибуты. Свойства же в свою очередь это контейнеры для других объектов, примитивных значений, или функций. Примитивным есть значение, что представляет один из следующих типов ECMAScript: <em>Undefined</em> (неопределенное), <em>Null</em> (значение для нихуя), <em>Boolean</em> (булевское значение true/false), <em>Number</em> (число), <em>String</em> (строка), и <em>Symbol</em> (символ). Объект это представитель типа <em>Object</em>, а функция - это вызываемый объект.</p>

            <p>Набор ECMAScript объектов включает в себя: глобальный объект; основные объекты для динамической семантики (формальной модели) языка (<em>Object, Function, Boolean, Symbol, и Error</em>); объекты, что представляют и манипулируют числовыми значениями (<em>Math, Number, и Date</em>); объекты, обрабатывающие текст (<em>String и RegExp</em>); объекты, что являются пронумерованными наборами значений (<em>Array</em> и другие его виды); ключевые наборы (<em>Map и Set</em>); объекты, что предоставляют структурированные данные (<em>JSON, ArrayBuffer, SharedArrayBuffer, и DataView</em>); объекты, что поддерживают абстрактные понятия управления (<em>функции-генераторы и Promise</em>); отражающие объекты (<em>Proxy и Reflect</em>).</p>

            <p>Еще ECMAScript определяет набор операторов, среди которых унарные, запятые, логические, назначения, равенства, относительные и тд. Также большие програмы ECMAScript поддерживают модульность, что позволяет разделить программу на множество последовательностей из конструкций и объявлений. И хоть синтаксис языка лайтовый (нет, например, строгой типизации), при этом в нем существует возможность использовать строгий режим.</p>

            <article>

               <header class="header">

                   <h3><a href="https://www.ecma-international.org/ecma-262/#sec-strict-variant-of-ecmascript">Строгий вариант ECMAScript</a></h3>

               </header>

               <p>ECMAScript определяет строгий вариант языка. Он исключает некоторые определенные синтаксические и семантические свойства обычного ECMAScript и меняет детализированную семантику некоторых его свойств. Строгий вариант также определяет дополнительные условия для ошибок, которые не являются таковыми в не строгой форме языка.</p>

               <p>Строгий вариант языка обычно указывается как строгий режим (<em>strict mode</em>). Строгий режим налагает ограничения, что имеют только локальный эфект внутри синтаксической единицы ECMAScript. Программа может состоять из синтаксических единиц ECMAScript, что написаны в строгом и не строгом режиме.</p>

            </article>

        </div>
              
   </section>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-data-types-and-values">Типы данных и значений в ECMAScript</a></h2>
           
       </header>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types">Типы языка ECMAScript</a></h3>
               
           </header>
           
           <p>Типы языка есть следующие: <em>Undefined (неопределенный), Null (нулевой), Boolean (для булевских значений), String (для значений в виде строки), Symbol (для символов), Number (для числовый значений), и Object (для объектов)</em>. Кратко рассмотрим каждый тип.</p>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-undefined-type">Неопределенный тип (Undefined)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>undefined</strong>. Каждая переменная, которой не было назначено какое-либо значение, будет иметь <em>undefined</em> вместо него.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-null-type">Нулевой тип (Null)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>null</strong> (т.е. пустое значение).</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-boolean-type">Булев тип (Boolean)</a></h4>

               </header>
               
               <p>Булев тип служит для представления логической сущности, что имеет два значения: <strong>true</strong> и <strong>false</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-string-type">Строковый тип (String)</a></h4>

               </header>
               
               <p>Данный тип в основном используется для представления текстовой информации в программе ECMAScript, и в этом случае каждый элемент обрабатывается как значение единицы кода UTF-16 (UTF-16 это кодировка символов Юникода). Элемент занимает конкретную позицию внутри строки, что является последовательностью элементов. Эти позиции индексируются не отрицательными целыми числами, начиная с нуля: первый элемент будет иметь индекс 0, второй - 1, и тд. Длина строки это общее число элементов, из которых она состоит (пустая строка имеет длину 0).</p>
               
               <p>Операции ECMAScript, интерпретирующие строковые значения, рассматривают каждый элемент как отдельную кодовую точку UTF-16. ECMAScript не накладывает никаких ограничений или требований на последовательность кодовых точек в строке. Операции, что не интерпретируют контент строки, обрабатывают ее, как универсальную нерасчлененную 16-битную целочисленную переменную без знака.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-symbol-type">Тип для символов (Symbol)</a></h4>

               </header>
               
               <p>Этот тип является набором значений, что могут быть использованы, как ключи свойств объекта. Каждое возможное значение этого типа уникальное и неизменное.</p>
               
               <p>Известные символы, чьи значения расширяют возможности EcmaScript, наводятся в этой <a href="#symbol_table">таблице</a>:</p>
               
               <table id="symbol_table">
                   <caption>Широко-используемые символы</caption>
                   <tr>
                       <th>Сокращенное имя для спецификации</th>
                       <th>Описание ([[Description]])</th>
                       <th>Значение и для чего используется</th>
                   </tr>
                   <tr id="symb_instanse">
                       <td><em>@@hasInstance</em></td>
                       <td><strong>"Symbol.hasInstance"</strong></td>
                       <td>Метод, что определяет, является ли объект экземпляром конструктора. Вызывается семантикой оператора <strong>instanceof</strong>.</td>
                   </tr>
                   <tr id="symb_conc_spread">
                       <td><em>@@isConcatSpreadable</em></td>
                       <td><strong>"Symbol.isConcatSpreadable"</strong></td>
                       <td>Свойство с булевским значением. Если <strong>true</strong>, определяет, что объект должен быть упорядочен методом <strong>Array.prototype.concat</strong> к элементам массива.</td>
                   </tr>
                   <tr id="symb_iterator">
                       <td><em>@@iterator</em></td>
                       <td><strong>"Symbol.iterator"</strong></td>
                       <td>Метод, что возвращает дэфолтный итератор для объекта. Вызывается семантикой выражения <strong>for-of</strong>.</td>
                   </tr>
                   <tr id="symb_match">
                       <td><em>@@match</em></td>
                       <td><strong>"Symbol.match"</strong></td>
                       <td>Метод, что сопоставляет регулярное выражение со строкой. Вызывается методом <strong>String.prototype.match</strong>.</td>
                   </tr>
                   <tr id="symb_replace">
                       <td><em>@@replace</em></td>
                       <td><strong>"Symbol.replace"</strong></td>
                       <td>Метод, что заменяет совпадающие подстроки строки. Вызывается методом <strong>String.prototype.replace</strong>.</td>
                   </tr>
                   <tr id="symb_search">
                       <td><em>@@search</em></td>
                       <td><strong>"Symbol.search"</strong></td>
                       <td>Метод, что возвращает индекс в строке, который соответствует регулярному выражению. Вызывается методом <strong>String.prototype.search</strong>.</td>
                   </tr>
                   <tr id="symb_species">
                       <td><em>@@species</em></td>
                       <td><strong>"Symbol.species"</strong></td>
                       <td>Свойство, значением которого является функция-конструктор, что используется для создания производных объектов.</td>
                   </tr>
                   <tr id="symb_split">
                       <td><em>@@split</em></td>
                       <td><strong>"Symbol.split"</strong></td>
                       <td>Метод, что разделяет строку по индексам, которые соответствуют регулярному выражению. Вызывается методом <strong>  String.prototype.split</strong>.</td>
                   </tr>
                   <tr id="symb_toprim">
                       <td><em>@@toPrimitive</em></td>
                       <td><strong>"Symbol.toPrimitive"</strong></td>
                       <td>Метод, что преобразовывает объект в соответствующее примитивное значение. Вызывается асбтрактной операцией <a href="#toprim-abstr"><strong>ToPrimitive</strong></a></td>
                   </tr>
                   <tr id="symb_tostring">
                       <td><em>@@toStringTag</em></td>
                       <td><strong>"Symbol.toStringTag"</strong></td>
                       <td>Свойство со строковым значением, что используется в создании дефолтного строкового описания объекта. Доступ к нему осуществляется через метод <strong>Object.prototype.toString</strong>.</td>
                   </tr>
                   <tr id="symb_unscop">
                       <td><em>@@unscopables</em></td>
                       <td><strong>"Symbol.unscopables"</strong></td>
                       <td>Свойство, значением которого есть объект, чьи собственные и унаследованные имена свойств это те, которые исключены из привязок <strong>with</strong> окружения связанного объекта.</td>
                   </tr>
                   
               </table>
               
           </article>
           
           <article>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-number-type">Числовой тип (Number)</a></h4>

                </header>

                <p>Данный тип представляет 64-битные значения формата IEEE 754-2008, и их количество составляет дохера (2<sup>64</sup>-2<sup>53</sup>+3). Среди них есть особенные. Первым особенным значением есть <strong>NaN</strong> (“Not-a-Number”, которое производится программным выражением <strong>NaN</strong>). В коде ECMAScript <em>NaN</em> значения не отличимы друг от друга, при этом некоторые операции позволяют обнаружить разницу между <em>NaN</em> значениями (разные <em>NaN</em> значения не равны друг другу).</p>

                <p>Еще одними особенными значениями есть позитивная и отрицательная беснонечности, которые изображают с помощью символов <strong>+&#8734;</strong> и <strong>-&#8734;</strong> (оба они производятся программными выражениями <strong>+Infinity</strong> (или просто <strong>Infinity</strong>) и <strong>-Infinity</strong>).</p>

                <p>Остальные значения являются конечными, и половина из них это позитивные значения, а другая - отрицательные. Для каждого конечного числового значения существует соответствющее ему отрицательное по модулю.</p>

                <p>Также в ECMAScript не один ноль, а два: позитивный и отрицательный. Выражаются они символами <strong>+0</strong> и <strong>-0</strong> (производятся они программными выражениями <strong>+0</strong> (или просто <strong>0</strong>) и <strong>-0</strong> соответственно).</p>
                
                <p>Все положительные и отрицательные целые числа, величина которых по модулю не превышает 2<sup>53</sup>, представлены в типе чисел.</p>
               
           </article>
           
            <section>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-type">Объектный тип (Object)</a></h4>

                </header>

                <p>Объект это собрание свойств. Есть свойства данных и свойства доступа:</p>
                
                <ul class="list">
                    
                    <li><em>свойство данных</em> связывает свой ключ со значением ECMAScript и набором соответствующих атрибутов;</li>
                    
                    <li><em>свойство доступа</em> связывает свой ключ с функциями доступа и набором соответствующих атрибутов. Функция доступа используется для хранения или извлечения значения ECMAScript, которое связано со свойством.</li>
                    
                </ul>
                
                <p>Свойства идентифицируются, используя ключ значений. Ключом свойства есть либо строка, либо символ ECMAScript. Все строки и символы, включая пустую строку, это корректные ключи свойств. Ключ, что выражает имя свойства, является строкой. Еще в качетсве ключей именованных свойств используются целочисленные индексы строкового типа, чьи числовые значения находятся в диапазоне от +0 до 2<sup>53</sup>-1 включительно. В массивах индексы имеют значения в диапазоне +0 <span>&#8804;</span> <em>i</em> <span>&#60;</span> 2<sup>32</sup>-1.</p>
                
                <p>Ключи используются, чтобы получить доступ к свойствам и их значениям. Существует два вида доступа к значениям свойств: получение и запись, что соответствует либо операции извлечения значения, либо операции его назначения. Свойства, к которым существует подобный доступ, могут быть собственными или унаследованными от другого объекта.</p>
                
                <p>Есть несколько форм объектов, что отличаются в своей семантике доступа к свойствам и их управлением. Есть обычные объекты и необычные, чья семантика свойств отличается от той, что предоставлена обычным объектам по умолчанию (массивы, например). Теперь рассмотрим объекты подробнее.</p>
                
                <article>
                    
                    <header class="header header--center">
                        
                        <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-attributes">Атрибуты свойства</a></h4>
                        
                    </header>
                    
                    <p>Атрибуты используются, чтобы определить и объяснить состояние свойств объекта. Свойство данных связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-2">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств данных</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="value_attr">
                           
                            <td>[[Value]] (значение)</td>
                            
                            <td>Любой тип ECMAScript</td>
                            
                            <td>Значение свойства, что извлекается при получении к нему доступа.</td>
                            
                        </tr>
                        
                        <tr id="write_attr">
                           
                            <td>[[Writable]] (записываемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, возможно ли записать новое значение атрибута свойства <a href="#value_attr"><strong>[[Value]]</strong></a>. Если значением этого атрибута является <strong>false</strong>, тогда изменить значение атрибута <a href="#value_attr"><strong>[[Value]]</strong></a>, используя внутренний метод объекта <a href="#internal-set"><strong>[[Set]]</strong></a>, не получится.</td>
                            
                        </tr>
                        
                        <tr id="enum_attr">
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, будет ли свойство объекта перечислено при применении цыкла. Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В ином случае, свойство является не перечислимым (т.е. циклы при перечислении свойств его пропустят).</td>
                            
                        </tr>
                        
                        <tr id="config_attr">
                           
                            <td>[[Configurable]] (изменяемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, является ли свойтсво изменяемым. Если значением этого атрибута является <strong>false</strong>, тогда удалить, или изменить свойство, чтобы оно стало свойством доступа, или изменить его атрибуты (кроме как <a href="#value_attr"><strong>[[Value]]</strong></a>, или меняя <a href="#write_attr"><strong>[[Writable]]</strong></a> на <strong>false</strong>) нельзя.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Свойство доступа связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-3">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств доступа</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="get_attr">
                           
                            <td>[[Get]] (получение)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). Данный атрибут вызывает внутренний метод вызова функции <a href="#intarnal-call"><strong></strong>[[Call]]</a> с пустым списком аргументов (<em>List</em>), чтобы извлечь значение свойства, каждый раз при использовании доступа получения к свойству.</td>
                            
                        </tr>
                        
                        <tr id="set_attr">
                           
                            <td>[[Set]] (запись)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). Данный атрибут вызывает внутренний метод вызова функции <a href="#intarnal-call"><strong></strong>[[Call]]</a> со списком аргументов, что содержит присваиваемое значение, каждый раз при использовании доступа записи к свойству.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В другом случае, свойство не перечислимое.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Configurable]] (изменяемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>false</strong>, тогда удалить свойство, изменить его, чтобы оно стало свойством данных, или изменить его атрибуты, нельзя.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Значения по умолчанию для атрибутов свойств следующие:</p>
                    
                    <table>
                        
                        <caption>Значения атрибутов по умолчанию</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Значение по умолчанию</th>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Записываемый ([[Writable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Перечислимый ([[Enumerable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Изменяемый ([[Configurable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Значение ([[Value]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Получение ([[Get]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Запись ([[Set]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                    </table>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4><a href="https://www.ecma-international.org/ecma-262/#sec-object-internal-methods-and-internal-slots">Внутренние</a> методы объектов и слоты (ячейки)</h4>
                        
                    </header>
                    
                    <p>Внутренние методы это алгоритмы, что определяют поведение объектов во время выполнения. Имена внутренних методов полиморфные, а это означает, что выполняются разные сценарии алгоритма при вызове такого метода, если объект имеет для него разные значения. Если вызывается внутренний метод, который не поддерживается объектом, тогда программа выкинет ошибку <strong>TypeError</strong>. Внутренний метод возвращает запись завершения и всегда имеет доступ к целевому объекту.</p>
                    
                    <p>Внутренние слоты соответствуют внутреннему состоянию, которое связано с объектами, и используются различными алгоритмами ECMAScript. Эти слоты не наследуются и являются частью создания объекта, при этом они не могут быть добавлены динамически. Внутреннее состояние может состоять из значений любого типа ECMAScript. Начальное значение внутреннего слота это <strong>undefined</strong>. ECMAScript не предоставляет прямого пути, чтобы связать внутренние слоты с объектом.</p>
                    
                    <p><a href="https://www.ecma-international.org/ecma-262/#table-5">Таблица</a> ниже обобщает важные внутренние методы, которые применимы ко всем объектам, что были созданы с помощью кода ECMAScript:</p>
                    
                    <table>
                        
                        <caption>Важные внутренние методы</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-get_proto">
                           
                            <td>[[GetPrototypeOf]]</td>
                            
                            <td>() <span>&#8594;</span> Object | Null</td>
                            
                            <td>Этот метод определяет тот объект, который предоставляет наследуемые свойства (иными словами, с его помощью определяется прототип). Значение <strong>null</strong> указывает на то, что нет никаких наследуемых свойств (это значение у того объекта, который не имеет прототипов в своей цепочке, и поэтому он в ней первый). Цепь прототипов имеет конечную длину при том условии, если в ней не встречаются необычные объекты, которые не используют обыкновенное определение этого метода, ведь тогда это может призвести к бесконечному цыклу при попытке получить доступ к свойствам объекта-прототипа.</td>
                            
                        </tr>
                        
                        <tr id="internal-set_proto">
                           
                            <td>[[SetPrototypeOf]]</td>
                             
                            <td>(Object | Null) <span>&#8594;</span> Boolean</td>
                            
                            <td>Связывает свой объект с другим объектом, который предоставляет наследуемые свойства (записывает объекту прототип). Если в аргументе <strong>null</strong>, это указывает на то, что нет никаких наследуемых свойств. Если возвращаемое значение <strong>true</strong>, это указывает на успешное присвоение объекту прототипа, а если <strong>false</strong> - успех не состоялся.</td>
                            
                        </tr>
                        
                        <tr id="internal-isextensible">
                           
                            <td>[[IsExtensible]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Определяет, разрешается ли добавить дополнительные свойства объекту.</td>
                            
                        </tr>
                        
                        <tr id="internal-prev_exts">
                           
                            <td>[[PreventExtensions]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Контролирует могут ли новые свойства быть добавлены объекту. Если операция по превращению объекта в нерасширяемый прошла успешно, тогда этот метод вернет <strong>true</strong> (после этого дополнительные свойства не смогут быть добавлены объекту и  метод <a href="#internal-isextensible"><strong>[[IsExtensible]]</strong></a> вернет <strong>false</strong>), в противном случае - <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-get_prop_o">
                           
                            <td>[[GetOwnProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Undefined | Property Descriptor</td>
                            
                            <td>Возвращает описание (<em>Property Descriptor</em>) собственного свойства (<em>propertyKey</em>) объекта, если оно существует. А если возвращает <strong>undefined</strong>, тогда такого свойства в этом объекте нет.</td>
                            
                        </tr>
                        
                        <tr id="internal-define_prop_o">
                           
                            <td>[[DefineOwnProperty]]</td>
                             
                            <td>(<em>propertyKey, Property Descriptor</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Создает или меняет свобственное свойство (<em>propertyKey</em>), чтобы оно имело определенное описание (Property Descriptor). Возвращает <strong>true</strong>, если свойство было создано/обновлено. В противном случае - <strong>false</strong>, если существует одно из следующих состояний: свойство не изменяемое (<a href="#config_attr"><strong>[[Configurable]]</strong></a>: <strong>false</strong>), объект не расширяемый (<a href="#internal-isextensible"><strong>[[IsExtensible]]</strong></a> <span>&#8594;</span> <strong>false</strong>) или свойства не существует (<a href="#internal-has_prop"><strong>[[HasProperty]]</strong></a> <span>&#8594;</span> <strong>false</strong>).</td>
                            
                        </tr>
                        
                        <tr id="internal-has_prop">
                           
                            <td>[[HasProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Возвращает булевское значение, указывая на то, имеет ли данный объект собственное, или наследуемое свойство (<em>propertyKey</em>), возвращая <strong>true</strong>, или не имеет - тогда <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-get">
                           
                            <td>[[Get]]</td>
                             
                            <td>(<em>propertyKey, Receiver</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Возвращает значение свойства (<em>propertyKey</em>) объекта. Если для того, чтобы извлечь значение свойства, нужно выполнить код ECMAScript, используется значение <strong>this</strong> (<em>Receiver</em>).</td>
                            
                        </tr>
                        
                        <tr id="internal-set">
                           
                            <td>[[Set]]</td>
                             
                            <td>(<em>propertyKey, value, Receiver</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Записывает значение (<em>value</em>) свойству (<em>propertyKey</em>). Если для того, чтобы записать значение свойства, нужно выполнить код ECMAScript, используется значение <strong>this</strong> (<em>Receiver</em>). Возвращает <strong>true</strong>, если значение (<em>value</em>) было записано свойству (<em>propertyKey</em>), или <strong>false</strong>, если нет.</td>
                            
                        </tr>
                        
                        <tr id="internal-delete">
                           
                            <td>[[Delete]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Удаляет собственное свойство (<em>propertyKey</em>) из объекта. Возвращает <strong>false</strong>, если свойство (<em>propertyKey</em>) не было удалено и все еще находится в объекте, или <strong>true</strong>, если оно было удалено и не находится в объекте. Если свойство не изменяемое (<a href="#config_attr"><strong>[[Configurable]]</strong></a>: <strong>false</strong>), тогда этот метод вернет <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-prop_keys_o">
                           
                            <td>[[OwnPropertyKeys]]</td>
                             
                            <td>() <span>&#8594;</span> <em>List of properties</em></td>
                            
                            <td>Возвращает список, элементами которого являются все ключи собственных свойств объекта.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Существуют еще <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-6">дополнительные</a> внутренние методы для объектов. Объект функции поддерживает внутренний метод вызова ([[Call]]), а конструктор это функция, что поддерживает внутренний метод построения ([[Construct]]).</p>
                    
                    <table>
                        
                        <caption>Дополнительные важные внутренние мтоды объектов функции</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-call">
                           
                            <td>[[Call]]</td>
                            
                            <td>(<em>any, a List of any</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Внутри объекта функции существует определенный код и этот внутренний метод запускает его выполнения в контексте значения <strong>this</strong> (<em>any</em>) со списком аргументов (<em>List of any</em>). Вызывается он через выражение вызова функции. Объекты, что реализовывают этот метод, называются вызываемыми.</td>
                            
                        </tr>
                        
                        <tr id="internal-construct">
                           
                            <td>[[Construct]]</td>
                             
                            <td>(<em>a List of any, Object</em>) <span>&#8594;</span> <em>Object</em></td>
                            
                            <td>Создает объект, свойства которого получают свои значения из списка аргументов (<em>List of any</em>), что передаются выражению вызова конструктора. Вызывается через операторы <strong>new</strong> и <strong>super</strong>. Оператор <strong>new</strong> применяется к определенному объекту (<em>Object</em>), что во втором аргументе. Объекты, что реализовывают этот метод, называются конструкторами.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Если какой-то из внутренних методов объекта не поддерживается реализацией, вылетит <strong>TypeError</strong>.</p>
                    
                </article>
                
                <p>У внутренних методов есть определенные <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-invariants-of-the-essential-internal-methods">признаки</a>. Также существует еще кучища известных встроенных объектов, и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-well-known-intrinsic-objects">тут</a> дается их перечень.</p>
               
           </section>
           
       </section>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-specification-types">Типы спецификации ECMAScript</a></h3>
               
           </header>
           
           <p>Существуют еще скрытые типы, которые используются алгоритмами языка. При выполнении вычслений запускаются внутренние алгоритмы, которые используют значения, что относятся к скрытым типам. Их значения используются внутри алгоритмов для описания семантики конструкций и типов ECMAScript, о которых упоминалось выше. К скрытым типам относятся Ссылка (Reference), Список (List), Завершение (Completion), Описание свойства (Property Descriptor), Лексическое окружение (Lexical Environment), Запись об окружении (Environment Record) и Блок данных (Data Block). Значения, что относятся к этим типам, являются "артефактами" и не могут хранится в свойствах объекта или в переменных ECMAScript.</p>
           
           <article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-list-and-record-specification-type">Типы списка и записи</a></h4>
                   
               </header>
               
               <p>Данный тип используется, чтобы обьяснить определения списков из аргументов в выражениях оператора <strong>new</strong>, в вызовах функциий и в других алгоритмах, где нужен простой упорядоченный список. Список является просто упорядоченной последовательностью элементов, которые содержат конкретные значения.</p>
               
               <p>Тип для записи используется, чтобы обьяснить агрегацию (обьединение) данных внутри алгоритмов. Данный тип содержит одно или более именованных полей. Значение каждого поля это либо значение ECMAScript, либо абстрактное значение. Имена полей используются для определения конкретных разновидностей агрегации.</p>
               
               <article>
               
                   <header class="header header--center">

                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completion-record-specification-type">Тип записи выполнения</a></h4>

                   </header>

                   <p>Тип записи выполнения используется, чтобы обьяснить распостранение значений внутри своей среды и порядок, в котором осуществляется поведение инструкций (<strong>break</strong>, <strong>continue</strong>, <strong>return</strong> и <strong>throw</strong>), что выполняют нелокальную передачу контроля.</p>

                   <p>Значения и поля типа для записи выполнения определены <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-8">ниже</a>:</p>

                   <table>

                            <caption>Поля записи выполнения</caption>

                            <colgroup>

                                <col />

                                <col />

                            </colgroup>

                            <tr>

                                <th>Поле</th>

                                <th>Значение</th>

                                <th>Смысл</th>

                            </tr>

                            <tr>

                                <td>[[Type]]</td>

                                <td>одно из значений <strong>normal</strong>, <strong>return</strong>, <strong>break</strong>, <strong>continue</strong> или <strong>throw</strong></td>

                                <td>Тип выполнения</td>

                            </tr>

                            <tr>

                                <td>[[Value]]</td>

                                <td>любое значение ECMAScript или <strong>empty</strong></td>

                                <td>Созданное значение</td>

                            </tr>

                            <tr>

                                <td>[[Target]]</td>

                                <td>любая строка ECMAScript или <strong>empty</strong></td>

                                <td>Метка передачи контроля</td>

                            </tr>

                        </table>

               </article>
               
           </article>
           
           <!--<article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-and-relation-specification-type">Типы набора и отношения</a></h4>
                   
               </header>
               
               <p>Тип для набора используется, чтобы обьяснить собрание неупорядоченных элементов для использования в модели памяти. Хитромудятину про модель памяти я разбирать не особо намерен.</p>
               
               <p>Тип для отношений используется, чтобы обьяснить ограничения в наборе.</p>
               
           </article>-->
           
           <section>
               
               <header class="header">
                   
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-reference-specification-type">Тип ссылки</a></h4>
                   
               </header>
               
               <p>Тип для ссылки используется, чтобы обьяснить поведение операторов <strong>delete</strong>, <strong>typeof</strong>, <strong>super</strong>, назначения и других фичей языка.</p>
               
               <p>Ссылка это обработанное имя или привязка свойства. Она состоит из трех компонентов (ссылка, что выражается через оператор <strong>super</strong>, состоит из четырех):</p>
               
               <ol class="list">
                   
                   <li>базового значения;</li>
                   
                   <li>имени, на которое ссылаются;</li>
                   
                   <li>и признака состояния строгости ссылки;</li>
                   
                   <li>в ссылке, что выражается через оператор <strong>super</strong>, имеется еще дополнительный компонент, что указывает на значение <strong>this</strong> - <em>thisValue</em>.</li>
                   
               </ol>
               
               <p>Базовое значение принимает <em>undefined</em>, объект, булевское значение, строку, символ, число, или запись окружения (базовое значение ссылки, что выражается через оператор <strong>super</strong>, не принимает в себе запись окружения). Если базовое значение <em>undefined</em>, это указывает на то, что ссылка не содержит в себе значения. Имя, на которое ссылаются, это либо строка, либо символ.</p>
               
               <p>Для работы с ссылкой используются некоторые абстрактные операции. Их важно рассмотреть, поскольку необходимо понимать, как значения излекаются и перезыписываются, когда на них ссылаются.</p>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-getvalue"><em>GetValue(V)</em></a></h4>
                       
                   </header>
                   
                   <p>Абстрактная операция <strong><em>GetValue(V)</em></strong> применяется, когда по ссылке должно быть извлечено значение.</p>
                   
                   <ol class="list">
                       
                       <li>Первый шаг - это <strong>ReturnIfAbrupt(V)</strong>, что возвращает запись выполнения (тип выполнения в данном случае будет <em>return</em> со значением <strong>V</strong>).</li>
                       
                       <li>Далее проверяется тип значения <strong>V</strong> <span>&#8594;</span> <strong>Type(V)</strong>. Если значение <strong>V</strong> это не ссылка, тогда оно возвращается и на этом все.</li>
                       
                       <li>В случае, когда значение <strong>V</strong> это ссылка, будет выполнена операция <strong>GetBase(V)</strong>, которая возвращает базовое значение (<strong>base</strong>).</li>
                       
                       <li>После возвращения базового значения ссылки (<strong>base</strong>) идет проверка <strong>IsUnresolvableReference(V)</strong>. Если базовое значение ссылки это <strong>undefined</strong>, тогда <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>, а это вызовет <span>&#8594;</span> <strong>ReferenceError</strong>, что закончит выполнение алгоритма. В ином случае, когда <strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>, выполнение алгоритма потопает дальше.</li>
                       
                       <li>Убедившись, что базовое значение ссылки не <strong>undefined</strong>, выполняется проверка <strong>IsPropertyReference(V)</strong>. Эта операция вернет <strong>true</strong>, когда подтвердится одно из двух условий: либо базовое значение ссылки (<strong>base</strong>) имеет тип <em>Object</em>, либо оно относится к одному из примитивных типов <em>Boolean, String, Symbol или Number</em> (без <em>Undefined и Null</em>).
                       
                           <ol class="list" type="a">
                               
                               <li>Принадлежность базового значения ссылки (<strong>base</strong>) к примитивному типу проверяется с помощью <strong>HasPrimitiveBase(V)</strong>. Если операция <strong>HasPrimitiveBase(V)</strong> возвращает <strong>true</strong>, это говорит о том, что базовое значение ссылки (<strong>base</strong>) относится к примитивному типу, и оно должно быть преобразовано в соответствующий объект. Такое превращение при этом сценарии сделает операция <a href="#toobject"><strong>ToObject(base)</strong></a>. Это необходимо для дальнейшего выполнения метода <a href="#internal_get"><strong>[[Get]]</strong></a>.</li>
                               
                               <li>Когда базовое значение ссылки (<strong>base</strong>) уже имеет тип <em>Object</em>, тогда алгоритм запустит внутренний метод <a href="#internal_get"><strong>[[Get]]</strong></a>. Имя ключа свойства объекта, на которое ссылаются, возвращает операция <strong>GetReferencedName(V)</strong>, а значение <strong>this</strong> для определения контекста выполнения - операция <a href="#getthisvalue"><strong>GetThisValue(V)</strong></a>. Итак, будет выполнено <span>&#8594;</span> <strong><em>base.[[Get]](GetReferencedName(V), GetThisValue(V))</em></strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернула <strong>false</strong>, тогда алгоритм приступит к последнему плацдарму. На этом этапе алгоритму ничего не остается, как признать базовое значение ссылки записью окружения (<strong>Environment Record</strong>). Для записи окружения будет применен внутренний метод <a href="#get_bind_value"><strong>GetBindingValue(N, S)</strong></a>, который возвращает значение привязки. Он получает имя привязки, на которое ссылаются (его возвращает операция <strong>GetReferencedName(V)</strong>), и булевское значение, которое будет либо <strong>true</strong>, либо <strong>false</strong> в зависимости от того, строгая ли данная привязка, или нет (этот признак возвращается с помощью операции <strong>IsStrictReference(V)</strong>, что определяет строгость семантики ссылки). Будет выполнено <span>&#8594;</span> <strong><em>base.GetBindingValue(GetReferencedName(V), IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-putvalue"><em>PutValue(V, W)</em></a></h4>
                       
                   </header>
                   
                   <p>Алгоритм тут перезаписывает существующее значение. Операции <strong><em>PutValue(V, W)</em></strong> передаются текущее значение (<strong>V</strong>) и то, которое его заменит (<strong>W</strong>).</p>
                   
                   <ol class="list">
                      
                       <li>Сперва алгоритм выполнит <strong>ReturnIfAbrupt(V)</strong> для текущего значения.</li>
                       
                       <li>Затем для значения, которое его заменит - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>После получения этих двух записей алгоритм проверит тип текущего значения <strong>V</strong> <span>&#8594;</span> <strong>Type(V)</strong> <span>&#8594;</span> чтобы определить, является ли оно ссылкой. Если нет, тогда программа выкинет <span>&#8594;</span> <strong>ReferenceError</strong>, закончив дальнейшее выполнение алгоритма.</li>
                       
                       <li>Получив подтверждение того, что <strong>V</strong> это ссылка, вернем базовое значение (<strong>base</strong>) с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Теперь алгоритм проверит ссылку с помощью <strong>IsUnresolvableReference(V)</strong>. Когда у ссылки базовое значение <strong>undefined</strong>, <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>. 
                          
                           <ol class="list" type="a">
                              
                               <li>Если разигрывется такой сценарий, тогда еще подключится проверка строгости ссылки с помощью операции <strong>IsStrictReference(V)</strong> (она определяет, имеет ли ссылка строгую семантику, или нет). Если <strong>IsStrictReference(V)</strong> вернет <strong>true</strong>, тогда <span>&#8594;</span> <strong>ReferenceError</strong>, ведь строгая семантика ссылки при отсуствии в ней значения - это несовместимое сочетание.</li>
                               
                               <li>В другом случае, когда семантика не является строгой <span>&#8594;</span> <strong>IsStrictReference(V)</strong> вернет <strong>false</strong> <span>&#8594;</span> тогда алгоритм выполнит операцию записи <a href="#set-abstr"><strong>Set</strong></a>. Для этого ему нужно выудить глобальный объект (<strong>globalObj</strong>), который будет использоваться в качестве целевого. Это выполнит операция <a href="#get_glob_obj"><strong>GetGlobalObject()</strong></a>.</li>
                               
                               <li>Обращение к глобальному объекту (<strong>globalObj</strong>) исходит из того, что он является хранилищем всех ссылок, которые находятся в его области видимости, в виде свойств. Потому берется имя ссылки (как ключ свойства), которое возвращает <strong>GetReferencedName(V)</strong>, и выполняется операция записи <strong><a href="#set-abstr">Set</a>(globalObj, GetReferencedName(V), W, false)</strong>, которая запишет значение <strong>W</strong> вместо <strong>undefined</strong> для целевого глобального объекта (<strong>globalObj</strong>) в его контексте выполнения. Булевское значение <strong>false</strong> (последний аргумент в списке) это признак строгости ссылки.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если <strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>, это говорит о том, что базовое значение ссылки имеет в себе значение иное от <strong>undefined</strong> и дальше нужно осуществить проверку того, к какому типу оно принадлежит. Это сделает операция <strong>IsPropertyReference(V)</strong>.
                       
                           <ol class="list" type="a">
                               
                               <li>Эта проверка напоминает матрешку, поэтому будет еще выполнена операция <strong>HasPrimitiveBase(V)</strong>. Когда <strong>HasPrimitiveBase(V)</strong> вернет <strong>true</strong>, тогда примитивное базовое значение ссылки будет преобразовано в соответствующий примитивному типу (<em>Boolean, String, Symbol, или Number</em>) объект с помощью операции <a href="#toobject"><strong>ToObject(base)</strong></a>.</li>
                               
                               <li>В случае, когда <strong>HasPrimitiveBase(V)</strong> возвращает <strong>false</strong>, тогда базовое значение ссылки уже имеет тип <em>Object</em>. Получив базовое значение в виде объекта, оно может использоваться как целевой объект для внутреннего метода <a href="#internal-set"><strong>[[Set]]</strong></a>. Он берет ключ свойства, что соответствует имени, на которое ссылаются (его вернет операция <strong>GetReferencedName(V)</strong>), и записывает ему новое значение <strong>W</strong> вместо текущего <strong>V</strong>, выполняя это в контексте значения <strong>this</strong> (его возвращает операция <strong>GetThisValue(V)</strong>). При успешном своем завершении метод <strong>[[Set]]</strong> вернет <strong>true</strong>. Тут еще подтянется проверка <strong>IsStrictReference(V)</strong>. На выходе это выглядит так: <strong><em>base.[[Set]](GetReferencedName(V), W, GetThisValue(V))</em></strong> (<em>succes</em>).</li>
                               
                               <li>При условии, когда внутрннему методу <a href="#internal-set"><strong>[[Set]]</strong></a> не удалось записать новое значение вместо текущего и он вернет <strong>false</strong>, а <strong>IsStrictReference(V)</strong> - <strong>true</strong>, тогда программа выкинет исключение <span>&#8594;</span> <strong>TypeError</strong>.</li>
                               
                               <li>В остальном, вернется результат выполнения <a href="#internal-set"><strong>[[Set]]</strong></a> (<em>succes</em>).</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернет <strong>false</strong>, тогда алгоритм приступит к последнему шагу. На этом этапе базовое значение ссылки будет соответствовать записи окружения (<strong>Environment Record</strong>). К ней будет применен внутренний метод <a href="#set_mut_bind"><strong>SetMutableBinding(N, V, S)</strong></a>, который записывает новое значение существующей привязке (ее имя вернет операция <strong>GetReferencedName(V)</strong>). Итогом будет выполнение: <strong><em>base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getthisvalue">GetThisValue(V)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция возвращает значение <strong>this</strong>, что является объектом, который определяет контекст выполнения.</p>
                   
                   <ol class="list">
                      
                       <li>Обязательное утверждение: ссылка <strong>V</strong> это объект (<strong>IsPropertyReference(V)</strong> возвращает <strong>true</strong>).</li>
                       
                       <li>Затем проверяется, имеет ли ссылка <strong>V</strong> компонент <em>thisValue</em>: выполняется операция <strong>IsSuperReference(V)</strong>. Если она его имеет <span>&#8594;</span> <strong>IsSuperReference(V)</strong> будет <strong>true</strong> <span>&#8594;</span> тогда возвращается значение этого компонента в качестве <strong>this</strong>.</li>
                       
                       <li>Если предыдущая проверка не подтвердилась, тогда возращается базовое значение ссылки (алгоритм выполнит <strong>GetBase(V)</strong>), которое и будет текущим контекстом выполнения - <strong>this</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <!--<article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-initializereferencedbinding">InitializeReferencedBinding(V, W)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция записывает новое значение <strong>W</strong> существующей, при это не инициализированной привязке, на которую ссылаются, в записи окружения, которая является ссылкой.</p>
                   
                   <ol class="list">
                      
                       <li>Сначала возвращается запись для начального значения - <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>После этого возвращается запись для нового значения - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>Обязательное утверждение: начальное значение <strong>V</strong> это ссылка, что подтверждает соответствующая проверка <strong>Type(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: ссылка является обрабатываемой (<strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>).</li>
                       
                       <li>Возвращается базовое значение ссылки с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: базовое значение ссылки является записью окружения (<em>Environment Record</em>).</li>
                       
                       <li>И теперь возвращается операция <strong>base.InitializeBinding(<em>GetReferencedName(V), W</em>)</strong>. К записи окружения применяется внутренний метод <strong>InitializeBinding(N, V)</strong>, что записывает значение <strong>W</strong> для существующей, при это не инициализированной привязки в записи окружения, имя которой возвращает <strong>GetReferencedName(V)</strong>.</li>
                       
                   </ol>
                   
               </article>-->
               
           </section>
           
           <section id="prop_desc">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-descriptor-specification-type">Тип описания свойства</a></h4>
                   
               </header>
               
               <p>Тип описания свойства используется, что объяснить управление и воплощение атрибутов свойств объекта. Значением типа описания свойств является запись. Имя поля это имя атрибута, а значение поля - это соответствующее значение атрибута.</p>
               
               <p>Значения описания свойства в дальнейшем могут быть классифицированы как описание свойств данных и описание свойств доступа, что основаны на существовании или использовании определенных полей. Описание свойства данных включает в себя поля с именами <strong>[[Value]]</strong> и <strong>[[Writable]]</strong> (либо одно из них, либо оба). Описание свойства доступа включает в себя поля с именами <strong>[[Get]]</strong> или <strong>[[Set]]</strong> (либо одно из них, либо оба). Каждое описание свойства имеет поля, имена которых <strong>[[Enumerable]]</strong> и <strong>[[Configurable]]</strong>. Есть еще общее и полное описание свойства, которое имеет все соответствующие поля.</p>
               
               <p>Существуют абстрактные операции для управления значениями описания свойства.</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isaccessordescriptor"><strong>IsAccessorDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства доступа.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isdatadescriptor"><strong>IsDataDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства данных.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isgenericdescriptor"><strong>IsGenericDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> общим описанием свойства.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-frompropertydescriptor"><strong>FromPropertyDescriptor(Desc)</strong></a> записывает значения соответствующих полей свойствам с теми же именами, что создаются для объекта, у которого собственных свойств нет, и возвращает этот объект.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-topropertydescriptor"><strong>ToPropertyDescriptor(Obj)</strong></a> возвращает описание свойства, у которого изначально не было соответствующих полей.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completepropertydescriptor"><strong>CompletePropertyDescriptor(Desc)</strong></a> возвращает полное описание свойства в зависимости от его типа, у которого отсуствуют соответствующие поля, записывая им значения по умолчанию.</li>
                   
               </ul>
               
           </section>
           
           <p>Есть еще типы <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">записи окружения</a>, <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">лексического окруженния</a> и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-data-blocks">блоки данных</a>.</p>
           
       </section>
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-operations">Абстрактные операции</a></h2>
           
       </header>
       
       <p>Существуют абстрактные операции, которые описывают семантику языка.</p>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-type-conversion">Преобразование типов</a></h3>
               
           </header>
           
           <p>ECMAScript неявно выполняет автоматическое преобразование типов при необходимости. Абстрактные операции преобразования типов принимают значения любого типа ECMAScript (при этом они не работают со значениями, что относятся к скрытым внутренним типам языка) и они полиморфные.</p>
           
           <p>Рассмотрим эти абстрактные операции.</p>
           
           <section id="toprim-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive">ToPrimitive ( input [ , PreferredType ] )</a></h4>
                   
               </header>
               
               <p>Абстрактная операция <strong>ToPrimitive</strong> преобразовывает входящий аргумент <strong>input</strong> к примитивному типу. Объект может быть преобразован в более чем один примитивный тип, поэтому используется дополнительное указание <strong>PreferredType</strong>, чтобы ткнуть пальцем на предпочтительный тип для преобразования. Эта операция выполняется согласно такому алгоритму:</p>
               
               <ol class="list">
                  
                   <li>Сначала утверждается, что <strong>input</strong> это значение любого типа ECMAScript.</li>
                   
                   <li>Далее проверяется тип входящего аргумента <strong>input</strong> <span>&#8594;</span> <strong>Type(input)</strong>. Если выдает, что <strong>input</strong> принадлежит к типу <em>Object</em>, тогда алгоритм выполнит следующие шаги:
                   
                       <ol class="list" type="a">
                           
                           <li>Сперва алгоритм должен узнать, к какому примитивному типу следует преобразовать объект <strong>input</strong>. Если аргументу <strong>PreferredType</strong> не было передано никакого указания, тогда ему по умолчанию запишется <strong>"default"</strong>.</li>
                           
                           <li>Если же аргументу <strong>PreferredType</strong> было передано указание на тип строки (<em>String</em>), тогда ему запишется <strong>"string"</strong>.</li>
                           
                           <li>В случае, когда аргументу <strong>PreferredType</strong> было передано указание на тип числа (<em>Number</em>), тогда он получит запись <strong>"number"</strong>.</li>
                           
                           <li>Когда вопрос с аргументом <strong>PreferredType</strong> решен, необходимо понять, с каким именно объектом алгоритм имеет дело: обычным или нет. <a href="https://www.ecma-international.org/ecma-262/#sec-built-in-exotic-object-internal-methods-and-slots">Необычные объекты</a> еще будут подробно рассматриваться. Если объект необычный, тогда алгоритм воспользуется операцией <strong>GetMethod(input, @@toPrimitive)</strong> (<em>exoticToPrim</em>), чтобы преобразовать его в примитивный тип. Сама по себе операция <strong>GetMethod (V, P)</strong> используется для получения значения свойства <strong>P</strong> объекта <strong>V</strong>. При этом данное значение ожидаемое как функция. И если оно не функция, тогда вылетит <strong>TypeError</strong>. В контексте этого алгоритма для операции <strong>GetMethod(input, @@toPrimitive)</strong> в итоге будет выполнено извлечение значения свойства (метода) с ключом <strong>@@toPrimitive</strong> целевого объекта <strong>input</strong>: <strong>input.[[Get]](@@toPrimitive, input)</strong>. Символ <strong>@@toPrimitive</strong> соответствует методу, который превращает объект в соответствующее примитивное значение (и вызывается он абстрактной операцией <strong><em>ToPrimitive</em></strong>). 
                           
                               <p>Итак, значением свойства <strong>@@toPrimitive</strong> есть функция, что превращает объект символа в примитивное значение. У этой функции есть имя - <strong>"Symbol.toPrimitive"</strong>. Она так же принимает в качетсве аргумента указание на тип преобразования (<em>hint</em>). И если извлеченным значением <strong>@@toPrimitive</strong> является не <strong>undefined</strong>, тогда будет выполнено еще несколько шагов:</p>
                               
                               <ol class="list" type="i">
                                   
                                   <li>Извлеченная функция метода <strong>@@toPrimitive</strong> (<em>exoticToPrim</em>) будет вызвана с помощью операции <strong> Call(exoticToPrim, input, "hint")</strong>. Эта операция используется для вызова извлеченной функции (<strong>exoticToPrim</strong>) в контексте выполнения объекта <strong>input</strong> с указанием на тип преобразования (<strong>"hint"</strong>) с помощью внутреннего метода <strong>[[Call]]</strong>. В итоге операция <strong>Call</strong> вернет: <strong>exoticToPrim.[[Call]](input, "hint")</strong>.</li>
                                   
                                   <li>Если полученный результат вызова извлеченной функции (<em>result</em>) выдержал проверку на не принадлежность к типу Object <span>&#8594;</span> <strong>Type(result)</strong> <span>&#8594;</span> тогда алгоритм вернет его,  окончив выполнение операции <strong><em>ToPrimitive</em></strong>.</li>
                                   
                                   <li>В противном случае вылетит птичка в виде <strong>TypeError</strong>.</li>
                                   
                               </ol>
                               
                            </li>
                            
                            <li>Если же объект обычный и в качестве указания аргумент <strong>PreferredType</strong> получил запись <strong>"default"</strong>, тогда это указание запишется к <strong>"number"</strong>. </li>
                            
                            <li>Когда объект является обычным, будет выполнена операция <a href="#ordinarytoprimitive"><strong>OrdinaryToPrimitive(input, hint)</strong></a>, что используется для преобразования обычных объектов в примитивное значение.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же проверка <strong>Type(input)</strong> выдает, что аргумент <strong>input</strong> не принадлежит к типу <em>Object</em>, тогда алгоритм вернет его.</li>
                   
               </ol>
               
               <p>Объекты типа <em>Date</em> и объекты символов (<em>Symbol</em>) единственные, которые переопределяют стандартное поведение операции <strong><em>ToPrimitive</em></strong>.</p>
               
               <p>Теперь не мешает разобрать, что представляет из себя абстрактная операция <strong>OrdinaryToPrimitive</strong>.</p>
               
               <article id="ordinarytoprimitive">
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive">OrdinaryToPrimitive ( O, hint )</a></h4>
                       
                   </header>
                   
                   <p>Эта операция используется для преобразования обычных объектов в примитивное значение. Алгоритм тут состоит из следующих шагов:</p>
                   
                   <ol class="list">
                      
                       <li>Для начала объявляется, что аргумент <strong>O</strong> это значение, которое имеет тип <em>Object</em> (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                       
                       <li>Аргумент <strong>hint</strong> является указанием для преобразования, который принимает в качестве значения строку либо <strong>"string"</strong>, либо <strong>"number"</strong> (<strong>Type(hint)</strong> <span>&#8594;</span> <em>String</em>).</li>
                       
                       <li>Если указанию <strong>hint</strong> было передано значение <strong>"string"</strong> для преобразования объекта <strong>O</strong> в строку, тогда алгоритм получит список из имен внутренних методов (<em>methodNames</em>), которые имеют такую последовательность: <strong>" 'toString', 'valueOf' "</strong>.</li>
                       
                       <li>Если же <strong>hint</strong> получил в качестве значения <strong>"number"</strong> для преобразования объекта <strong>O</strong> в число, тогда последовательность методов (<em>methodNames</em>) будет обратная: <strong>" 'valueOf', 'toString' "</strong>.</li>
                       
                       <li>Для каждого имени метода (<em>name</em>) за порядком списка (<em>methodNames</em>) будут выполнены такие шаги:
                       
                           <ol class="list" type="a">
                               
                               <li>Имя (<em>name</em>) используется как указатель на метод для выполнения операции <strong>Get(O, name)</strong> (<em>method</em>), которая извлекает значение данного метода, возвращая <strong>O.[[Get]](name, O)</strong>. Для объекта <strong>O</strong> эти методы достаются из глобального объекта через наследование, что реализовано цепочкой прототипов.</li>
                               
                               <li>Получив значение соответствующего метода, алгоритм выполнит проверку того, является ли оно функцией с внутренним методом вызова <strong>[[Call]]</strong> <span>&#8594;</span> <strong>IsCallable(method)</strong>. Если вернулось <strong>true</strong>, тогда:
                               
                                   <ol class="list" type="i">
                                       
                                       <li>Данный метод будет вызван для целевого объекта <strong>O</strong>. Этот вызов выполнит операция <strong>Call(method, O)</strong> (<em>result</em>), что вернет: <strong>method.[[Call]](O)</strong>.</li>
                                       
                                       <li>Если полученный результат (<em>result</em>) не относится к типу <em>Object</em> (тут будет выполнена проверка <span>&#8594;</span> <strong>Type(result)</strong>), тогда алгоритм вернет его. А если полученный результат все еще имеет тип <em>Object</em>, тогда запустится выполнение следующего метода (<em>name</em>) в списке (<em>methodNames</em>).</li>
                                       
                                   </ol>
                               
                               </li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если на предыдущем шаге в итоге случилась лажа, тогда вылетит <strong>TypeError</strong>.</li>
                       
                   </ol>
                   
                   <p>Итак, теперь важно понимать, какое значение имеет тут последовательность методов, когда алгоритм получил то, или иное указание для преобразования (<em>hint</em>). Когда указанию было передано значение <strong>"string"</strong>, сперва будет выполнен внутренний метод <strong>toString</strong>. Он возвращает строку формата <strong>"[object <em>tag</em>]"</strong>, где обозначением <em>tag</em> может быть: <strong>Undefined</strong>, <strong>Null</strong>, <strong>Array</strong>, <strong>String</strong>, <strong>Arguments</strong>, <strong>Function</strong>, <strong>Error</strong>, <strong>Boolean</strong>, <strong>Number</strong>, <strong>Date</strong>, <strong>RegExp</strong> и <strong>Object</strong>, - что зависит от особенностей объекта, к которому этот метод применяется. Вернув строку, очередь метода <strong>valueOf</strong> не наступит и алгоритм закончит свое выполнение.</p>
                   
                   <p>В случае, когда указанию (<em>hint</em>) было передано значение <strong>"number"</strong>, первым будет выполнен метод <strong>valueOf</strong>. Он возвращает операцию <strong>ToObject(O)</strong>, которая превращает в объект передаваемое ей в аргументе значение. Получив результат выполнения <strong>valueOf</strong> (<em>result</em>), алгоритм повторит цикл для метода <strong>toString</strong>, который будет применен к объекту, что произвел предыдущий метод. А он уже вернет соответствующую строку, которая и будет использоваться для дальнейшего преобразования в число.</p>
                   
               </article>
               
           </section>
           
           <article id="toboolean-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toboolean">ToBoolean ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в булевский тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в булевское значение <strong>ToBolean</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Если в аргументе дано <strong>+0</strong>, <strong>-0</strong> или <strong>NaN</strong>, тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Если в аргументе дано пустую строку (имеет нулевую длину), тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                </table>
               
           </section>
           
           <section id="tonumber">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber">ToNumber ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в числовой тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в числовое значение <strong>ToNumber</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>NaN</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>+0</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет 1; в случае, когда <strong>false</strong> - вернет 0.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber-applied-to-the-string-type">алгоритм преоразования</a>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint Number)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) будет значением для аргумента <strong>ToNumber</strong> <span>&#8594;</span> <strong>ToNumber(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Если аргументу было передано значение с типом <em>String</em>, что не может быть истолковано как числовой литерал, который дается в виде строки (<em>StringNumericLiteral</em>), тогда результатом выполнения операции <strong>ToNumber</strong> будет <strong>NaN</strong>. Итак, если строка, которую нужно преобразовать в число, имеет вид "трали-вали", тогда получим <strong>NaN</strong>. Если же строка является такой, что имеет вид десятичного, двоичного, восьмеричного или шестнадцатиричного числа, тогда она преобразуется в значение, что имеет тип <em>Number</em> ("123" <span>&#8594;</span> 123).</p>
                
                <p>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) имеет некоторые свои особенности, что отличают его от простого числового литерала (<em>NumericLiteral</em>):</p>
                
                <ul class="list">
                   
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя пробел, что начинает и/или завершает строку, и/или символы конца строки (т.е. " 123 " это норм и будет <span>&#8594;</span> 123).</li>
                    
                    <li>Десятичному числовому литералу в виде строки (<em>StringNumericLiteral</em>) может предшествовать любое количество нулей (т.е. "000000123" <span>&#8594;</span> 123, а это говорит о том, что нули являются незначительными).</li>
                    
                    <li>Десятичный числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя <strong>+ / -</strong>, чтобы указать свой знак (т.е. "-123" <span>&#8594;</span> -123).</li>
                    
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>), которая является пустой или имеет в себе только пробел, преобразовывется в <strong>+0</strong> (т.е. " " <span>&#8594;</span> 0).</li>
                    
                    <li>Значения <strong>Infinity</strong> и <strong>-Infinity</strong> распознаются как числовой литерал в виде строки (<em>StringNumericLiteral</em>), а не как просто числовой литерал (<em>NumericLiteral</em>), и преобразовываются в настолько огромедное число (10<sup>10000</sup>), что округляются к <strong>+&#8734;</strong> или <strong>-&#8734;</strong>.</li>
                    
                </ul>
                
                <p>Динамическая семантика преобразования того значения, что сидит в строке, к типу <em>Number</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-runtime-semantics-mv-s"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tostring">ToString ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в строку. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в строку <strong>ToString</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>"undefined"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>"null"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет <strong>"true"</strong>; в случае, когда <strong>false</strong> - вернет <strong>"false"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type">алгоритм преоразования</a> (вот, к примеру, <strong>NaN</strong> <span>&#8594;</span> <strong>"NaN"</strong>, <strong>+0 / -0</strong> <span>&#8594;</span> <strong>"0"</strong>, а <strong>+&#8734;</strong> <span>&#8594;</span> <strong>"Infinity"</strong>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) будет значением для аргумента операции <strong>ToString</strong> <span>&#8594;</span> <strong>ToString(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Динамическая семантика преобразования числа к типу <em>String</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section id="toobject">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toobject">ToObject ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) к типу <em>Object</em>. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в объект <strong>ToObject</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-boolean-objects">булевский объект</a>, чей внутренний слот <strong>[[BooleanData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-number-objects">числовой объект</a>, чей внутренний слот <strong>[[NumberData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-string-objects">строковый объект</a>, чей внутренний слот <strong>[[StringData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-symbol-objects">объект символа</a>, чей внутренний слот <strong>[[SymbolData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Возвращает свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                </table>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tointeger">ToInteger ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое числовое значение. Её алгоритм такой:</p>
               
               <ol class="list">
                  
                   <li>Сначала будет выполнена операция, что возвращает число - <a href="#tonumber"><strong>ToNumber(argument)</strong></a>.</li>
                   
                   <li>Если результат выполнения предыдущей операции (<em>number</em>) это <strong>NaN</strong>, тогда вернется ноль <strong>+0</strong>.</li>
                   
                   <li>Если результатом выполнения операции <a href="#tonumber"><strong>ToNumber(argument)</strong></a> (<em>number</em>) будет <strong>+0</strong>, <strong>-0</strong>, <strong>+&#8734;</strong> или <strong>-&#8734;</strong>, тогда он же (<em>number</em>) и вернется.</li>
                   
                   <li>В остальных случаях будет возвращатся число со своим знаком (<em>number</em>) и сводится к его абсолютному значению через выполнение <strong>floor(abs(number))</strong>. Разберем по порядку:
                   
                       <ol class="list" type="a">
                           
                           <li id="abs_number">Математическая функция <strong>abs(number)</strong> выдает абсолютное значение числа (<em>number</em>).</li>
                           
                           <li id="floor">Затем эта абсолютная величина округляется к наибольшему целому числу, которое при этом не больше входящего значения <strong>abs(number)</strong> - эту выдачу обеспечивает операция <strong>floor</strong> (т.е. 5.66666 тут будет <span>&#8594;</span> 5).</li>
                           
                       </ol>
                   
                   </li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-topropertykey">ToPropertyKey ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в то значение, которое может быть использовано в качестве ключа свойства. Алгоритм тут следующий:</p>
               
               <ol class="list">
                  
                  <li>Первое, что выполняется, это операция, которая сводит входящий аргумент (<em>argument</em>) к примитивному значению - <a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a>. Это полученное примитивное значение и будет ключом свойства (<em>key</em>).</li>
                  
                  <li>Если полученный ключ является символом (<strong>Type(key)</strong> <span>&#8594;</span> <em>Symbol</em>), тогда вернется этот символ как ключ свойства.</li>
                  
                  <li>В случае же, когда ключ свойства это не символ, тогда полученное примитивное значение, которое родилось на первом этапе (<em>key</em>), попадет в лапы операции, что трансформирует его и наверняка вернет строку - <a href="#tostring"><strong>ToString(key)</strong></a>. Она и будет ключом свойства. Вуа-ля.</li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tolength">ToLength ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое число, которое в дальнейшем используется как длина (число элементов) массивоподобного объекта. Алгоритм выполнения данной операции:</p>
               
               <ol class="list">
                  
                  <li>Для начала необходимо вернуть целое число (<em>len</em>), чем и займется операция <a href="#tointeger"><strong>ToInteger(argument)</strong></a>.</li>
                  
                  <li>Если полученный результат (<em>len</em>) меньше или равен нулю (<em>len</em> <span>&#8804;</span> <strong>+0</strong>), тогда вернется ноль <strong>+0</strong>.</li>
                  
                  <li>А если полученное число больше нуля, тогда оно и вернется. Вот только не так просто, а через функцию <strong>min(<em>len</em>, 2<sup>53</sup>-1)</strong>, которая возвращает наименьшее число в данном диапазоне. Диапазон тут дается потому, что длина массивоподобного объекта (<em>len</em>) не может быть больше 2<sup>53</sup>-1.</li>

               </ol>
               
           </section>
           
           <div>
              
               <p>Существует еще целый набор абстрактных операций, которые производят преобразование входящего значения. Кратко перечислим:</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toindex"><strong>ToIndex ( value )</strong></a> - эта операция возвращает корректное целое число для индекса.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-canonicalnumericindexstring"><strong>CanonicalNumericIndexString ( argument )</strong></a> - эта операция возвращает числовое значение, если оно является строковым представлением числа, произведенного операцией <a href="#tostring"><strong>ToString</strong></a>, или строкой <strong>"-0"</strong>. В ином случае вернет <strong>undefined</strong>.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint32"><strong>ToInt32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от -2<sup>31</sup> до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint32"><strong>ToUint32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от 0 до 2<sup>31</sup> - 1 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint16"><strong>ToInt16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от -32768 до 32767 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint16"><strong>ToUint16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от 0 до 2<sup>16</sup> - 1 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint8"><strong>ToInt8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от -128 до 127 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8"><strong>ToUint8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от 0 до 255 включительно (значения без знака).</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8clamp"><strong>ToUint8Clamp ( argument )</strong></a> - то же определение, что и в предыдущей операции, только с измененным алгоритмом выполнения.</li>
                   
               </ul>
               
           </div>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-testing-and-comparison-operations">Операции тестирования и сравнения</a></h3>
               
           </header>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-requireobjectcoercible">RequireObjectCoercible ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция проверяет возможность преобразования значения аргумента (<em>argument</em>) в объект с помощью <a href="#toobject"><strong>ToObject</strong></a>. Если значение не поддатливое, тогда она вернет ошибку.</p>
               
               <table>

                    <caption>Результаты <strong>RequireObjectCoercible</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em>).</td>

                    </tr>

                </table>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isarray">IsArray ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли объект массивом (<em>Array</em>) или прокси-объектом (<em>Proxy</em>). Алгоритм проверки следующий:</p>
               
               <ol class="list">
                   
                   <li>Сначала проверяется тип значения в аргументе <span>&#8594;</span> <strong>Type(argument)</strong>. Если оно не принадлежит к типу <em>Object</em>, тогда вернется <strong>false</strong>.</li>
                   
                   <li>Если в аргументе массив (<em>Array</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если в аргументе прокси-объект (<em>Proxy</em>), тогда
                   
                   <ol class="list" type="a">
                       
                       <li>под прицел попадает значение внутреннего слота <strong>[[ProxyHandler]]</strong> аргумента (<em>argument</em>) <span>&#8594;</span> <strong>argument.[[ProxyHandler]]</strong>. Когда оно <strong>null</strong>, на выходе получим <strong>TypeError</strong>.</li>
                       
                       <li>А если не <strong>null</strong>, тогда аргументу будет передано значение <strong>argument.[[ProxyHandler]]</strong> (<em>target</em>).</li>
                       
                       <li>Итак, будет выполнено <strong>IsArray(target)</strong>.</li>
                       
                   </ol>
                   
                   
                   </li>
                   
                   <li>В остальных случаях, когда имеем какой-то другой объект, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="iscallable-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-iscallable">IsCallable ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) вызываемой функцией с внутренним методом <strong>[[Call]]</strong>. Алгоритм проверки такой:</p>
               
               <ol class="list">
                  
                   <li>В аргументе должен быть объект, иначе вернется <strong>false</strong> (выкупаем <span>&#8594;</span> <strong>Type(argument)</strong>).</li>
                   
                   <li>Если значение в аргументе имеет внутренний метод вызова <strong>[[Call]]</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>А если не имеет, тогда вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isconstructor">IsConstructor ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) функцией с внутренним методом <strong>[[Construct]]</strong>. Алгоритм проверки такой:</p>
               
               <ol class="list">
                  
                   <li>Если в аргументе не объект, тогда вернется <strong>false</strong> (выкупаем <span>&#8594;</span> <strong>Type(argument)</strong>).</li>
                   
                   <li>Если значение в аргументе имеет внутренний метод <strong>[[Construct]]</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>А если не имеет, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isextensible-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isextensible-o">IsExtensible ( O )</a></h4>
                   
               </header>
               
               <p>Эта операция используется для определения того, могут ли дополнительные свойства быть добавлены к объекту <em>O</em>. Выполняются такие шаги:</p>
               
               <ol class="list">
                  
                   <li>Проверка <strong>Type(O)</strong> <span>&#8594;</span> объект.</li>
                   
                   <li>Возвращает <strong>O.[[IsExtensible]]()</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isinteger">IsInteger ( argument )</a></h4>
                   
               </header>
               
               <p>Определяет, является ли значение в аргументе (<em>argument</em>) конечным целым числом. Алгоритм выполнения:</p>
               
               <ol class="list">
                   
                   <li>В аргументе должно быть значение числового типа <strong>Type(argument)</strong> <span>&#8594;</span> <strong>Number</strong>, или же вернется <strong>false</strong>.</li>
                   
                   <li>Если в аргументе <strong>NaN</strong>, <strong>+&#8734;</strong>, или <strong>-&#8734;</strong>, вернется <strong>false</strong>.</li>
                   
                   <li>Затем проверяется равенство <a href="#floor"><strong>floor(abs(argument))</strong></a> с <a href="#abs_number"><strong>abs(argument)</strong></a> <span>&#8594;</span> если они не равны другу другу (<span>&#8800;</span>), тогда вернется <strong>false</strong>.</li>
                   
                   <li>Дойдя до сюда, вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="ispropkey">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ispropertykey">IsPropertyKey ( argument )</a></h4>
                   
               </header>
               
               <p>Определяет, может ли значение в аргументе (<em>argument</em>) использоваться как ключ свойства. Алгоритм проверки:</p>
               
               <ol class="list">
                   
                   <li>Если <strong>Type(argument)</strong> <span>&#8594;</span> <strong>String</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(argument)</strong> <span>&#8594;</span> <strong>Symbol</strong>, тогда вернется <strong>true</strong>.</li>
                   
                   <li>В других случаях - <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isregexp">IsRegExp ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли значение в аргументе (<em>argument</em>) регулярным выражением (<em>RegExp</em>). Алгоритм:</p>
               
               <ol class="list">
                  
                   <li>Если <strong>Type(argument)</strong> не <span>&#8594;</span> <strong>Object</strong>, тогда вернется <strong>false</strong>.</li>
                   
                   <li>Затем выполнится операция <strong>Get(argument, @@match)</strong> (<em>isRegExp</em>). Символ <strong>@@match</strong> соответствует методу, что подбирает строку под регулярное выраженние (вызывается методом <em>String.prototype.match</em>). Итак, к объекту в аргументе (<em>argument</em>) будет применен внутренний метод <strong>[[Get]]</strong>, чтобы извлечь значение свойства <strong>@@match</strong>.</li>
                   
                   <li>Если вернувшееся значение операции <strong>Get</strong> (<em>isRegExp</em>) не <strong>undefined</strong>, тогда будет выполнено <a href="#toboolean"><strong>ToBoolean(isRegExp)</strong></a>.</li>
                   
                   <li>Далее проверяется, имеет ли значение в аргументе (<em>argument</em>) внутренний слот <strong>[[RegExpMatcher]]</strong>. При его наличии вернется <strong>true</strong>.</li>
                   
                   <li>Если нет, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="samevalue-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevalue">SameValue ( x, y )</a></h4>
                   
               </header>
               
               <p>Эта операция сравнивает два значения, которые передаются ей в аргументе (<em>x</em> и <em>y</em>), и выдает булевский результат сравнения <strong>true / false</strong> в зависимости от того, являются ли они равны друг другу, или нет. Алгоритм сверки:</p>
               
               <ol class="list">
                   
                   <li>Если <strong>Type(x)</strong> выдал нечто иное от <strong>Type(y)</strong>, тогда <span>&#8594;</span> <strong>false</strong>.</li>
                   
                   <li>В случае, когда <strong>Type(x)</strong> возвращает <em>Number</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>если <strong>x</strong> это <strong>NaN</strong> и <strong>y</strong> тоже <strong>NaN</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>если <strong>x</strong> это <strong>+0</strong>, а <strong>y</strong> имеет <strong>-0</strong> (и наоборот), вернется <strong>false</strong>;</li>
                           
                           <li>если числовые значения <strong>x</strong> и <strong>y</strong> одинаковы, вернется <strong>true</strong>;</li>
                           
                           <li>в остальном будет <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же <strong>Type(x)</strong> это все, что угодно, кроме <em>Number</em>, тогда будет выполнена операция <a href="#samevaluenonnumber"><strong>SameValueNonNumber(x, y)</strong></a>.</li>
                   
               </ol>
               
               <div id="samevaluezero">
                  
                   <p>Существует еще операция <a href="https://www.ecma-international.org/ecma-262/#sec-samevaluezero"><strong>SameValueZero ( x, y )</strong></a>, которая повторяет алгоритм <strong>SameValue ( x, y )</strong>, вот только с тем отличием, что положительный и отрицательный ноль в ней равны друг другу. Т.е. если <strong>x</strong> это <strong>+0</strong>, а <strong>y</strong> - это <strong>-0</strong> (и наоборот), тогда вернется <strong>true</strong>.</p>
                   
               </div>
               
           </article>
           
           <article id="samevaluenonnumber">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevaluenonnumber">SameValueNonNumber ( x, y )</a></h4>
                   
               </header>
               
               <p>В этой операции сравниваемые значения (<em>x</em> и <em>y</em>) не принадлежат к типу <em>Number</em>. Алгоритм сравнения такой:</p>
               
               <ol class="list">
                   
                   <li><strong>Type(x)</strong> не вернет <em>Number</em>.</li>
                   
                   <li><strong>Type(x)</strong> имеет такой же тип, как и <strong>Type(y)</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Undefined</em>, вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Null</em>, вернется <strong>true</strong>.</li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>String</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда <strong>x</strong> и <strong>y</strong> это одинаковая последовательность кодовых единиц (имеют одинаковую длину и одинаковые кодовые единицы с соответствующими индексами), вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Boolean</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда оба <strong>x</strong> и <strong>y</strong> имеют одинаковое булевское значение <strong>true</strong> или <strong>false</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если <strong>Type(x)</strong> это <em>Symbol</em>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>в случае, когда оба <strong>x</strong> и <strong>y</strong> имеют одинаковое значение символа (<em>Symbol</em>), вернется <strong>true</strong>;</li>
                           
                           <li>в ином случае вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если <strong>x</strong> и <strong>y</strong> это один и тот же объект, вернется <strong>true</strong>; в ином случае вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="equality-comparison">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison">Равенство</a></h4>
                   
               </header>
               
               <p>Это сравнение имеет вид <em>x == y</em> и возвращает либо <strong>true</strong>, либо <strong>false</strong>, где <em>x</em> и <em>y</em> - сравниваемые значения. Алгоритм таков:</p>
               
               <ol class="list">
                  
                   <li>Если <em>x</em> и <em>y</em> имеют одинаковый тип (что проверит <strong>Type(x)</strong> и <strong>Type(y)</strong>), тогда вернется результат выполнения операции <a href="#strict-equality">строгого равенства</a>.</li>
                   
                   <li>Если <em>x</em> это <strong>null</strong>, а <em>y</em> - <strong>undefined</strong>, тогда вернется <strong>true</strong> (и если наоборот, то тоже вернется <strong>true</strong>).</li>
                   
                   <li>Если <em>x</em> имеет числовой тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Number</em>), а <em>y</em> - строковый (<strong>Type(y)</strong> <span>&#8594;</span> <em>String</em>), тогда вернется результат сравнения <strong>x == <a href="#tonumber">ToNumber(y)</a></strong>.</li>
                   
                   <li>Если же <em>x</em> имеет строковый тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>String</em>), а <em>y</em> - числовой (<strong>Type(y)</strong> <span>&#8594;</span> <em>Number</em>), тогда вернется результат сравнения <strong><a href="#tonumber">ToNumber(x)</a> == y</strong>.</li>
                   
                   <li>Если <em>x</em> имеет булевский тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда вернется результат сравнения <strong><a href="#tonumber">ToNumber(x)</a> == y</strong>.</li>
                   
                   <li>Если же <em>y</em> имеет булевский тип (<strong>Type(y)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда вернется результат сравнения <strong>x == <a href="#tonumber">ToNumber(y)</a></strong>.</li>
                   
                   <li>В случае, если значение <em>x</em> имеет строковый, числовой или символьный тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>String / Number / Symbol</em>), а <em>y</em> - объектный (<strong>Type(y)</strong> <span>&#8594;</span> <em>Object</em>), тогда вернется результат сравнения <strong>x == <a href="#toprimitive">ToPrimitive(y)</a></strong>.</li>
                   
                   <li>Если же значение <em>x</em> имеет объектный тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Object</em>), а <em>y</em> - строковый, числовой или символьный тип (<strong>Type(y)</strong> <span>&#8594;</span> <em>String / Number / Symbol</em>), тогда вернется результат сравнения <strong><a href="#toprimitive">ToPrimitive(x)</a> == y</strong>.</li>
                   
                   <li>В остальных случаях вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="strict-equality">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison">Строгое равенство</a></h4>
                   
               </header>
               
               <p>Это сравнение имеет вид <em>x === y</em> и возвращает либо <strong>true</strong>, либо <strong>false</strong>. Алгоритм имеет вид:</p>
               
               <ol class="list">
                   <li>Если сравниваемые значения <em>x</em> и <em>y</em> имеют разные типы (что выдаст <strong>Type(x)</strong> и <strong>Type(y)</strong>), тогда вернется <strong>false</strong>. Так что строгое сравнение применяется только "для своих" значений.</li>
                   
                   <li>Если <em>x</em> имеет числовой тип (<strong>Type(x)</strong> <span>&#8594;</span> <em>Number</em>), тогда 
                   
                       <ol class="list">
                           
                           <li>когда значение <em>x</em> это <strong>NaN</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>когда значение <em>y</em> это <strong>NaN</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>когда <em>x</em> и <em>y</em> это одинаковые числовые значения, вернется <strong>true</strong>.</li>
                           
                           <li>когда значение <em>x</em> это <strong>+0</strong>, а <em>y</em> - это <strong>-0</strong>, вернется <strong>true</strong> (и когда наоборот, тоже вернется <strong>true</strong>).</li>
                           
                           <li>в остальных случаях вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же мы имеем другие типы для значений <em>x</em> и <em>y</em>, тогда будет выполнена операция <a href="#samevaluenonnumber"><strong>SameValueNonNumber(x, y)</strong></a>.</li>
                   
               </ol>
               
               <p>Отличается от <a href="#samevalue"><strong>SameValue</strong></a> в обращении с нулями и <strong>NaN</strong>.</p>
               
           </article>
           
           <article id="relation_compare">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison">Относительное сравнение</a></h4>
                   
               </header>
               
               <p>Здесь, в общем, происходит сравнение одного значения с другим в плане "ху ис биггер": <em>x &#60; y</em> (или <em>x &#62; y</em>). Возвращается <strong>true</strong>, <strong>false</strong> или <strong>undefined</strong>. Эта операция дополнительно имеет булевский индикатор состояния <em>LeftFirst</em> в качестве параметра, который контролирует порядок выполнения операций над значениями <em>x</em> и <em>y</em>. В EcmaScript вычисление происходят слева направо и по дефолту <em>LeftFirst</em> принимает значение <strong>true</strong> (в этом случае сначала обработается тот параметр, что слева в выражении - <em>x</em>). Бывает и такое, что параметр <em>LeftFirst</em> имеет значение <strong>false</strong>, и в этом случае под внимание попадают сперва те параметры, что справа в выражении (т.е. сначала будет выполнен весь комплекс необходимых событий над параметром <em>y</em> и только потом над <em>x</em>). Алгоритм тут таков (и представлен он для выражения <em>x &#60; y</em>, так что обратный знак вернет другой результат):</p>
               
               <ol class="list">
                   
                   <li>Сначала смотрит, какое значение имеет <em>LeftFirst</em>. Если <strong>true</strong>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>первым под раздачу попадает параметр <em>x</em>, который будет приведен к примитивному значению <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(x, hint Number)</strong></a> (<em>px</em>);</li>
                           
                           <li>и только потом параметр <em>y</em>, который также преобразовывается в примитивное значение <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(y, hint Number)</strong></a> (<em>py</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>А если <strong>false</strong>, тогда
                   
                       <ol class="list" type="a">
                           
                           <li>первым обращенным в примитивное значение будет параметр <em>y</em> <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(y, hint Number)</strong></a> (<em>py</em>);</li>
                           
                           <li>затем параметр <em>x</em> <span>&#8594;</span> <a href="#toprimitive"><strong>ToPrimitive(x, hint Number)</strong></a> (<em>px</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если случилось так, что полученные примитивные значения для <em>x</em> и <em>y</em> (<em>px</em> и <em>py</em> соответственно) строки (предполагается, что эти строки имеют уже нормализированную форму, дабы не вкатываться в дебри Юникода), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>если строка <em>y</em> (<em>py</em>) это приставка значения <em>x</em> (<em>px</em>), вернется <strong>false</strong>;</li>
                           
                           <li>если строка <em>x</em> (<em>px</em>) это приставка <em>y</em> (<em>py</em>), вернется <strong>true</strong>;</li>
                           
                           <li>если же ни одна из полученных строк не является приставкой для другой, значит, под прицел сравнения попадает символ строки, т.е. кодовая единица. Само значение этой кодовой единицы - целое число. И имеет данная кодовая единица наименьший не отрицательный индекс, который одинаковый в каждой из строк. Обязательное условие: под сравнение попадают только те кодовые единицы, что не равны друг другу. Так что, если символ с индексом 0 в кажой строке одинаковый, в оборот пойдет следующий символ с индексом 1 и тд. Поэтому, если целочисловое значение конкретной по индексу кодовой единицы в строке <em>x</em> (<em>px</em>) больше, или меньше, чем в строке <em>y</em> (<em>py</em>), тогда получим соответсвующий результат на выходе. Типа, вот кодовая единица строки <em>x</em> (<em>px</em>) - это <em>m</em>, а для строки <em>y</em> (<em>py</em>) - <em>n</em>. И, если действительно <em>m &#60; n</em>, тогда вернется <strong>true</strong> (в противном случае - <strong>false</strong>). К примеру, выражение <em>"ab" &#60; "az"</em> вернет <strong>true</strong>, поскольку символы <em>"а"</em> одинаковые и сравнение поднимется индексом выше, пока не найдет такие элементы строки, что не равны друг другу (как <em>"b"</em> и <em>"z"</em>). Если не найдет и обе строки одинаковые, будет <strong>false</strong>. И, кстати, операция сравнения заканчивается на первом попавшемся символе, что не равен другому. Т.е. выражение <em>"abz" &#60; "az"</em> вернет <strong>true</strong>, поскольку состыковка произошла с символами <em>"b"</em> и <em>"z"</em>, и <em>"z"</em> победил.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li> Если же полученные примитивные значения для <em>x</em> и <em>y</em> не строки, тогда
                       
                       <ol class="list" type="a">
                          
                           <li> примитивное значение для <em>x</em> (<em>px</em>) будет преобразовано в число <span>&#8594;</span> <a href="#tonumber"><strong>ToNumber(px)</strong></a> (<em>nx</em>);</li>
                           
                           <li>и примитивное значение <em>y</em> (<em>py</em>) тоже <span>&#8594;</span> <a href="#tonumber"><strong>ToNumber(py)</strong></a> (<em>ny</em>);</li>
                           
                           <li>если число <em>x</em> (<em>nx</em>) это <strong>NaN</strong>, вернется <strong>undefined</strong> (то же самое и для числа <em>y</em> (<em>ny</em>), если оно <strong>NaN</strong>);</li>
                           
                           <li>если числовое значение <em>x</em> (<em>nx</em>) такое же, как и <em>y</em> (<em>ny</em>), вернется <strong>false</strong>; </li>
                           
                           <li>если значение <em>x</em> (<em>nx</em>) это <strong>+0</strong>, а <em>y</em> (<em>ny</em>) - это <strong>-0</strong>, вернется <strong>false</strong> (и, если махнуть нули наоборот, тоже <strong>false</strong>);</li>
                           
                           <li>если значение <em>x</em> (<em>nx</em>) это <strong>+&#8734;</strong>, вернется <strong>false</strong>; а если <em>y</em> (<em>ny</em>) - это <strong>+&#8734;</strong>, вернется <strong>true</strong>;</li>
                           
                           <li>если же значение <em>x</em> (<em>nx</em>) это <strong>-&#8734;</strong>, вернется <strong>true</strong>; а если <em>y</em> (<em>ny</em>) - это <strong>-&#8734;</strong>, вернется <strong>false</strong>;</li>
                           
                           <li>и если математическое значение <em>x</em> (<em>nx</em>) меньше <em>y</em> (<em>ny</em>) - они оба конечные и не нули, - вернется <strong>true</strong>. В противном случае - <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
               </ol>
               
           </article>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-operations-on-objects">Операции над объектами</a></h3>
               
           </header>
           
           <article id="get-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-get-o-p">Get ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы извлечь значение определенного свойства (<em>P</em>) объекта (<em>O</em>). И ключ свойства (<em>P</em>), и объект (<em>O</em>) передаются ей в качетсве аргументов. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>И ей всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get"><strong>[[Get]]</strong></a> <span>&#8594;</span> <strong>O.[[Get]](P, O)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="getv-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getv">GetV ( V, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы извлечь значение определенного свойства (<em>P</em>) значения EcmaScript (<em>V</em>). И если это значение EcmaScript не объект, тогда поиск свойства выполняется, используя объектную оболочку, что соответствует типу значения. Ключ свойства (<em>P</em>) и значение EcmaScript (<em>V</em>) передаются ей в качетсве аргументов. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Ей всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Чтобы выполнить поиск свойства, необходимо создать объектную оболочку (<em>O</em>) для значения (<em>V</em>) <span>&#8594;</span> <a href="#toobject"><strong>ToObject(V)</strong></a>.</li>
                   
                   <li>Дальше выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get"><strong>[[Get]]</strong></a> <span>&#8594;</span> <strong>O.[[Get]](P, V)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="set-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-o-p-v-throw">Set ( O, P, V, Throw )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы записать значение определенного свойства (<em>P</em>) объекта (<em>O</em>). И аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>), новое значение для свойства (<em>V</em>) и булевский флаг (<em>Throw</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>И флагу (<em>Throw</em>) передается только булевское значение (<strong>Type(Throw)</strong> <span>&#8594;</span> <em>Boolean</em>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-set"><strong>[[Set]]</strong></a> <span>&#8594;</span> <strong>O.[[Set]](P, V, O)</strong> (<em>succes</em>).</li>
                   
                   <li>Если запись нового значение (<em>success</em>) не прошла успешно, вернув <strong>false</strong>, а булевский флаг получил значение <strong>true</strong>, тогда вылетит <strong>TypeError</strong> (этот булевский флаг получает соответствующие значения в зависимости от того, в каком режиме выполняется код: если в строгом, тогда он получит <strong>true</strong>, а если нет - <strong>false</strong>).</li>
                   
                   <li>В остальных случаях вернется результат выполнения записи (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="create_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdataproperty">CreateDataProperty ( O, P, V )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Создается описание нового свойства (<em>newDesc</em>), поля которого получают такие значения <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Затем выполняетмя внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>Эта абстрактная операция создает свойство, чьи атрибуты записываются к тем же значениям по умолчанию, что используются для свойств, которые создаются оператором назначения в EcmaScript. В нормальных условиях, такого свойста еще не существует. А если оно существует, и это существующее свойство не изменяемое (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>) или объект не расширяемый (<strong><a href="#internal-isextensible">[[IsExtensible]]</a>: false</strong>), <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> вернет <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createmethodproperty">CreateMethodProperty ( O, P, V )</a></h4>
                   
               </header>
            
               <p>Очень похоже на <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a>, только есть ньюансы. Эта операция тоже используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Важный момент: данное свойство является здесь методом. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Создается описание нового свойства (<em>newDesc</em>), поля которого получают такие значения <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: false, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Затем выполняетмя внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>Эта абстрактная операция создает свойство, чьи атрибуты записывются к тем же значениям по умолчанию, которые используются для встроенных методов и методов, определенных с помощью синтаксиса классов. В нормальных условиях, такого свойства еще не существует. А если он существует, и он не изменяемый (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>) или объект не расширяемый (<strong><a href="#internal-isextensible">[[IsExtensible]]</a>: false</strong>), <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> вернет <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow ( O, P, V )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать новое собственное свойство (<em>P</em>) объекта (<em>O</em>). Она выкидывает <strong>TypeError</strong>, если создание нового свойства не может быть выполнено. Аргументами тут выступают целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и значение для свойства (<em>V</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется <a href="#create_prop-abstr"><strong>CreateDataProperty ( O, P, V )</strong></a> (<em>success</em>).</li>
                   
                   <li>Если <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит недовольный <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#create_prop-abstr"><strong>CreateDataProperty</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="define_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-definepropertyorthrow">DefinePropertyOrThrow ( O, P, desc )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы вызвать внутренний метод (<em>P</em>) объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> таким способом, что выкинет <strong>TypeError</strong>, если свойство нельзя обновить. Аргументы здесь это: целевой объект (<em>O</em>), ключ свойства (<em>P</em>) и описание свойства (<em>desc</em>). Семантика этой операции такая, что при существовании уже такого свойства с определенным ключом (<em>P</em>) он заменяется или затеняется новым, который создается. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[DefineOwnProperty]](P, desc)</strong> (<em>success</em>).</li>
                   
                   <li>Если <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#internal-define_prop_o"><strong>[[DefineOwnProperty]]</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="delete_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-deletepropertyorthrow">DeletePropertyOrThrow ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы убрать определенное собственное свойство (<em>P</em>) объекта (<em>O</em>). Выкинет <strong>TypeError</strong>, если свойство не изменяемое (<a href="#config_attr">[[Configurable]]</a>: false). В качестве аргументов тут целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-delete"><strong>[[Delete]]</strong></a> <span>&#8594;</span> <strong>O.[[Delete]](P)</strong> (<em>success</em>).</li>
                   
                   <li>Если <a href="#internal-delete"><strong>[[Delete]]</strong></a> (<em>success</em>) вернет <strong>false</strong>, тогда вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#internal-delete"><strong>[[Delete]]</strong></a> (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="get_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getmethod">GetMethod ( V, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы получить значение, ожидаемое как функция, определенного свойства (<em>P</em>) значения EcmaScript (<em>V</em>). Для значения EcmaScript используется объектная оболочка определенного типа значения. Вызывается она с такими аргументами, как значение EcmaScript (<em>V</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется операция <a href="#getv-abstr"><strong>GetV(V, P)</strong></a> (<em>func</em>).</li>
                   
                   <li>Если полученный результат <a href="#getv-abstr"><strong>GetV</strong></a> (<em>func</em>) это либо <strong>undefined</strong>, либо <strong>null</strong>, тогда вернется <strong>undefined</strong>.</li>
                   
                   <li>Затем проверяется, имеет ли то значение, которое вернула операция <a href="#getv-abstr"><strong>GetV</strong></a>, внутренний метод  вызова <a href="#internal-call"><strong>[[Call]]</strong></a> <span>&#8594;</span> <a href="#iscallable-abstr"><strong>IsCallable(func)</strong></a>. Если <a href="#iscallable-abstr"><strong>IsCallable</strong></a> вернула <strong>false</strong>, вылетит <strong>TypeError</strong>.</li>
                   
                   <li>В ином случае вернется результат выполнения <a href="#getv-abstr"><strong>GetV</strong></a> (<em>func</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasproperty">HasProperty ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, имеет ли объект (<em>O</em>) свойство (<em>P</em>) с определенным ключом. Свойство может быть как собственным, так и унаследованным. Вызывается она с такими аргументами, как целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-has_prop"><strong>[[HasProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[HasProperty]](P)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop_o-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasownproperty">HasOwnProperty ( O, P )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, имеет ли объект (<em>O</em>) собственное свойство (<em>P</em>) с определенным ключом. Вызывается она с такими аргументами, как целевой объект (<em>O</em>) и ключ свойства (<em>P</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> <span>&#8594;</span> <strong>O.[[GetOwnProperty]](P)</strong> (<em>desc</em>).</li>
                   
                   <li>Если <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> вернет <strong>undefined</strong>, на выходе получим <strong>false</strong>.</li>
                   
                   <li>В ином случае - <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="call-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-call">Call ( F, V [ , argumentsList ] )</a></h4>
                   
               </header>
               
               <p>Эта операция вызывает внутренний метод объекта функции (<em>F</em>) <a href="#internal-call"><strong>[[Call]]</strong></a>. Вызывается с аргументами, среди которых объект функции (<em>F</em>), значение EcmaScript (<em>V</em>), которое является <strong>this</strong> для внутреннего метода <a href="#internal-call"><strong>[[Call]]</strong></a>, и список (<em>argumentsList</em>) из аргументов функции (<em>F</em>), что является необязательным. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если список (<em>argumentsList</em>) из аргументов функции (<em>F</em>) не был передан, поскольку их нет, тогда новый пустой список (<em>List</em>) будет записан и использоваться как значение (<em>argumentsList</em>) для соответствующего аргумента внутреннего метода <a href="#internal-call"><strong>[[Call]]</strong></a>.</li>
                   
                   <li>Если объект функции (<em>F</em>) не вызываемый (<a href="#iscallable-abstr"><strong>IsCallable(F)</strong></a> <span>&#8594;</span> <strong>false</strong>), вылетит <strong>TypeError</strong>.</li>
                   
                   <li>Когда все норм, выполняется внутренний метод объекта функции (<em>F</em>) <a href="#internal-call"><strong>[[Call]]</strong></a> <span>&#8594;</span> <strong>F.[[Call]](V, argumentsList)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="constr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-construct">Construct ( F [ , argumentsList [ , newTarget ]] )</a></h4>
                   
               </header>
               
               <p>Эта операция вызывает внутренний метод объекта функции (<em>F</em>) <a href="#internal-constr"><strong>[[Construct]]</strong></a>. Вызывается с аргументами, среди которых объект функции (<em>F</em>), список из аргументов функции (<em>F</em>) и целевой объект, к которому применяется оператор <strong>new</strong> (<em>newTarget</em>). Последние два аргумента для метода <a href="#internal-constr"><strong>[[Construct]]</strong></a> не являются обязательными. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если целевой объект (<em>newTarget</em>) не был передан, тогда объект функции (<em>F</em>) записывается как целевой (<em>newTarget</em>) и используется как значение для соответствующего аргумента внутреннего метода <a href="#internal-construct"><strong>[[Construct]]</strong></a>.</li>
                   
                   <li>Если список (<em>argumentsList</em>) из аргументов функции (<em>F</em>) не был передан, поскольку их нет, тогда новый пустой список (<em>List</em>) будет записан и использоваться как значение (<em>argumentsList</em>) для соответствующего аргумента внутреннего метода <a href="#internal-construct"><strong>[[Construct]]</strong></a>.</li>
                   
                   <li>Объект функции имеет внутренний метод <a href="#internal-construct"><strong>[[Construct]]</strong></a> (<a href="#isconstr-abstr"><strong>IsConstructor(F)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Целевой объект функции тоже имеет внутренний метод <a href="#internal-construct"><strong>[[Construct]]</strong></a> (<a href="#isconstr-abstr"><strong>IsConstructor(newTarget)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Выполняется внутренний метод объекта функции (<em>F</em>) <a href="#internal-construct"><strong>[[Construct]]</strong></a> <span>&#8594;</span> <strong>F.[[Construct]](argumentsList, newTarget).</strong>.</li>
                   
               </ol>
               
               <p>В случае, когда значение целевого объекта (<em>newTarget</em>) не было передано <a href="#constr-abstr"><strong>Construct</strong></a>, тогда эта операция эквивалентна <strong>new F(...argumentsList)</strong>.</p>
               
           </article>
           
           <article id="set_integr_level-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-setintegritylevel">SetIntegrityLevel ( O, level )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы зафиксировать набор собственных свойств объекта (<em>O</em>). Ей в аргументах передаются объект (<em>O</em>) и уровень надежности (<em>level</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Уровень надежности (<em>level</em>) получает только два значения: <strong>"sealed"</strong> (изолированный) и <strong>"frozen"</strong> (неизменный).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-prev_exts"><strong>[[PreventExtensions]]</strong></a>, что делает объект нерасширяемым <span>&#8594;</span> <strong>O.[[PreventExtensions]]()</strong> (<em>status</em>).</li>
                   
                   <li>Если сделать объект нерясширяемым не получилось (<strong>O.[[PreventExtensions]]()</strong> <span>&#8594;</span> <strong>false</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если же получилось, тогда следом выполняется внутренний метод объекта (<em>O</em>) <a href="internal-prop_keys_o"><strong>[[OwnPropertyKeys]]</strong></a>, что вернет список собственных свойств <span>&#8594;</span> <strong>O.[[OwnPropertyKeys]]()</strong> (<em>keys</em>).</li>
                   
                   <li>Если эта операция имеет изолированный уровень надежности (<em>level</em> <span>&#8594;</span> <strong>"sealed"</strong>), тогда для каждого элемента (<em>k</em>) списка свойств (<em>keys</em>) будет выполнена операция <a href="#define_prop_throw-abstr"><strong>DefinePropertyOrThrow(O, k, PropertyDescriptor{[[Configurable]]: false})</strong></a>.</li>
                   
                   <li>В случае, когда эта операция имеет неизменный уровень надежности (<em>level</em> <span>&#8594;</span> <strong>"frozen"</strong>), тогда для каждого элемента (<em>k</em>) списка свойств (<em>keys</em>) будет
                   
                       <ol class="list" type="a">
                           
                           <li>выполнен внутренний метод объекта (<em>O</em>) <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a>, что возвращает описание свойства <span>&#8594;</span> <strong>O.[[GetOwnProperty]](k)</strong> (<em>currentDesc</em>).</li>
                           
                           <li>если <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> не вернул <strong>undefined</strong>,
                           
                               <ol class="list" type="i">
                                   
                                   <li>и если элемент (<em>k</em>) списка свойств (<em>keys</em>) является свойством доступа, что имеет атрибут <a href="#get_attr"><strong>[[Get]]</strong></a>, или <a href="#set_attr"><strong>[[Set]]</strong></a>, или оба (<a href="https://www.ecma-international.org/ecma-262/#sec-isaccessordescriptor"><strong>IsAccessorDescriptor ( Desc )</strong></a>) <span>&#8594;</span> <strong>true</strong>), тогда атрибут изменяемости (<strong>[[Configurable]]</strong>) в описании этого свойства получит значение <strong>false</strong> <span>&#8594;</span> <strong>PropertyDescriptor{[[Configurable]]: false}</strong> (<em>desc</em>);</li>
                                   
                                   <li>в ином случае, когда элемент (<em>k</em>) списка свойств (<em>keys</em>) не является свойством доступа (<a href="https://www.ecma-international.org/ecma-262/#sec-isaccessordescriptor"><strong>IsAccessorDescriptor ( Desc )</strong></a>) <span>&#8594;</span> <strong>false</strong>), атрибутам записываемости (<strong>[[Writable]]</strong>) и изменяемости (<strong>[[Configurable]]</strong>) в описании свойства будут записаны такие значения  <span>&#8594;</span> <strong>PropertyDescriptor { [[Configurable]]: false, [[Writable]]: false }</strong> (<em>desc</em>).</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Далее будет выполнена операция <a href="#define_prop_throw-abstr"><strong>DefinePropertyOrThrow(O, k, desc)</strong></a>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>В остальном вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="test_integr_level-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-testintegritylevel">TestIntegrityLevel ( O, level )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, является ли набор собственных свойств объекта зафиксированным. Ей в аргументах передаются объект (<em>O</em>) и уровень надежности (<em>level</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Уровень надежности (<em>level</em>) получает только два значения: <strong>"sealed"</strong> (изолированный) и <strong>"frozen"</strong> (неизменный).</li>
                   
                   <li>Выполняется операция <a href="#isextensible-abstr"><strong>IsExtensible</strong></a>, что проверяет, расширяемый ли объект (<em>O</em>) <span>&#8594;</span> <strong>IsExtensible(O)</strong> (<em>status</em>).</li>
                   
                   <li>Если объект рясширяемый (<strong>IsExtensible(O)</strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong> (если объект расширяемый, ни одно его свойство не рассматривается).</li>
                   
                   <li>Если же нерасширяемый, далее выполняется внутренний метод объекта (<em>O</em>) <a href="internal-prop_keys_o"><strong>[[OwnPropertyKeys]]</strong></a>, что вернет список собственных свойств <span>&#8594;</span> <strong>O.[[OwnPropertyKeys]]()</strong> (<em>keys</em>).</li>
                   
                   <li>Для каждого элемента (<em>k</em>) списка свойств (<em>keys</em>) будет

                       <ol class="list" type="a">
                           
                           <li>выполнен внутренний метод объекта (<em>O</em>) <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a>, что возвращает описание свойства <span>&#8594;</span> <strong>O.[[GetOwnProperty]](k)</strong> (<em>currentDesc</em>).</li>
                           
                           <li>если <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a> не вернул <strong>undefined</strong>,
                           
                               <ol class="list" type="i">
                                   
                                   <li>а атрибут изменяемости (<strong>[[Configurable]]</strong>) в описании этого свойства имеет значение <strong>true</strong> (<strong>currentDesc.[[Configurable]]</strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>;</li>
                                   
                                   <li>в случае, когда уровень надежности неизменный (<em>level</em> <span>&#8594;</span> <strong>"frozen"</strong>) и элемент (<em>k</em>) списка свойств (<em>keys</em>) является свойством данных (<a href="https://www.ecma-international.org/ecma-262/#sec-isdatadescriptor"><strong>IsDataDescriptor ( Desc )</strong></a>) <span>&#8594;</span> <strong>true</strong>), и если атрибут записываемости (<strong>[[Writable]]</strong>) имеет значение <strong>true</strong> (<strong>currentDesc.[[Writable]]</strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>В остальном вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="create_arr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-createarrayfromlist">CreateArrayFromList ( elements )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать массив, чьи элементы представлены в списке (<em>List</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Элементами (<em>elements</em>) в cписке (<em>List</em>) являются все EcmaScript значения.</li>
                   
                   <li>Создается массив (<em>array</em>) с нулевой длиной <span>&#8594;</span> <a href="#"><strong>ArrayCreate(0)</strong></a>.</li>
                   
                   <li>Далее устанавливается начальный индекс (<em>n</em>), что будет использоваться в качестве ключа свойства массива, начиная с нуля (<em>n = 0</em>).</li>
                   
                   <li>Теперь каждый элемент (<em>e</em>) списка (<em>elements</em>)

                       <ol class="list" type="a">
                           
                           <li>будет использован для создания свойств массива <span>&#8594;</span> <a href="create_prop-abstr"><strong>CreateDataProperty(array, ToString(n), e)</strong></a>.</li>
                           
                           <li>увеличиваем индекс (<em>n</em>) на единицу (<em>n + 1</em>), пока не закончаться все элементы (<em>e</em>) в списке (<em>elements</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Возвращается массив (<em>array</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="create_list-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-createlistfromarraylike">CreateListFromArrayLike ( obj [ , elementTypes ] )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы создать список, чьи элементы представлены проиндексированными свойствами массивоподобного объекта (<em>obj</em>). Среди аргументов есть необязательный, значение которого является списком из EcmaScript типов (<em>elementTypes</em>), которыми могут быть значения элементов. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если типы элементов (<em>elementTypes</em>) не переданы, тогда этот список будет выглядеть так: <strong>« Undefined, Null, Boolean, String, Symbol, Number, Object »</strong>.</li>
                   
                   <li>Если эта операция применяется не к объекту (<em>obj</em>), выкинет <strong>TypeError</strong> (<strong>Type(obj)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>Выполняется операция, чтобы определить длину объекта (<em>len</em>) <span>&#8594;</span> <a href="#tolength-abstr"><strong>ToLength(Get(obj, "length"))</strong></a>.</li>
                   
                   <li>Теперь создается новый пустой список (<em>list</em>).</li>
                   
                   <li>Устанавливается индекс (<em>index</em>), начиная с нуля (<em>index = 0</em>).</li>
                   
                   <li>Теперь повторяем комплекс операций, что ниже, пока <em>index <span>&#60;</span> len</em>
                       
                       <ol class="list">
                          
                           <li>Индекс преобретает корректное имя (<em>indexName</em>) в виде строки <span>&#8594;</span> <a href="#tostring-abstr"><strong>ToString(index)</strong></a>.</li>
                           
                           <li>Затем извлекается значение (<em>next</em>) за полученным ключом <a href="get-abstr"><strong>Get(obj, indexName)</strong></a>.</li>
                           
                           <li>Если тип полученного значения (<em>next</em>) не принадлежит к списку типов (<em>elementTypes</em>), выкинет <strong>TypeError</strong> (<strong>Type(next)</strong> не <span>&#8594;</span> <em>elementTypes</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                           
                           <li>Полученное значение (<em>next</em>) добавляется в список (<em>list</em>), как поледний элемент.</li>
                           
                           <li>Затем индекс (<em>index</em>) увеличивается на единицу (<em>index + 1</em>).</li>
                           
                       </ol>
                       
                   </li>
                   
                   <li>Возвращается список (<em>list</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="invoke-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-invoke">Invoke ( V, P [ , argumentsList ] )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы вызвать метод EcmaScript значения. Аргументы тут точка поиска для свойства, которая заодно и <strong>this</strong> значение (<em>V</em>), ключ свойства (<em>P</em>) и необязательный список значений для аргументов, что передаются методу (<em>argumentsList</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Всегда передается корректный ключ свойства (<a href="#ispropkey"><strong>IsPropertyKey(P)</strong></a> <span>&#8594;</span> <strong>true</strong>).</li>
                   
                   <li>Если список значений для аргументов (<em>argumentsList</em>) не был передан, тогда новый пустой список будет использоваться как его значение.</li>
                   
                   <li>Выполняется операция, чтобы извлечь значение свойства (<em>P</em>) <span>&#8594;</span> <a href="#getv-abstr"><strong>GetV(V, P)</strong></a> (<em>func</em>).</li>
                   
                   <li>Вслед за ней выполняется операция вызова <span>&#8594;</span> <a href="#сфдд-abstr"><strong>Call(func, V, argumentsList)</strong></a>.</li>
                   
               </ol>
               
           </article>
           
           <article id="ord_has_inst-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinaryhasinstance">OrdinaryHasInstance ( C, O )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы определить, наследывает ли объект (<em>O</em>) экземпляр, который предоставляется конструктором (<em>C</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Проверяется, является ли конструктор (<em>C</em>) функцией <span>&#8594;</span> <a href="#iscallable-abstr"><strong>IsCallable(C)</strong></a>. Если нет (результат <strong>false</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Затем выполняется проверка того, имеет ли конструктор (<em>C</em>) внутренний слот <strong>[[BoundTargetFunction]]</strong>. Если имеет, тогда будет выполнена операция для определения того, наследуется ли объект (<em>O</em>) от конструктора, которым будет значение данного слота <span>&#8594;</span> <strong>C.[[BoundTargetFunction]]</strong> (<em>BC</em>) <span>&#8594;</span> <a href="#"><strong>InstanceofOperator(O, BC)</strong></a>.</li>
                   
                   <li>После этого рассматривается значение, что передается в качестве объекта (<em>O</em>). Если оно не имеет соответствующий тип <em>Object</em>, вернется <strong>false</strong> <span>&#8594;</span> <strong>Type(O)</strong>.</li>
                   
                   <li>Далее выполняется операция, которая извлекает значение свойства <strong>prototype</strong> конструктора (<em>C</em>) <span>&#8594;</span> <a href="#get-abstr"><strong>Get(C, "prototype")</strong></a> (<em>P</em>).</li>
                   
                   <li>Если значение (<em>P</em>), полученное на предыдущем этапе не объект, вылетит <strong>TypeError</strong> <span>&#8594;</span> <strong>Type(P)</strong>.</li>
                   
                   <li>Теперь будет выполнен внутренний метод, что определяет прототип объекта (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_proto">[[GetPrototypeOf]]()</a></strong> (<em>O</em>).</li>
                   
                   <li>Если полученное значение это <strong>null</strong>, тогда вернется <strong>false</strong>.</li>
                   
                   <li>Напоследок выполняется операция сравнения прототипов объекта (<em>O</em>) и конструктора (<em>P</em>) <span>&#8594;</span> <a href="#samevalue-abstr"><strong>SameValue(P, O)</strong></a>.</li>
                   
               </ol>
               
           </article>
           
           <article id="spec_constr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-speciesconstructor">SpeciesConstructor ( O, defaultConstructor )</a></h4>
                   
               </header>
               
               <p>Эта операция используется, чтобы извлечь конструктор для создания объектов, которые явлются производными от объекта (<em>O</em>) в аргументе. Дэфолтный конструктор, что передается в другом аргументе (<em>defaultConstructor</em>), используется в том случае, когда конструктор в свойстве <em>@@species</em> не может быть обнаружен, начиная с объекта в аргументе (<em>O</em>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Этой операции всегда передается объект (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Извлекается конструктор объекта (<em>O</em>) <span>&#8594;</span> <a href="#get-abstr"><strong>Get(O, "constructor")</strong></a> (<em>C</em>).</li>
                   
                   <li>Если полученный конструктор (<em>C</em>) это <strong>undefined</strong>, вернется дэфолтный конструктор (<em>defaultConstructor</em>).</li>
                   
                   <li>И если этот полученный конструктор (<em>C</em>) не объект, выкинет <strong>TypeError</strong> <span>&#8594;</span> <strong>Type(C)</strong>.</li>
                   
                   <li>Далее извлекается функция конструктора (<em>C</em>) <span>&#8594;</span> <a href="#get-abstr"><strong>Get(C, @@species)</strong></a> (<em>S</em>). Символ <em>@@species</em> это свойство, что является функцией конструктора, которая используется для создания производных объектов.</li>
                   
                   <li>Если значение свойства <em>@@species</em> (<em>S</em>) это либо <strong>undefined</strong>, либо <strong>null</strong>, вернется вернется дэфолтный конструктор (<em>defaultConstructor</em>).</li>
                   
                   <li>Выполняется проверка того, имеет ли функция конструктора (<em>S</em>) внутренний метод <a href="#internal-call"><strong>[[Constructor]]</strong></a> <span>&#8594;</span> <a href="#isconstr-abstr"><strong>IsConstructor(S)</strong></a>. Если она <strong>true</strong>, вернется функция конструктора (<em>S</em>).</li>
                   
                   <li>В противном случае выкинет <strong>TypeError</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="enum_prop_o-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-enumerableownproperties">EnumerableOwnProperties ( O, kind )</a></h4>
                   
               </header>
               
               <p>Эта операция возвращает список перечислимых свойств объекта (<em>O</em>), у которых артибут <a href="#enum_attr"><strong>[[Enumerable]]</strong></a> имеет значение <strong>true</strong>. В аргументах ей передаются объект (<em>O</em>) и вид значений элементов списка (<em>kind</em>, которому передаются такие значения: <strong>key</strong>, <strong>value</strong> и <strong>key + value</strong>). Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Данная операция всегда применяется к объектам (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Выполняется внутренний метод объекта (<em>O</em>) <a href="#internal-prop_keys_o"><strong>[[OwnPropertyKeys]]</strong></a>, чтобы получить перечень всех его свойств <span>&#8594;</span> <strong>O.[[OwnPropertyKeys]]()</strong> (<em>ownKeys</em>).</li>
                   
                   <li>Создается новый пустой список (<em>properties</em>), который будет использоваться как хранилище значений, извлекаемых из свойств объекта (<em>O</em>).</li>
                   
                   <li>Для каждого свойства (<em>key</em>) из полученного перечня (<em>ownKeys</em>) выполняется такая последовательность действий:
                   
                       <ol class="list" type="a">
                          
                           <li>Если ключ свойства (<em>key</em>) это строка (<strong>Type(key)</strong> <span>&#8594;</span> <em>String</em>), тогда будет выполнен внутренний метод объекта (<em>O</em>) <a href="#internal-get_prop_o"><strong>[[GetOwnProperty]]</strong></a>, чтобы получить описание (<em>desc</em>) этого свойства (<em>key</em>) <span>&#8594;</span> <strong>O.[[GetOwnProperty]](key)</strong>.</li>
                           
                           <li>Если полученное значение (<em>desc</em>) это не <strong>undefined</strong> и его поле <a href="#enum_attr"><strong>[[Enumerable]]</strong></a> (<em>desc.[[Enumerable]]</em>) имеет значение <strong>true</strong>
                           
                               <ol class="list" type="i">
                                  
                                   <li>И если необходимо выполнить извлечение имен свойств (т.е. аргумент <em>kind</em> получает значение <strong>key</strong>), тогда ключ свойства (<em>key</em>) передается списку, созданному ранее (<em>properties</em>).</li>
                                   
                                   <li>Если же выполняется извлечение не имен ключей свойств, тогда
                                   
                                       <ol class="list" type="I">
                                          
                                           <li>Извлекается значение (<em>value</em>) свойства (<em>key</em>) объекта (<em>O</em>) <span>&#8594;</span> <a href="#get-abstr"><strong>Get(O, key)</strong></a>.</li>
                                           
                                           <li>Затем, если необходимо только значение (<em>value</em>) свойства (т.е. аргумент <em>kind</em> получает значение <strong>value</strong>), тогда оно передается списку (<em>properties</em>).</li>
                                           
                                           <li>В ином случае, когда требуемый вид значений это ни ключ свойства, ни его значение, тогда извлекаются оба (т.е. аргумент <em>kind</em> получает значение <strong>key + value</strong>).
                                           
                                               <ol class="list" type="a">
                                                  
                                                   <li>Далее для каждого свойства (<em>key</em>) объекта (<em>O</em>) будет создан массив (<em>entry</em>), что будет состоять из двух элементов: имени свойства (<em>key</em>) и его значения (<em>value</em>) <span>&#8594;</span> <a href="#create_arr-abstr"><strong>CreateArrayFromList(« key, value »)</strong></a></li>
                                                   
                                                   <li>И потом этот массив (<em>entry</em>) передается списку (<em>properties</em>).</li>
                                                   
                                               </ol>
                                           
                                           </li>
                                           
                                       </ol>
                                   
                                   </li>
                                   
                               </ol>
                           
                           </li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Затем элементы полученного списка (<em>properties</em>) упорядычиваются таким способом, который вернул бы итератор (<em>Iterator</em>) от операции <a href="#"><strong>EnumerateObjectProperties</strong></a> вызванной с объектом (<em>O</em>).</li>
                   
                   <li>Наконец возвращается этот список (<em>properties</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="funct_realm-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getfunctionrealm">GetFunctionRealm ( obj )</a></h4>
                   
               </header>
               
               <p>Эта операция возвращает область текущего контекста выполнения функции (<em>obj</em>). Алгоритм имеет такие этапы:</p>
               
               <ol class="list">
                  
                   <li>Эта операция применяется к вызываемым объектам (<em>obj</em>).</li>
                   
                   <li>Если этот объект (<em>obj</em>) имеет внутренний слот <strong>[[Realm]]</strong>, тогда возвращается его значение <span>&#8594;</span> <strong>obj.[[Realm]]</strong>.</li>
                   
                   <li>Если же данный объект (<em>obj</em>) это связанная функция (<em>Bound Function</em>), что является необычным объектом, тогда
                   
                       <ol class="list" type="a">
                          
                           <li>Извлекается значение слота <strong>[[BoundTargetFunction]]</strong> (<em>target</em>) <span>&#8594;</span> <strong>obj.[[BoundTargetFunction]]</strong>.</li>
                           
                           <li>Затем данное значение будет передано в аргументе текущей операции <span>&#8594;</span> <a href="#funct_realm-abstr"><strong>GetFunctionRealm(target)</strong></a>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>А если данный объект (<em>obj</em>) это прокси-объект (Proxy), что является необычным объектом,
                   
                       <ol class="list" type="a">
                          
                           <li>И если значение внутреннего слота <strong>[[ProxyHandler]]</strong> этого объекта (<em>obj</em>) <strong>null</strong>, тогда выкинет <strong>TypeError</strong> (<strong>obj.[[ProxyHandler]]</strong> <span>&#8594;</span> <strong>null</strong> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                           
                           <li>В ином случае извлекается значение внутреннего слота <strong>[[ProxyHandler]]</strong> (<em>proxyTarget</em>) <span>&#8594;</span> <strong>obj.[[ProxyTarget]]</strong>.</li>
                           
                           <li>Затем полученное значение будет передано в аргументе текущей операции <span>&#8594;</span> <a href="#funct_realm-abstr"><strong>GetFunctionRealm(proxyTarget)</strong></a>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Иначе возвращается запись области текущего контекста выполнения (<em>Realm Record</em>).</li>
                   
               </ol>
               
           </article>
           
       </section>
       
       <section id="iterator_oper-abstr">
           
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-operations-on-iterator-objects">Операции над объектами-итераторами</a></h3>
               
           </header>
           
           <p>Объекты-итераторы еще будут рассматриваться далее, а пока пересмотрим те абстрактные операции, что выполняются над ними.</p>
           
           <article id="get_iter-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-getiterator">GetIterator ( obj [ , method ] )</a></h4>
                   
               </header>
               
               <p>Эта операция возвращает объект-итератор. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если метод (<em>method</em>) объекта (<em>obj</em>), что возвращает итератор не был передан, тогда вместо него будет использован тот метод, который возвращает дэфолтный итератор <span>&#8594;</span> <strong><a href="#get_method-abstr">GetMethod</a>(obj, <a href="#symb_iterator">@@iterator</a>)</strong>.</li>
                   
                   <li>Выполняется вызов этого метода (<em>method</em>) в контексте данного объекта (<em>obj</em>) <span>&#8594;</span> <strong><a href="#call-abstr">Call</a>(method, obj)</strong> (<em>iterator</em>).</li>
                   
                   <li>И если вернувшийся результат (<em>iterator</em>) не является объектом, выкинет <strong>TypeError</strong> (<strong>Type(iterator)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>В ином случае возвращается итератор (<em>iterator</em>).</li>

               </ol>
               
           </article>
           
       </section>
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-executable-code-and-execution-contexts">Выполняемый код и контекст выполнения</a></h2>
           
       </header>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-lexical-environments">Лексическое окружение</a></h3>
               
           </header>
           
           <p>Лексическое окружение основано на вложенной структуре и определяет взаимосвязь идентификаторов с переменными и функциями. Состоит лексическое окружение из соответствующей <a href="#envir_record">записи</a> и ссылки на внешнее лексическое окружение (такой ссылки может и не быть, если лексическое окружение является глобальным). Обычно лексическое окружение связано с такими определенными синтаксическими структурами (элементами) кода, как объявление функции, выражение блока, или условие <em>Catch</em> выражения <em>Try</em>, и каждый раз создается новое лексическое окружение, когда происходит их вычисление.</p>
           
           <p>Запись окружения фиксирует привязки идентификаторов, что создаются внутри области видимости их лексического окружения.</p>
           
           <p>Одно лексическое окружение может находится внутри другого, что формирует логическую вложенность для значений. Лексическое окружение, находясь внутри другого, имеет на него ссылку. </p>
           
           <p>Есть глобальное лексическое окружение, которое не имеет внешнего, поэтому его значением для ссылки на внешнее лексическое окружение будет <strong>null</strong>.</p>
           
           <p>Окружение модуля это лексическое окружение, что содержит привязки для объявлений верхнего уровня модуля, а также импортированные привязки. Внешним окружением модуля является глобальное.</p>
           
           <p>Окружение функции это лексическое окружение, что соответствует вызову объекта функции. Это окружение может установить новую привязку <strong>this</strong>. И также охватывает состояние, которое необходимо, чтобы поддержать вызовы метода <strong>super</strong>.</p>
           
           <section id="envir_record">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-environment-records">Записи окружения</a></h4>
                   
               </header>
               
               <p>Записи окружения есть двух основных видов: декларативные и объектные. Декларативные записи окружения определяют влияние объявлений функций, переменных и условий <em>Catch</em> выражения <em>Try</em>, что непосредственно связывают привязки идентификаторов с ECMAScript значениями. Объектные записи окружения определяют влияние выражения <strong>with</strong>, что связывает привязки идентификаторов со свойствами какого-то объекта. Существует еще глобальные записи окружения, которые используются для глобальных объявлений. Декларативные записи окружения имеют еще два подкласса: записи для функций и модулей.</p>
               
               <p>Есть абстрактные методы, что работают с записями окружения, основной перечень которых наводится в таблице:</p>
               
               <table>
                   <tr>
                       <th>Метод</th>
                       <th>Для чего используется</th>
                   </tr>
                   <tr>
                       <td><strong>HasBinding(N)</strong></td>
                       <td>Определяет, имеет ли запись окружения привязку для определенного имени (<em>N</em>), возвращая булевское значение.</td>
                   </tr>
                   <tr>
                       <td><strong>CreateMutableBinding(N, D)</strong></td>
                       <td>Создает новую изменяемую неинициализированную привязку с определенным именем (<em>N</em>), которой еще не существует, в записи окружения. Еще этот метод принимает булевский идентификатор, который обозначает, может ли привязка быть удалена (<em>D</em>).</td>
                   </tr>
                   <tr>
                       <td><strong>CreateImmutableBinding(N, S)</strong></td>
                       <td>Создает новую неизменяемую неинициализированную привязку с определенным именем (<em>N</em>), которой еще не существует, в записи окружения. Еще этот метод принимает булевский идентификатор, который указывает на строгость привязки (<em>S</em>).</td>
                   </tr>
                   <tr>
                       <td><strong>InitializeBinding(N, V)</strong></td>
                       <td>Записывает значение (<em>V</em>) существующей неиницилизированной привязке с определенным именем (<em>N</em>) в записи окружения и инициализирует ее.</td>
                   </tr>
                   <tr>
                       <td><strong>SetMutableBinding(N, V, S)</strong></td>
                       <td>Записывает новое значение (<em>V</em>) существующей привязке с определенным именем (<em>N</em>) из записи окружения. Привязка с данным именем обычно уже существует (если нет, тогда она создается и инициализируется) и имеет какое-то значение, которое этот метод меняет на другое. Еще этот метод принимает булевский идентификатор, который указывает на строгость привязки (<em>S</em>).</td>
                   </tr>
                   <tr>
                       <td><strong>GetBindingValue(N, S)</strong></td>
                       <td>Возвращает значение (<em>V</em>) существующей привязки с определенным именем (<em>N</em>) из записи окружения. Еще этот метод принимает булевский идентификатор, который указывает на строгость привязки (<em>S</em>).</td>
                   </tr>
                   <tr>
                       <td><strong>DeleteBinding(N)</strong></td>
                       <td>Удаляет привязку с определенным именем (<em>N</em>), что была обозначена для удаления, из записи окружения, возвращая булевское значение.</td>
                   </tr>
                   <tr>
                       <td><strong>HasThisBinding()</strong></td>
                       <td>Определяет, устанавливает ли запись окружения привязку <strong>this</strong>, возвращая булевское значение.</td>
                   </tr>
                   <tr>
                       <td><strong>HasSuperBinding()</strong></td>
                       <td>Определяет, устанавливает ли запись окружения привязку метода <strong>super</strong>, возвращая булевское значение.</td>
                   </tr>
                   <tr>
                       <td><strong>WithBaseObject()</strong></td>
                       <td>Если запись окружения связана с выражением <strong>with</strong>, вернется объект. В ином случае вернется <strong>undefined</strong>.</td>
                   </tr>
               </table>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records">Декларативные</a> записи окружения</h4>
                       
                   </header>
                   
                   <p>Каждая декларативная запись окружения связана с областью видимости программы ECMAScript, что содержит объявления переменной, константы, допущения, класса, модуля, импорта и/или функции. Декларативная запись окружения связывает набор идентификаторов, что определены объявлениями, которые содержаться внутри ее области видимости.</p>
                   
                   <p>Поведение методов для декларативных записей окружения наведено ниже.</p>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasbinding-n">HasBinding ( N )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Если декларативная запись окружения (<em>envRec</em>) имеет привязку за конкретным именем (<em>N</em>), вернется <strong>true</strong>.</li>
                           
                           <li>Иначе вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createmutablebinding-n-d">CreateMutableBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Данная запись окружения (<em>envRec</em>), к которой применяется этот метод, еще не имеет привязки с конкретным именем  (<em>N</em>).</li>
                           
                           <li>Создается изменяемая привязка в записи окружения (<em>envRec</em>) с конкретным именем (<em>N</em>) и регистрируется, как не инициализированная. Эта привязка (<em>N</em>) отмечается и регистрируется в записи окружения (<em>envRec</em>) как удаляемая, если соотвествующему аргументу (<em>D</em>) было передано значение <strong>true</strong> (<em>D</em> <span>&#8594;</span> <strong>true</strong>), и тогда последующий вызов метода <a href="#"><strong>DeleteBinding</strong></a> удалит ее.</li>
                           
                           <li>Далее возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createimmutablebinding-n-s">CreateImmutableBinding ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Данная запись окружения (<em>envRec</em>), к которой применяется этот метод, еще не имеет привязки с конкретным именем  (<em>N</em>).</li>
                           
                           <li>Создается неизменяемая привязка в записи окружения (<em>envRec</em>) с конкретным именем (<em>N</em>) и регистрируется, как не инициализированная. Эта привязка (<em>N</em>) отмечается и регистрируется в записи окружения (<em>envRec</em>) как строгая, если соотвествующему аргументу (<em>S</em>) было передано значение <strong>true</strong> (<em>S</em> <span>&#8594;</span> <strong>true</strong>).</li>
                           
                           <li>Далее возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-initializebinding-n-v">InitializeBinding ( N, V )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Данная запись окружения (<em>envRec</em>), к которой применяется этот метод, имеет неинициализированную привязку с конкретным именем (<em>N</em>).</li>
                           
                           <li>Привязке (<em>N</em>) назначается значение (<em>V</em>) в записи окружения (<em>envRec</em>).</li>
                           
                           <li>Затем она (<em>N</em>) регистрируется как инициализированная в записи окружения (<em>envRec</em>).</li>
                           
                           <li>Далее возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-setmutablebinding-n-v-s">SetMutableBinding ( N, V, S )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Если запись окружения (<em>envRec</em>) не имеет привязки с конкретным именем (<em>N</em>),
                           
                               <ol class="list" type="a">
                                  
                                   <li>И если метод отмечает привязку как строгую (<em>S</em> <span>&#8594;</span> <strong>true</strong>), тогда выкинет <strong>ReferenceError</strong>.</li>
                                   
                                   <li>В случае, когда данный метод не отмечает привязку как строгую, тогда в этой записи окружения (<em>envRec</em>) будет создана изменяемая привязка с соответствующим именем (<em>N</em>), которая отмечена как удаляемая <span>&#8594;</span> <strong>envRec.<a href="#">CreateMutableBinding</a>(N, true)</strong>.</li>
                                   
                                   <li>После этого привязке (<em>N</em>) назначается значение (<em>V</em>) и она инициализируется, что регистрируется в записи окружения (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#">InitializeBinding</a>(N, V)</strong>.</li>
                                   
                                   <li>Возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Если привязка (<em>N</em>) в записи окружения (<em>envRec</em>) отмечается как строгая, тогда соответствующему аргументу (<em>S</em>) записывается значение <strong>true</strong> (<em>S</em> <span>&#8594;</span> <strong>true</strong>).</li>
                           
                           <li>Если привязка (<em>N</em>) в записи окружения (<em>envRec</em>) не была инициализирована, выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>Далее, если привязка (<em>N</em>) в записи окружения (<em>envRec</em>) изменяемая, тогда ей назначается новое значение (<em>V</em>).</li>
                           
                           <li>Если же привязка (<em>N</em>) в записи окружения (<em>envRec</em>) неизменяемая, тогда будет произведена попытка назначить ей новое значение (<em>V</em>), если привязка (<em>N</em>) не строгая (<em>S</em> <span>&#8594;</span> <strong>false</strong>). Вот только значение привязки (<em>N</em>) останется прежним. В случае, когда привязка (<em>N</em>) строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                           
                           <li>Затем возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-getbindingvalue-n-s">GetBindingValue ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Данная запись окружения (<em>envRec</em>), к которой применяется этот метод, имеет инициализированную привязку с конкретным именем (<em>N</em>).</li>
                           
                           <li>Если этот метод применяется к привязке (<em>N</em>), которая не была инициализирована в записи окружения (<em>envRec</em>), выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>Вернется значение (<em>V</em>) привязки (<em>N</em>) в записи окружения (<em>envRec</em>).</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-deletebinding-n">DeleteBinding ( N )</a></h4>
                           
                       </header>
                       
                       <p>Алгоритм:</p>
                       
                       <ol class="list">
                          
                           <li>Данная запись окружения (<em>envRec</em>), к которой применяется этот метод, имеет инициализированную привязку с конкретным именем (<em>N</em>).</li>
                           
                           <li>Если привязка (<em>N</em>) не может быть удалена (не обозначена как удаляемая), вернется <strong>false</strong>.</li>
                           
                           <li>Привязка (<em>N</em>) удаляется из записи окружения (<em>envRec</em>).</li>
                           
                           <li>Возвращается <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Обычная декларативная запись окружения не предоставляет привязки <strong>this</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding">HasSuperBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Обычная декларативная запись окружения не предоставляет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-withbaseobject">WithBaseObject ( )</a></h4>
                           
                       </header>
                       
                       <p>Декларативная запись окружения всегда возвращает <strong>undefined</strong> выражения <strong>with</strong>.</p>
                       
                   </article>
                   
                   <section>
                      
                       <header class="header header--center">
                          
                           <h4><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records">Запись окружения функции</a></h4>
                           
                       </header>
                       
                       <p>Запись окружения функции это декларативная запись окружения, что используется для олицетворения области видимости высшего уровня функции и, если функция не стрелочная (<em>ArrowFunction</em>), предоставляет привязку <strong>this</strong>. Если функция не стрелочная и ссылается на <strong>super</strong>, тогда запись окружения функции содержит еще и состояние, что используется для вызовов метода <strong>super</strong> из функции.</p>
                       
                       <p>Запись окружения функции имеет еще дополнительные поля состояния:</p>
                       
                       <table>
                           <tr>
                               <th>Имя поля</th>
                               <th>Значение</th>
                               <th>Смысловое значение</th>
                           </tr>
                           <tr>
                               <td><em>[[ThisValue]]</em></td>
                               <td>Любое значение ECMAScript</td>
                               <td>Это значение <strong>this</strong>, что используется для вызова функции.</td>
                           </tr>
                           <tr>
                               <td><em>[[ThisBindingStatus]</em></td>
                               <td><strong>"lexical"</strong> | <strong>"initialized"</strong> | <strong>"uninitialized"</strong></td>
                               <td>Если значение здесь <strong>"lexical"</strong>, тогда функция стрелочная, что не имеет локально установленного значения <strong>this</strong>.</td>
                           </tr>
                           <tr>
                               <td><em>[[FunctionObject]]</em></td>
                               <td><em>Object</em></td>
                               <td>Объект функции, вызов которого создает запись окружения.</td>
                           </tr>
                           <tr>
                               <td><em>[[HomeObject]]</em></td>
                               <td><em>Object</em> | <strong>undefined</strong></td>
                               <td>Если связанная функция имеет доступ к свойтсву <strong>super</strong> и не явдяется стрелочной, тогда значением этого поля является объект, от которого эта функция производная и с которым связана, как метод. Дэфолтное значение это <strong>undefined</strong>.</td>
                           </tr>
                           <tr>
                               <td><em>[[NewTarget]]</em></td>
                               <td><em>Object</em> | <strong>undefined</strong></td>
                               <td>Если запись окружения была создана внутренним методом <a href="#internal-construct"><strong>[[Construct]]</strong></a>, тогда значением этого поля является тот объект, к которому применяется параметр вызова <strong>new</strong>.</td>
                           </tr>
                       </table>
                       
                       <p>Запись окружения функции поддерживает все методы декларативной записи окружения с некоторыми отличиями в методах <a href="#"><strong>HasThisBinding</strong></a> и <a href="#"><strong>HasSuperBinding</strong></a>. Плюс к ним еще добавляются дополнительные методы:</p>
                       
                       <table>
                           <tr>
                               <th>Метод</th>
                               <th>Для чего используется</th>
                           </tr>
                           <tr>
                               <td><strong>BindThisValue(V)</strong></td>
                               <td>Назначает значение полю <em>[[ThisValue]]</em> и регистрирует его как инициализированную привязку <strong>this</strong>.</td>
                           </tr>
                           <tr>
                               <td><strong>GetThisBinding()</strong></td>
                               <td>Возвращает значение привязки <strong>this</strong> записи окружения. Выкинет <strong>ReferenceErroe</strong>, если привязка <strong>this</strong> не была инициализирована.</td>
                           </tr>
                           <tr>
                               <td><strong>GetSuperBase()</strong></td>
                               <td>Возвращает объект, что является основой привязки свойства <strong>super</strong> функции в записи окружения. Этот объект извлекается из значения поля <em>[[HomeObject]]</em>. Значение <strong>undefined</strong> указывает, что доступ к свойству <strong>super</strong> будет выдавать ошибки при выполнении.</td>
                           </tr>
                       </table>
                       
                       <p>Поведение дополнительных методов и тех, что отличаются от методов декларативной записи окружения, рассматривается ниже.</p>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-bindthisvalue">BindThisValue ( V )</a></h4>

                           </header>

                           <p>Алгоритм:</p>

                           <ol class="list">

                               <li>Этот метод не используется, когда запись окружения (<em>envRec</em>) создается стрелочной функцией (<em>envRec.[[ThisBindingStatus]]</em> не <span>&#8594;</span> <strong>"lexical"</strong>).</li>

                               <li>Если этот метод используется, когда привязка <strong>this</strong> записи окружения функции (<em>envRec</em>) уже инициализирована, выкинет <strong>ReferenceError</strong> (<em>envRec.[[ThisBindingStatus]]</em> <span>&#8594;</span> <strong>"initialized"</strong> <span>&#8594;</span> <strong>ReferenceError</strong>).</li>

                               <li>Привязке <strong>this</strong> записи окружения функции (<em>envRec</em>) назначается значение <strong>V</strong> (<em>envRec.[[ThisValue]]</em> <span>&#8594;</span> <strong>V</strong>).</li>

                               <li>Далее эта привязка в записи окружения функции (<em>envRec</em>) инициализиурется (<em>envRec.[[ThisBindingStatus]]</em> <span>&#8594;</span> <strong>"initialized"</strong>).</li>

                               <li>Возвращается значение, используемое как <strong>this</strong> (<em>V</em>).</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>

                           </header>

                           <p>Алгоритм:</p>

                           <ol class="list">

                               <li>Если этот метод используется, когда запись окружения (<em>envRec</em>) была создана стрелочной функцией, вернется <strong>false</strong> (<em>envRec.[[ThisBindingStatus]]</em> <span>&#8594;</span> <strong>"lexical"</strong> <span>&#8594;</span> <strong>false</strong>).</li>

                               <li>В ином случае вернется <strong>true</strong>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-hassuperbinding">HasSuperBinding ( )</a></h4>

                           </header>

                           <p>Алгоритм:</p>

                           <ol class="list">

                               <li>Если этот метод используется, когда запись окружения (<em>envRec</em>) была создана стрелочной функцией, вернется <strong>false</strong> (<em>envRec.[[ThisBindingStatus]]</em> <span>&#8594;</span> <strong>"lexical"</strong> <span>&#8594;</span> <strong>false</strong>).</li>

                               <li>Если функция, что создает запись окружения, не имеет объекта, который подтягивает существующая привязка метода <strong>super</strong>, тогда вернется <strong>false</strong> (<em>envRec.[[HomeObject]]</em> <span>&#8594;</span> <strong>undefined</strong> <span>&#8594;</span> <strong>false</strong>). Если же имеет, вернется <strong>true</strong>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-getthisbinding">GetThisBinding ( )</a></h4>

                           </header>

                           <p>Алгоритм:</p>

                           <ol class="list">

                               <li>Этот метод не используется, когда запись окружения (<em>envRec</em>) создается стрелочной функцией (<em>envRec.[[ThisBindingStatus]]</em> не <span>&#8594;</span> <strong>"lexical"</strong>), поскольку она не имеет привязки <strong>this</strong>.</li>

                               <li>Если этот метод используется, когда привязка <strong>this</strong> записи окружения функции (<em>envRec</em>) еще не инициализирована, выкинет <strong>ReferenceError</strong> (<em>envRec.[[ThisBindingStatus]]</em> <span>&#8594;</span> <strong>"uninitialized"</strong> <span>&#8594;</span> <strong>ReferenceError</strong>).</li>
                               
                               <li>Возвращается значение <strong>this</strong> <span>&#8594;</span> <em>envRec.[[ThisValue]]</em>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-getsuperbase">GetSuperBase ( )</a></h4>

                           </header>

                           <p>Алгоритм:</p>

                           <ol class="list">

                               <li>Извлекается объект, который подтягивает привязка метода <strong>super</strong>, функции, что создает запись окружения <span>&#8594;</span> <em>envRec.[[HomeObject]]</em> (<em>home</em>).</li>

                               <li>Если привязка <strong>super</strong> не связывает функцию с объектом, указывая на его отсуствие, вернется <strong>undefined</strong> (<em>envRec.[[HomeObject]]</em> <span>&#8594;</span> <strong>undefined</strong> <span>&#8594;</span> <strong>undefined</strong>).</li>
                               
                               <li>В ином случае, функция будет связана с объектом (<strong>Type(home)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                               
                               <li>Возвращается родитель (прототип) этого объекта <span>&#8594;</span> <strong>home.<a href="#internal-get_proto">[[GetPrototypeOf]]</a>()</strong>.</li>

                           </ol>

                       </article>
                       
                   </section>
                   
                   <section>
                      
                       <header class="header header--center">
                          
                           <h4><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records">Запись окружения модуля</a></h4>
                           
                       </header>
                       
                       <p>Запись окружения модуля это декларативная запись окружения, что используется для олицетворения внешней области видимости модуля ECMAScript. В дополнение к изменяемым и неизменяемым привязкам запись окружения модуля еще предоставляет незменяемые привязки импорта, что дают отдаленный доступ к целевой привязке, которая существует в другой записи окружения.</p>
                       
                       <p>Запись окружения модуля поддерживает все методы, используемые в декларативной записи окружения, с некоторыми изменениями в методах <a href="#"><strong>GetBindingValue</strong></a>, <a href="#"><strong>DeleteBinding</strong></a>, <a href="#"><strong>HasThisBinding</strong></a> и <a href="#"><strong>GetThisBinding</strong></a>. Плюс еще поддерживает дополнительные методы:</p>
                       
                       <table>
                           <tr>
                               <th>Метод</th>
                               <th>Для чего используется</th>
                           </tr>
                           <tr>
                               <td><strong>CreateImportBinding(N, M, N2)</strong></td>
                               <td>Создает в записи окружения своего модуля новую неизменяемую, инициализированную отдаленную привязку, которой еще не существует, с определенным именем (<em>N</em>), что имеет доступ к целевой привязке (<em>N2</em>), которая существует в записи окружения другого модуля (<em>M</em>). Когда осуществляется доступ к значениям новой отдаленной привязки (<em>N</em>), будет получен опосредованный доступ к значениям целевой привязки (<em>N2</em>), поскольку они связаны.</td>
                           </tr>
                           <tr>
                               <td><strong>GetThisBinding()</strong></td>
                               <td>Возвращает значение привязки <strong>this</strong> записи окружения.</td>
                           </tr>
                       </table>
                       
                       <p>Поведение этих методов наводится здесь:</p>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-getbindingvalue-n-s">GetBindingValue ( N, S )</a></h4>
                               
                           </header>
                           
                           <p>Алгоритм:</p>
                           
                           <ol class="list">
                              
                               <li>Привязки записи окружения модуля являются строгими (<em>S</em> <span>&#8594;</span> <strong>true</strong>), потому что модуль это строгий код.</li>
                               
                               <li>Этот метод используется, когда привязка с конкретным именем (<em>N</em>) существует в своей записи окружения модуля (<em>envRec</em>).</li>
                               
                               <li>Если привязка (<em>N</em>) является отдаленной, тогда вернется значение целевой (<em>N2</em>). По порядку:
                               
                                   <ol class="list" type="a">
                                       
                                       <li>Отдаленная привязка имеет доступ к окружению другого модуля (<em>M</em>). Построить такой мост доступа в этом модуле (<em>M</em>) помогает целевая привязка (<em>N2</em>). На нее и ссылается отдаленная (<em>N</em>).</li>
                                       
                                       <li>И если у этого модуля (<em>M</em>) нет никакого окружения (<em>M.[[Environment]]</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>ReferenceError</strong>.</li>
                                       
                                       <li>В ином случае получим запись окружения (<em>targetER</em>) этого модуля (<em>M</em>).</li>
                                       
                                       <li>Затем возвращается значение целевой привязки (<em>N2</em>), что находится в записи окружения другого модуля (<em>targetER</em>) <span>&#8594;</span> <strong>targetER.<a href="#">GetBindingValue</a>(N2, true)</strong>.</li>
                                       
                                   </ol>
                               
                               </li>
                               
                               <li>Если же привязка рассматриваемой записи окружения модуля не является отдаленной, при этом она не инициализирована, тогда вернется <strong>ReferenceError</strong>.</li>
                               
                               <li>Вернется значение (<em>V</em>) привязки (<em>N</em>) записи окружения модуля (<em>envRec</em>).</li>
                               
                           </ol>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-deletebinding-n">DeleteBinding ( N )</a></h4>
                               
                           </header>
                           
                           <p>Метод <a href="#"><strong>DeleteBinding</strong></a> не вызывается к привязкам записи окружения модуля.</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>
                               
                           </header>
                           
                           <p>Запись окружения модуля предоставляет привязку <strong>this</strong>, поэтому вернется <strong>true</strong>.</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-getthisbinding">GetThisBinding ( )</a></h4>
                               
                           </header>
                           
                           <p>Этот метод возвращает <strong>undefined</strong>, что указывает на отсуствие своего значения <strong>this</strong> (значит, модуль подтягивает <strong>this</strong> с того окружения, где его используют).</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-createimportbinding">CreateImportBinding ( N, M, N2 )</a></h4>
                               
                           </header>
                           
                           <p>Алгоритм:</p>
                           
                           <ol class="list">
                              
                               <li>Создаваемой привязки (<em>N</em>) еще не существует в записи окружения модуля (<em>envRec</em>).</li>
                               
                               <li>Существует другой модуль (<em>M</em>) с его окружением (<em>M.[[Environment]]</em>), который напрямую будет иметь целевую привязку (<em>N2</em>).</li>
                               
                               <li>Создается неизменяемая отдаленная привязка в записи окружения своего модуля (<em>envRec</em>) с конкретным именем (<em>N</em>), которая ссылается на другой модуль (<em>M</em>) и целевую привязку в нем (<em>N2</em>), и регистрируется, что новая привязка (<em>N</em>) инициализирована.</li>
                               
                               <li>Затем возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                               
                           </ol>
                           
                       </article>
                       
                   </section>
                   
               </section>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records">Запись окружения объекта</a></h4>
                       
                   </header>
                   
                   <p>Каждая запись окружения объекта связана с объектом привязки. Запись окружения объекта связывает набор имен свойств своего объекта привязки, которые являются именам идентификаторов в виде строки. Ключи свойств, что не являются строкой, не включены в набор связанных идентификаторов. Вместе с собственными свойствами в этот набор также входят унаследованные, независимо от значения  их атрибута <a href="#enum_attr"><strong>[[Enumerable]]</strong></a>. Из-за того, что свойства могут быть динамически добавлены и удалены из объекта, набор индентификаторов, которые связаны записью окружения объекта, могут вероятно меняться, как побочный результат операций, выполняющих добавление или удаление свойств. Поэтому каждая привязка, что была создана в результате таких побочных действий, считается изменяемой привязкой, даже если атрибут <a href="#write_attr"><strong>[[Writable]]</strong></a> соответствующего свойтсва имеет значение <strong>false</strong>. Неизменяемых привязок в записи окружения объекта не существует.</p>
                   
                   <p>Запись окружения объекта, созданная для выражения <strong>with</strong>, может предоставить свой объект привязки как неявно определенное значение <strong>this</strong>, что используется для вызовов функции. Данную возможность контролирует идентификатор, что указывает, используется ли запись окружения объекта для выражения <strong>with</strong> (<em>withEnvironment</em>). Он связан с каждой записью окружения объекта и его дэфолтное значение это <strong>false</strong>.</p>
                   
                   <p>Далее наводится поведение методов записи окружения объекта.</p>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasbinding-n">HasBinding ( N )</a></h4>
                           
                       </header>
                       
                       <p>Определяет, имеет ли объект привязки свойство с конкретным именем (<em>N</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Сначала определяется, имеет ли объект привязки (<em>bindings</em>) конкретное свойство (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(bindings, N)</strong> (<em>foundBinding</em>).</li>
                           
                           <li>Если объект привязки (<em>bindings</em>) этого свойства (<em>N</em>) не имеет (<a href="#has_prop-abstr"><strong>HasProperty</strong></a> <span>&#8594;</span> <strong>false</strong>), вернется <strong>false</strong>.</li>
                           
                           <li>Если запись окружения (<em>envRec</em>) не связана с выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>true</strong>.</li>
                           
                           <li>Если же запись окружения (<em>envRec</em>) связана с выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>true</strong>), выполняется проверка того, находится ли объект привязки в окружении выражения <strong>with</strong> <span>&#8594;</span> <strong><a href="get-abstr">Get</a>(bindings, <a href="#symb_unscop">@@unscopables</a>)</strong> (<em>unscopables</em>).</li>
                           
                           <li>Если получили объект (<strong>Type(unscopables)</strong> <span>&#8594;</span> <em>Object</em>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Будет выполнен поиск искомого свойства (<em>N</em>) среди тех (<em>unscopables</em>), кто не попал в окружение <strong>with</strong>, и затем полученный результат сведется к булевскому значению <strong><a href="#toboolean-abstr">ToBoolean</a>(<a href="#get-abstr">Get</a>(unscopables, N))</strong> (<em>blocked</em>).</li>
                                   
                                   <li>Полученное булевское значение определяет наличие этого свойства в окружении <strong>with</strong>: если оно <strong>true</strong>, вернется <strong>false</strong>.
                                   </li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Когда все проверки были пройдены до этого момента, вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-createmutablebinding-n-d">CreateMutableBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <p>Создает в объекте привязки свойство с конкретным именем (<em>N</em>) и инициализирует его со значением <strong>undefined</strong>. Если привязка отмечена как удаляемая (<em>D</em> <span>&#8594;</span> <strong>true</strong>), тогда атрибуту свойства <a href="#config_attr"><strong>[[Configurable]]</strong></a> назначается значение <strong>true</strong>, и наоборот.</p>
                       
                       <ol class="list">
                          
                           <li>Без особых прелюдий создается свойство в объекте привязки (<em>bindings</em>) с определенным именем (<em>N</em>) и описанием (<em>PropertyDescriptor</em>) <span>&#8594;</span> <strong><a href="#define_prop_throw-abstr">DefinePropertyOrThrow</a>(bindings, N, <a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: undefined, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: D})</strong></li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-createimmutablebinding-n-s">CreateImmutableBinding ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Данный метод не применяется к записи окружения объекта. Все привязки являются здесь изменяемыми.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-initializebinding-n-v">InitializeBinding ( N, V )</a></h4>
                           
                       </header>
                       
                       <p>Назначает значение (<em>V</em>) созданной привязке идентификатора (<em>N</em>), что является свойством объекта привязки.</p>
                       
                       <ol class="list">
                          
                           <li>В записи окружения объекта (<em>envRec</em>) уже должна быть неинициализированная привязка с конкретным именем (<em>N</em>).</li>
                           
                           <li>Регистрирует, что привязка (<em>N</em>) в записи окружения объекта (<em>envRec</em>) инициализирована.</li>
                           
                           <li>Назначает значение (<em>V</em>) привязке (<em>N</em>) в записи окружения объекта (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#">SetMutableBinding</a>(N, V, false)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-setmutablebinding-n-v-s">SetMutableBinding ( N, V, S )</a></h4>
                           
                       </header>
                       
                       <p>Назначает значение (<em>V</em>) свойству объекта привязки с конкретным именем (<em>N</em>). Данное свойство (<em>N</em>) уже существует, а если нет, или оно не поддается записи, тогда обработка ошибок в этом случае определяется значением идентификатора строгости (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Выполняется запись нового значения (<em>V</em>) определенному свойству (<em>N</em>) объекта привязки (<em>bindings</em>) с указанием на строгость данной привязки (<em>S</em>) <span>&#8594;</span> <strong><a href="#set-abstr">Set</a>(bindings, N, V, S)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                    <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-getbindingvalue-n-s">GetBindingValue ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Возвращает значение свойства (<em>N</em>) связанного объекта привязки. Данное свойство (<em>N</em>) уже существует, а если нет,  тогда результат зависит от строгости привязки (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Определяется, существует ли данное свойство (<em>N</em>) в объекте привязки (<em>bindings</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(bindings, N)</strong> (<em>value</em>).</li>
                           
                           <li>Если такого свойства (<em>N</em>) нет (<em>value</em> <span>&#8594;</span> <strong>false</strong>), и если привязка не строгая (<em>S</em> <span>&#8594;</span> <strong>false</strong>), тогда вернется <strong>undefined</strong>; а если привязка строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>А когда такое свойство (<em>N</em>) существует (<em>value</em> <span>&#8594;</span> <strong>true</strong>), будет извлечено его значение <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(bindings, N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-deletebinding-n">DeleteBinding ( N )</a></h4>
                           
                       </header>
                       
                       <p>Удаляет привязки, что соответствуют свойствам объекта окружения, у которых атрибут <a href="#config_attr"><strong>[[Configurable]]</strong></a> имеет значение <strong>true</strong>.</p>
                       
                       <ol class="list">
                          
                           <li>Из своего объекта (<em>bindings</em>) удаляется определенное свойство-привязка (<em>N</em>) <span>&#8594;</span> <strong>bindings.<a href="#internal-delete">[[Delete]]</a>(N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Обычная запись окружения объекта не предоставляет привязки <strong>this</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-hassuperbinding">HasSuperBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Обычная запись окружения объекта не предоставляет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-withbaseobject">WithBaseObject ( )</a></h4>
                           
                       </header>
                       
                       <p>Обычная запись окружения объекта возвращает <strong>undefined</strong> в качестве базового объекта выражения <strong>with</strong>, если только окружение не было создано для этого выражения, на что укажет соответствующий идентификатор (<em>withEnvironment</em>) со значением <strong>true</strong>.</p>
                       
                       <ol class="list">
                          
                           <li>Если окружение было создано для выражения <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>true</strong>), тогда вернется объект привязки для записи окружения (<em>envRec</em>).</li>
                           
                           <li>В ином случае, вернется <strong>undefined</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
               </section>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records">Глобальная запись окружения</a></h4>
                       
                   </header>
                   
                   <p>Глобальная запись окружения олицетворяет внешнюю область видимости, которая разделяется всеми элементами скрипта, что обрабатываются в общей области. Глобальная запись окружения предоставляет привязки для встроенных глобальных объектов, их свойств и для всех объявлений высшего уровня, что возникают внутри скрипта.</p>
                   
                   <p>Гдобальная запись окружения является смесью из записи окружения объекта и декларативной записи окружения. Запись окружения объекта здесь имеет глобальный объект связанной записи области (<em>Realm Record</em>) в качестве основы. Запись окружения объекта как компонент глобальной записи окружения содержит привязки для всех встроенных глобальных объектов и все привязки, введенные объявлениями функции, генератора, асинхронной функции и выражения переменной, что содержаться в глобальном коде. Привязки всех других ECMAScript объявлений в глобальном коде содержаться в декларативной записи окружения, что является компонентом глобальной записи окружения.</p>
                   
                   <p>В глобальном объекте могут быть напрямую созданы свойства, и поэтому запись окружения объекта как компонент может содержать и привязки, что были явно созданы через объявление функции, асинхронной функции, генератора и переменной, а также привязки, созданные неявно, как свойства глобального объекта.</p>
                   
                   <p>В глобальной записи окружения есть дополнительные поля:</p>
                   
                   <table>
                       <tr>
                           <th>Имя поля</th>
                           <th>Значения</th>
                           <th>Для чего используется</th>
                       </tr>
                       <tr>
                           <td><em>[[ObjectRecord]]</em></td>
                           <td>Запись глобального окружения объекта</td>
                           <td>Объект привязки здесь это глобальный объект. Содержит привязки объявления функции, асинхронной функции, генератора и переменной в глобальном коде для связанной области.</td>
                       </tr>
                       <tr>
                           <td><em>[[GlobalThisValue]]</em></td>
                           <td>Объект</td>
                           <td>Значение, которое возвращает <strong>this</strong> в глобальной области видимости.</td>
                       </tr>
                       <tr>
                           <td><em>[[DeclarativeRecord]]</em></td>
                           <td>Декларативная запись глобального окружения</td>
                           <td>Содержит привязки для всех объявлений в глобальном коде для связанной области, кроме привязок объявления функции, асинхронной функции, генератора и переменной.</td>
                       </tr>
                       <tr>
                           <td><em>[[VarNames]]</em></td>
                           <td>Список из элементов в формате строки</td>
                           <td>Имена в формате строки, что привязаны к объявлениям функции, асинхронной функции, генератора и переменной в глобальном коде для связанной области.</td>
                       </tr>
                   </table>
                   
                   <p>Также глобальная запись окружения предоставляет дополнительные методы, которые в ней используются:</p>
                   
                   <table>
                       <tr>
                           <th>Метод</th>
                           <th>Для чего используется</th>
                       </tr>
                       <tr>
                           <td><strong>GetThisBinding()</strong></td>
                           <td>Возвращает значение привязки <strong>this</strong> этой записи окружения.</td>
                       </tr>
                       <tr>
                           <td><strong>HasVarDeclaration (N)</strong></td>
                           <td>Определяет, имеет ли идентификатор (<em>N</em>) в этой записи окружения привязку, что была создана через объявление переменной, генератора, функции и асинхронной функции.</td>
                       </tr>
                       <tr>
                           <td><strong>HasLexicalDeclaration (N)</strong></td>
                           <td>Определяет, имеет ли идентификатор (<em>N</em>) в этой записи окружения привязку, что была создана через лексическое объявление (объявление классов или <em>const</em> и <em>let</em>).</td>
                       </tr>
                       <tr>
                           <td><strong>HasRestrictedGlobalProperty (N)</strong></td>
                           <td>Определяет, является ли имя в аргументе (<em>N</em>) именем свойства глобального объекта, которое не может быть перекрытым глобальной лексической привязкой, являясь ограниченным атрибутом изменяемости.</td>
                       </tr>
                       <tr>
                           <td><strong>CanDeclareGlobalVar (N)</strong></td>
                           <td>Определяет, будет ли успешным вызов соотвествующего метода <strong>CreateGlobalVarBinding</strong> с заданным аргументом (<em>N</em>). Допускаются избыточные объявления переменных и объявления переменных для уже существующих свойств глобального объекта.</td>
                       </tr>
                       <tr>
                           <td><strong>CanDeclareGlobalFunction (N)</strong></td>
                           <td>Определяет, будет ли успешным вызов соотвествующего метода <strong>CreateGlobalFunctionBinding</strong> с заданным аргументом (<em>N</em>).</td>
                       </tr>
                       <tr>
                           <td><strong>CreateGlobalVarBinding(N, D)</strong></td>
                           <td>Используется, чтобы создать привязку (<em>N</em>) глобальной переменной (<strong>var</strong>) и нициализировать ей значение <strong>undefined</strong> в компоненте глобальной записи окружения, что возвращает <em>[[ObjectRecord]]</em>, а также зарегистрировать ее имя (<em>N</em>) в списке имен объявлений <em>[[VarList]]</em>. Привязка (<em>N</em>) будет изменяемой. Соответствующее глобальной переменной <strong>var</strong> свойство глобального объекта будет иметь подходящие значения атрибутов. Если привязка уже сущесвтует, она снова используется и допускается, что инициализирована.</td>
                       </tr>
                       <tr>
                           <td><strong>CreateGlobalFunctionBinding(N, V, D)</strong></td>
                           <td>Используется, чтобы создать привязку (<em>N</em>) глобальной функции (<strong>function</strong>) и инициализировать ей значение (<em>V</em>) в компоненте глобальной записи окружения, что возвращает <em>[[ObjectRecord]]</em>, а также зарегистрировать ее имя (<em>N</em>) в списке имен объявлений <em>[[VarList]]</em>. Привязка (<em>N</em>) будет изменяемой. Соответствующее глобальной функции <strong>function</strong> свойство глобального объекта будет иметь подходящие значения атрибутов. Если привязка уже существует, она заменяется.</td>
                       </tr>
                   </table>
                   
                   <p>Далее наводится поведение конкретных методов глобальной записи окружения.</p>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hasbinding-n">HasBinding ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, существует ли данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если сущесвтует, что ознаменуется значением <strong>true</strong>, тогда вернется <strong>true</strong>.</li>
                           
                           <li>Если же в декларативной записи глобального окружения (<em>DclRec</em>) этой привязки нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже в записи глобального окружения объекта (<em>ObjRec</em>) будет выполнен поиск соответствующей привязки (<em>N</em>) <span>&#8594;</span> <strong>ObjRec.HasBinding(N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-createmutablebinding-n-d">CreateMutableBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <p>Создает изменяемую привязку (<em>N</em>) в декларативной записи глобального окружения.</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                           
                           <li>А если нет, тогда будет создана соответствующая привязка (<em>N</em>) в декларативной записи глобального окружения (DclRec) <span>&#8594;</span> <strong>DclRec.CreateMutableBinding(N, D)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-createimmutablebinding-n-s">CreateImmutableBinding ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Создает неизменяемую привязку (<em>N</em>) в декларативной записи глобального окружения.</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                           
                           <li>А если нет, тогда будет создана соответствующая привязка (<em>N</em>) в декларативной записи глобального окружения (DclRec) <span>&#8594;</span> <strong>DclRec.CreateImmutableBinding(N, S)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-initializebinding-n-v">InitializeBinding ( N, V )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда ей будет назначено соответствующее значение (<em>V</em>) <span>&#8594;</span> <strong>DclRec.InitializeBinding(N, V)</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>. Если привязка существует, при этом в деклаларативной записи глобального окружения ее нет, тогда она должна быть в записи глобального окружения объекта.</li>
                           
                           <li>Привязке (<em>N</em>) в записи глобального окружения объекта (<em>ObjRec</em>) будет инициализировано значение (<em>V</em>) <span>&#8594;</span> <strong>ObjRec.InitializeBinding(N, V)</strong></li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-setmutablebinding-n-v-s">SetMutableBinding ( N, V, S )</a></h4>
                           
                       </header>
                       
                       <p>Если привязка неизменяемая и строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>TypeError</strong>. Если привязки не существует, либо она не поддается записи (<a href="#write_attr"><strong>[[Writable]]</strong></a> <span>&#8594;</span> <strong>false</strong>), тогда обработка ошибок в этом случае будет определена значением строгости (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда ее текущее значение будет изменено на новое (<em>V</em>) <span>&#8594;</span> <strong>DclRec.SetMutableBinding ( N, V, S )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже там привязка (<em>N</em>) получит свое новое значение (<em>V</em>) <span>&#8594;</span> <strong>ObjRec.SetMutableBinding ( N, V, S )</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-getbindingvalue-n-s">GetBindingValue ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Если привязка неинициализирована, выкинет <strong>ReferenceError</strong>. Если привязки не существует, либо она не поддается записи (<a href="#write_attr"><strong>[[Writable]]</strong></a> <span>&#8594;</span> <strong>false</strong>), тогда обработка ошибок в этом случае будет определена значением строгости (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда вернется ее текущее значение <span>&#8594;</span> <strong>DclRec.GetBindingValue ( N, S )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже оттуда будет извлечено значение привязки (<em>N</em>) <span>&#8594;</span> <strong>ObjRec.GetBindingValue ( N, S )</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-deletebinding-n">DeleteBinding ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда удаляется <span>&#8594;</span> <strong>DclRec.DeleteBinding ( N )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Затем из этой записи глобального окружения (<em>ObjRec</em>) берется объект привязки, который является глобальным (<em>globalObject</em>), и в нем выполняется поиск этой привязки (<em>N</em>) как свойства <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если свойство с таким именем (<em>N</em>) сущесвтует в глобальном объекте (<em>globalObject</em>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Эта привязка (<em>N</em>) удаляется из записи глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>ObjRec.DeleteBinding(N)</strong> (<em>status</em>).</li>
                                   
                                   <li>Если удаление привязки (<em>N</em>) было выполнено (<em>status</em> <span>&#8594;</span> <strong>true</strong>),
                                   
                                       <ol class="list" type="i">
                                          
                                           <li>Берется список имен привязок (<em>varNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                                           
                                           <li>И если имя удаленной привязки (<em>N</em>) есть в этом списке (<em>varNames</em>), тогда оно из него также удаляется.</li>
                                           
                                       </ol>
                                   
                                   </li>
                                   
                                   <li>Возвращается булевский результат выполнения операции удаления (<em>status</em>).</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>В том случае, когда такого свойства-привязки (<em>N</em>) в глобальном объекте (<em>globalObject</em>) не существует, вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Глобальное окружение имеет привязку <strong>this</strong>, поэтому вернется <strong>true</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hassuperbinding">HasSuperBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Глобальное окружение не имеет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-withbaseobject">WithBaseObject ( )</a></h4>
                           
                       </header>
                       
                       <p>Выражение <strong>with</strong> не использует глобальный объект, поэтому вернется <strong>undefined</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-getthisbinding">GetThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Вовзращается значение <strong>this</strong> глобального окружения (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.[[GlobalThisValue]]</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasvardeclaration">HasVarDeclaration ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>) переменных и функций, что были объявлены в глобальном окружении (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) есть нужное имя привязки (<em>N</em>), вернется <strong>true</strong>.</li>
                           
                           <li>А если его там нет, вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-haslexicaldeclaration">HasLexicalDeclaration ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется поиск данной привязки (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasrestrictedglobalproperty">HasRestrictedGlobalProperty ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие привязки в качестве свойства с данным именем (<em>N</em>) в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) с помощью метода, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если вместо описания свойства (<em>existingProp</em>) получено <strong>undefined</strong>, тогда такого свойства-привязки нет (<em>N</em>) и вернется <strong>false</strong>.</li>
                           
                           <li>Если же вернулось описание (<em>existingProp</em>) свойства (<em>N</em>), в нем проверяется атрибут <a href="#config_attr"><strong>[[Configurable]]</strong></a>, который определяет, является ли свойство изменяемым. Если этот атрибут имеет значение <strong>true</strong>, значит, свойство изменяемое, и тогда вернется <strong>false</strong> (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a>: true</strong> <span>&#8594;</span> <strong>false</strong>).</li>
                           
                           <li>А когда свойство не изменяемое, а значит, оно с ограничениями, вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                       <p>Глобальная лексическая привязка не может быть создана с тем же именем, что и не настраиваемое свойство глобального объекта. Глобальное свойство <strong>undefined</strong> это его пример.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-candeclareglobalvar">CanDeclareGlobalVar ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется, имеет ли глобальный объект (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязку в качестве свойства с данным именем (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>hasProperty</em>) (<em>hasProperty</em>).</li>
                           
                           <li>Если такое свойство (<em>N</em>) в глобальном объекте (<em>globalObject</em>) есть (<em>hasProperty</em> <span>&#8594;</span> <strong>true</strong>), тогда вернется <strong>true</strong>.</li>
                           
                           <li>Если же такого свойства (<em>N</em>) нет (<em>hasProperty</em> <span>&#8594;</span> <strong>false</strong>), тогда проверяется возможность его добавления в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-candeclareglobalfunction">CanDeclareGlobalFunction ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязки в качестве свойства с данным именем (<em>N</em>) через метод, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если вместо описания свойства (<em>existingProp</em>) получено <strong>undefined</strong>, тогда такого свойства-привязки (<em>N</em>) нет и проверяется возможность его добавления в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong>.</li>
                           
                           <li>Если же вернулось описание (<em>existingProp</em>) свойства (<em>N</em>), в нем проверяется атрибут <a href="#config_attr"><strong>[[Configurable]]</strong></a>, который определяет, является ли свойство изменяемым. Если этот атрибут имеет значение <strong>true</strong>, значит, свойство изменяемое, и вернется <strong>true</strong> (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a>: true</strong> <span>&#8594;</span> <strong>true</strong>).</li>
                           
                           <li>В том случае, когда это свойство (<em>N</em>) неизменяемое (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a>: false</strong>), проверяется, является ли оно свойством данных. Если оно такое (<strong>IsDataDescriptor(existingProp)</strong> <span>&#8594;</span> <strong>true</strong>) и атрибуты записывемости и перечислимости имеют значение <strong>true</strong> (<strong>{<a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true}</strong>), вернется <strong>true</strong>.</li>
                           
                           <li>Если же свойство не изменяемое (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>), не записываемое (<strong><a href="#write_attr">[[Writable]]</a>: false</strong>) и не перечислимое (<strong><a href="#enum_attr">[[Enumerable]]</a>: false</strong>), тогда вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createglobalvarbinding">CreateGlobalVarBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется, имеет ли глобальный объект (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязку глобальной переменной в качестве свойства с данным именем (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>hasProperty</em>).</li>
                           
                           <li>И проверяется возможность добавления этого свойтсва-привязки (<em>N</em>) в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong> (<em>extensible</em>).</li>
                           
                           <li>Если такого свойства-привязки нет (<em>hasProperty</em> <span>&#8594;</span> <strong>false</strong>), при этом глобальный объект расширяемый (<em>extensible</em> <span>&#8594;</span> <strong>true</strong>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Будет создана изменяемая привязка глобальной переменной с данным именем (<em>N</em>) в записи окружения глобального объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>ObjRec.CreateMutableBinding(N, D)</strong>.</li>
                                   
                                   <li>И затем она (<em>N</em>) будет инициализирована без значения <span>&#8594;</span> <strong>ObjRec.InitializeBinding(N, undefined)</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) еще нет имени созданной привязки (<em>N</em>), тогда оно добавляется в него.</li>
                           
                           <li>Создается запись завершения <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>. В случае, когда такое свойство-привязка (<em>N</em>) уже есть (<em>hasProperty</em> <span>&#8594;</span> <strong>true</strong>), или глобальный объект (<em>globalObject</em>) не расширяемый (<em>extensible</em> <span>&#8594;</span> <strong>false</strong>), алгоритм завершит свое выполнение и никакой привязки глобальной переменной в окружении глобального объета создано не будет <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createglobalfunctionbinding">CreateGlobalFunctionBinding ( N, V, D )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязки глоабльной функции в качестве свойства с данным именем (<em>N</em>) через метод, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если такого свойства-привязки (<em>N</em>) в глобальном объекте нет (<em>existingProp</em> <span>&#8594;</span> <strong>undefined</strong>), или есть и это свойство (<em>N</em>) изменяемое (<strong><a href="#config_attr">[[Configurable]]</a>: true</strong>), тогда описание этого свойства-привязки (<em>N</em>) будет изменено к такому виду <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: D}</strong> (<em>desc</em>).</li>
                           
                            <li>Если же свойство-привязка с таким именем (<em>N</em>) существует и оно не настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: true</strong>), будет изменено только значение в описании свойства <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="value_attr">[[Value]]</a>: V}</strong> (<em>desc</em>).</li>
                           
                           <li>Определив, каким будет описание (<em>desc</em>) свойства-привязки глобальной функции, создается новая привязка или меняется существующая с таким именем (<em>N</em>) в глобальном объекте (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#define_prop_or_throw">DefinePropertyOrThrow</a>(globalObject, N, desc)</strong></li>
                           
                           <li>Затем эта привязка (<em>N</em>) регистрируется как инициализированная в окружении глобального объекта (<em>ObjRec</em>).</li>
                           
                           <li>Этому инициализированному свойтсву-привязке (<em>N</em>) в глобальном объекте (<em>globalObject</em>) записывается значение  (<em>V</em>) <strong><a href="#set-abstr">Set</a>(globalObject, N, V, false)</strong>.</li>
                           
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) еще нет имени созданной привязки (<em>N</em>), тогда оно добавляется в него.</li>
                           
                           <li>Создается запись завершения <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>.</li>
                          
                       </ol>
                       
                   </article>
                   
               </section>
               
           </section>
           
       </section>
       
   </section>
    
</body>
</html>