<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ECMAScript</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  
    <header class="header">
        
        <h1> <a href="https://www.ecma-international.org/ecma-262/">ECMAScript 2017</a></h1>
        
    </header>
   
   <section>
       
       <p>ECMAScript это объектно-ориентированный язык программирования. Его программа это набор взаимодействующих объектов. Сам по себе объект это собрание свойств, поведение которых определяют их атрибуты. В свою очередь свойства это контейнеры для других объектов, примитивных значений, или функций. Примитивные значения относится к таким типам в ECMAScript: <em>Undefined</em>, <em>Null</em>, <em>Boolean</em>, <em>Number</em>, <em>String</em> и <em>Symbol</em>. Объекты и функции это представители типа <em>Object</em> в ECMAScript.</p>
       
       <p>Рассмотрим эти типы и их значения.</p>
       
   </section>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-data-types-and-values">Типы данных и значения в ECMAScript</a></h2>
           
       </header>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types">Типы значений в ECMAScript</a></h3>
               
           </header>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-undefined-type">Неопределенный тип (Undefined)</a></h4>

               </header>
               
               <p>Этот тип имеет значение <strong>undefined</strong>, что указывает на отсуствие какого-либо значения.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-null-type">Нулевой тип (Null)</a></h4>

               </header>
               
               <p>Этот тип имеет значение <strong>null</strong>, которое определяется как пустое.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-boolean-type">Булев тип (Boolean)</a></h4>

               </header>
               
               <p>Булев тип представляет логическую сущность и имеет два значения: <strong>true</strong> и <strong>false</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-string-type">Строковый тип (String)</a></h4>

               </header>
               
               <p>Данный тип в основном используется для представления текстовой информации в программе ECMAScript, и в этом случае каждый элемент обрабатывается как значение единицы кода UTF-16 (UTF-16 это кодировка символов Юникода). Элемент занимает конкретную позицию внутри строки. Эти позиции индексируются не отрицательными целыми числами, начиная с нуля: первый элемент будет иметь индекс 0, второй - 1 и тд. Длина строки это общее число элементов, из которых она состоит (пустая строка имеет длину 0).</p>
               
               <p>Операции ECMAScript, интерпретирующие строковые значения, рассматривают каждый элемент как отдельную кодовую точку UTF-16.  Операции, что не интерпретируют контент строки, обрабатывают ее, как универсальную нерасчлененную 16-битную целочисленную переменную без знака.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-symbol-type">Тип для символов (Symbol)</a></h4>

               </header>
               
               <p>Этот тип является набором значений, что могут быть использованы, как ключи свойств объекта. Каждое значение этого типа уникальное и неизменное.</p>
               
               <p>Известные символы, чьи значения расширяют возможности ECMAScript, наводятся в этой <a href="#symbol_table">таблице</a>:</p>
               
               <table id="symbol_table">
                   <caption>Широко-используемые символы</caption>
                   <tr>
                       <th>Сокращенное имя для спецификации</th>
                       <th>Описание ([[Description]])</th>
                       <th>Значение и для чего используется</th>
                   </tr>
                   <tr id="symb_instanse">
                       <td><em>@@hasInstance</em></td>
                       <td><strong>"Symbol.hasInstance"</strong></td>
                       <td>Метод, что определяет, является ли объект экземпляром конструктора. Вызывается семантикой оператора <strong>instanceof</strong>.</td>
                   </tr>
                   <tr id="symb_conc_spread">
                       <td><em>@@isConcatSpreadable</em></td>
                       <td><strong>"Symbol.isConcatSpreadable"</strong></td>
                       <td>Свойство с булевским значением, где <strong>true</strong> определяет, что объект должен быть упорядочен к элементам массива методом <strong>Array.prototype.concat</strong>.</td>
                   </tr>
                   <tr id="symb_iterator">
                       <td><em>@@iterator</em></td>
                       <td><strong>"Symbol.iterator"</strong></td>
                       <td>Метод, что возвращает дэфолтный итератор для объекта. Вызывается семантикой выражения <strong>for-of</strong>.</td>
                   </tr>
                   <tr id="symb_match">
                       <td><em>@@match</em></td>
                       <td><strong>"Symbol.match"</strong></td>
                       <td>Метод, что сопоставляет регулярное выражение со строкой. Вызывается методом <strong>String.prototype.match</strong>.</td>
                   </tr>
                   <tr id="symb_replace">
                       <td><em>@@replace</em></td>
                       <td><strong>"Symbol.replace"</strong></td>
                       <td>Метод, что заменяет совпадающие подстроки строки. Вызывается методом <strong>String.prototype.replace</strong>.</td>
                   </tr>
                   <tr id="symb_search">
                       <td><em>@@search</em></td>
                       <td><strong>"Symbol.search"</strong></td>
                       <td>Метод, что возвращает индекс в строке, который соответствует регулярному выражению. Вызывается методом <strong>String.prototype.search</strong>.</td>
                   </tr>
                   <tr id="symb_species">
                       <td><em>@@species</em></td>
                       <td><strong>"Symbol.species"</strong></td>
                       <td>Метод, значением которого является функция-конструктор, что используется для создания производных объектов.</td>
                   </tr>
                   <tr id="symb_split">
                       <td><em>@@split</em></td>
                       <td><strong>"Symbol.split"</strong></td>
                       <td>Метод, что разделяет строку по индексам, которые соответствуют регулярному выражению. Вызывается методом <strong>  String.prototype.split</strong>.</td>
                   </tr>
                   <tr id="symb_toprim">
                       <td><em>@@toPrimitive</em></td>
                       <td><strong>"Symbol.toPrimitive"</strong></td>
                       <td>Метод, что преобразовывает объект в примитивное значение. Вызывается операцией <a href="#toprim-abstr"><strong>ToPrimitive</strong></a></td>
                   </tr>
                   <tr id="symb_tostring">
                       <td><em>@@toStringTag</em></td>
                       <td><strong>"Symbol.toStringTag"</strong></td>
                       <td>Свойство, значение которого используется в создании дефолтного строкового описания объекта. Вызывается методом <strong>Object.prototype.toString</strong>.</td>
                   </tr>
                   <tr id="symb_unscop">
                       <td><em>@@unscopables</em></td>
                       <td><strong>"Symbol.unscopables"</strong></td>
                       <td>Свойство, значением которого есть объект, чьи собственные и унаследованные имена свойств исключены как привязки из <strong>with</strong> окружения связанного объекта.</td>
                   </tr>
                   
               </table>
               
           </article>
           
           <article>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-number-type">Числовой тип (Number)</a></h4>

                </header>

                <p>Данный тип представляет 64-битные значения формата IEEE 754-2008, и их количество составляет дохера (2<sup>64</sup>-2<sup>53</sup>+3). Среди них есть особенные. Первым особенным значением есть <strong>NaN</strong> (“Not-a-Number”, которое производится программным выражением <strong>NaN</strong>). В коде ECMAScript <em>NaN</em> значения не отличимы друг от друга, при этом некоторые операции позволяют обнаружить разницу между ними, ведь в них разные <em>NaN</em> значения не равны друг другу.</p>

                <p>Еще одними особенными значениями есть позитивная и отрицательная беснонечности, которые изображают с помощью символов <strong>+&#8734;</strong> и <strong>-&#8734;</strong>. Производятся они программными выражениями <strong>+Infinity</strong> (или просто <strong>Infinity</strong>) и <strong>-Infinity</strong> соответственно.</p>

                <p>Остальные значения являются конечными, и половина из них это позитивные значения, а другая - отрицательные. Для каждого конечного числового значения существует соответствющее ему отрицательное по модулю.</p>

                <p>Это коснулось и нуля: он есть позитивный и отрицательный. Выражаются нули символами <strong>+0</strong> и <strong>-0</strong> соответственно и производятся такими же программными выражениями (<strong>+0</strong> (или просто <strong>0</strong>) и <strong>-0</strong>).</p>
                
                <p>Все положительные и отрицательные целые числа, величина которых по модулю не превышает 2<sup>53</sup>, представлены в типе чисел.</p>
               
           </article>
           
            <section>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-type">Объектный тип (Object)</a></h4>

                </header>

                <p>Объект это собрание свойств. Есть свойства данных и свойства доступа:</p>
                
                <ul class="list">
                    
                    <li><em>свойство данных</em> связывает свой ключ со значением ECMAScript и набором соответствующих атрибутов: <a href="#value_attr"><strong>[[Value]]</strong></a> и <a href="#write_attr"><strong>[[Writable]]</strong></a>;</li>
                    
                    <li><em>свойство доступа</em> связывает свой ключ с функциями доступа и набором соответствующих атрибутов: <a href="#get_attr"><strong>[[Get]]</strong></a> и <a href="#set_attr"><strong>[[Set]]</strong></a>. Функция доступа используется для хранения или извлечения ECMAScript значения, которое связывается со свойством.</li>
                    
                </ul>
                
                <p>Свойства идентифицируются с помощью ключей. Ключи используются, чтобы получить доступ к собственным или унаследованным свойствам объекта и их значениям. В качестве ключа свойства выступает либо строка, либо символ ECMAScript. Все строки и символы, включая пустую строку, это корректные ключи свойств. Ключ, что выражает имя свойства, является строкой. Также в качетсве ключей именованных свойств используются индексы, которые выражаются в виде строки, а не чисел, и чьи числовые значения находятся в диапазоне от +0 до 2<sup>53</sup>-1 включительно. В массивах индексы (<em>i</em>) имеют значения в диапазоне +0 <span>&#8804;</span> <em>i</em> <span>&#60;</span> 2<sup>32</sup>-1.</p>
                
                <article>
                    
                    <header class="header header--center">
                        
                        <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-attributes">Атрибуты свойства</a></h4>
                        
                    </header>
                    
                    <p>Атрибуты используются, чтобы определить и объяснить состояние свойств объекта. Свойство данных связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-2">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств данных</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="value_attr">
                           
                            <td>[[Value]] (значение)</td>
                            
                            <td>Любой тип ECMAScript</td>
                            
                            <td>В этом атрибуте хранится значение свойства.</td>
                            
                        </tr>
                        
                        <tr id="write_attr">
                           
                            <td>[[Writable]] (записываемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает, возможно ли записать свойству новое значение, что хранится в атрибуте <a href="#value_attr"><strong>[[Value]]</strong></a>. <strong>false</strong> означает, что изменить значение атрибута <a href="#value_attr"><strong>[[Value]]</strong></a> нельзя.</td>
                            
                        </tr>
                        
                        <tr id="enum_attr">
                           
                            <td>[[Enumerable]] (перечисляемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, перечисляется ли свойство в цыкле. <strong>true</strong> означает, что свойство перечисляется в цыкле <em>for-in</em>. Если <strong>false</strong>, цыкл это свойство пропускает.</td>
                            
                        </tr>
                        
                        <tr id="config_attr">
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, возможно ли изменить свойство, настраивая его соответствующим образом. <strong>false</strong> означает, что удалить свойство, изменить его на свойство доступа, или изменить его атрибуты (кроме <a href="#value_attr"><strong>[[Value]]</strong></a> и <a href="#write_attr"><strong>[[Writable]]</strong></a>, когда его значение меняется на <strong>false</strong>) нельзя.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Свойство доступа связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-3">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств доступа</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="get_attr">
                           
                            <td>[[Get]] (получение)</td>
                            
                            <td>Объект (функция) | Неопределенный тип (Undefined)</td>
                            
                            <td>В этом атрибуте хранится функция доступа, которая вызывается с пустым списком аргументов каждый раз, когда извлекается значения из свойства.</td>
                            
                        </tr>
                        
                        <tr id="set_attr">
                           
                            <td>[[Set]] (запись)</td>
                            
                            <td>Объект (функция) | Неопределенный тип (Undefined)</td>
                            
                            <td>В этом атрибуте хранится функция доступа, которая вызывается со списком аргументов каждый раз, когда присваивается новое значение свойству. Новое значение передается функции в списке аргументов.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Enumerable]] (перечисляемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td><strong>true</strong> означает, что свойство перечисляется в цыкле <em>for-in</em>. Если <strong>false</strong>, цыкл это свойство пропускает.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td><strong>false</strong> означает, тогда удалить свойство, изменить его на свойство данных, или изменить его атрибуты нельзя.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Значения по умолчанию для атрибутов свойств следующие:</p>
                    
                    <table id="default_attr">
                        
                        <caption>Значения атрибутов по умолчанию</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Значение по умолчанию</th>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Записываемый ([[Writable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Перечисляемый ([[Enumerable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Настраиваемый ([[Configurable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Значение ([[Value]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Получение ([[Get]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Запись ([[Set]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                    </table>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4><a href="https://www.ecma-international.org/ecma-262/#sec-object-internal-methods-and-internal-slots">Внутренние</a> методы объектов и слоты (ячейки)</h4>
                        
                    </header>
                    
                    <p>Внутренние методы это алгоритмы, что определяют поведение объектов во время выполнения. Внутренние методы полиморфные, а это означает, что выполняются различные сценарии в алгоритме при вызове такого метода с разными типами значений. Если вызывается внутренний метод, который не поддерживается объектом, тогда программа выкинет ошибку <strong>TypeError</strong>. Внутренний метод возвращает в качестве результата выполнения запись завершения и всегда имеет доступ к целевому объекту.</p>
                    
                    <p>Внутренние слоты соответствуют внутреннему состоянию объекта и используются различными алгоритмами ECMAScript. Эти слоты не наследуются и являются частью создания объекта, при этом они не могут быть добавлены динамически. Внутреннее состояние может состоять из значений любого типа ECMAScript. Начальное значение внутреннего слота это <strong>undefined</strong>. ECMAScript не предоставляет прямого пути, чтобы связать внутренние слоты с объектом.</p>
                    
                    <p><a href="https://www.ecma-international.org/ecma-262/#table-5">Таблица</a> ниже обобщает важные внутренние методы, которые применимы ко всем объектам, что были созданы с помощью кода ECMAScript:</p>
                    
                    <table>
                        
                        <caption>Важные внутренние методы</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-get_proto">
                           
                            <td>[[GetPrototypeOf]]</td>
                            
                            <td>() <span>&#8594;</span> Object | Null</td>
                            
                            <td>Этот метод определяет, какой объект предоставляет наследуемые свойства и возвращает его (иными словами, это прототип). Значение <strong>null</strong> означает, что нет никаких наследуемых свойств, а значит, объект не имеет прототипа.</td>
                            
                        </tr>
                        
                        <tr id="internal-set_proto">
                           
                            <td>[[SetPrototypeOf]]</td>
                             
                            <td>(Object | Null) <span>&#8594;</span> Boolean</td>
                            
                            <td>Этот метод назначает объекту прототип, который предоставляет наследуемые свойства. Значение <strong>null</strong> в аргументе означает, что в цепочке прототипов объекта пополнения не будет. Результат <strong>true</strong> указывает, что объект получил прототип, а <strong>false</strong> - присвоить объекту прототип не получилось.</td>
                            
                        </tr>
                        
                        <tr id="internal-isextensible">
                           
                            <td>[[IsExtensible]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Этот метод определяет, является ли объект расширяемым, а значит, возможно ли добавить ему дополнительные свойства. Результат <strong>true</strong> означает, что объект расширяемый, а <strong>false</strong> - объект нерасширяемый.</td>
                            
                        </tr>
                        
                        <tr id="internal-prev_exts">
                           
                            <td>[[PreventExtensions]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Этот метод делает объект нерасширяемым, а значит, новые свойства не могут быть добавлены в него. Результат <strong>true</strong> означает, что объект стал нерасширяемым, а <strong>false</strong> - объект остался прежним без изменений.</td>
                            
                        </tr>
                        
                        <tr id="internal-get_prop_o">
                           
                            <td>[[GetOwnProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Undefined | Property Descriptor</td>
                            
                            <td>Этот метод возвращает описание (<a href="#prop_descr">Property Descriptor</a>) собственного свойства (<em>propertyKey</em>) объекта, если оно существует. Результат <strong>undefined</strong> означает, что такого свойства в объекте нет.</td>
                            
                        </tr>
                        
                        <tr id="internal-define_prop_o">
                           
                            <td>[[DefineOwnProperty]]</td>
                             
                            <td>(<em>propertyKey, Property Descriptor</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Этот метод создает или меняет собственное свойство (<em>propertyKey</em>) объекта согласно описанию (<a href="#prop_descr">Property Descriptor</a>). Результат <strong>true</strong> означает, что свойство было создано или обновлено, а <strong>false</strong> - существует одно из следующих условий: свойство не настраиваемое (<a href="#config_attr"><strong>[[Configurable]]</strong></a>: <strong>false</strong>), объект не расширяемый (<a href="#internal-isextensible"><strong>[[IsExtensible]]</strong></a> <span>&#8594;</span> <strong>false</strong>) или этого свойства не существует (<a href="#internal-has_prop"><strong>[[HasProperty]]</strong></a> <span>&#8594;</span> <strong>false</strong>).</td>
                            
                        </tr>
                        
                        <tr id="internal-has_prop">
                           
                            <td>[[HasProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Этот метод определяет, имеет ли объект конкретное свойство (<em>propertyKey</em>), которое может быть собственным или унаследованным. Результат <strong>true</strong> означает, что объект имеет такое свойство, а <strong>false</strong> - не имеет.</td>
                            
                        </tr>
                        
                        <tr id="internal-get">
                           
                            <td>[[Get]]</td>
                             
                            <td>(<em>propertyKey, Receiver</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Этот метод извлекает значение свойства (<em>propertyKey</em>) объекта из атрибута <a href="#value_attr"><strong>[[Value]]</strong></a> и возвращает его. Когда необходимо извлечь значение свойства в определенном контексте выполнения, используется <strong>this</strong> (<em>Receiver</em>).</td>
                            
                        </tr>
                        
                        <tr id="internal-set">
                           
                            <td>[[Set]]</td>
                             
                            <td>(<em>propertyKey, value, Receiver</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Этот метод записывает  значение (<em>value</em>), которое находится в атрибуте <a href="#value_attr"><strong>[[Value]]</strong></a>, свойству (<em>propertyKey</em>) объекта. Когда необходимо записать значение свойству в определенном контексте выполнения, используется <strong>this</strong> (<em>Receiver</em>). Результат <strong>true</strong> означает, что свойству было записано данное значение, а <strong>false</strong> - записать новое значение свойству не удалось.</td>
                            
                        </tr>
                        
                        <tr id="internal-delete">
                           
                            <td>[[Delete]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Этот метод удаляет собственное свойство (<em>propertyKey</em>) из объекта. Результат <strong>false</strong> означает, что свойство (<em>propertyKey</em>) не было удалено и все еще находится в объекте, а <strong>true</strong> - свойство было удалено. Если свойство не настраиваемое (<a href="#config_attr"><strong>[[Configurable]]</strong></a>: <strong>false</strong>), тогда удалить его нельзя и результат будет <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr id="internal-prop_keys_o">
                           
                            <td>[[OwnPropertyKeys]]</td>
                             
                            <td>() <span>&#8594;</span> <em>List of properties</em></td>
                            
                            <td>Этот метод возвращает список собственных свойств объекта, где перечислены их ключи.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Существуют еще <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-6">дополнительные</a> внутренние методы для объектов. Объект функции поддерживает внутренний метод вызова <a href="#internal-call"><strong>[[Call]]</strong></a>, а конструктор это функция, что поддерживает внутренний метод построения <a href="#ibternal-construct"><strong>[[Construct]]</strong></a>.</p>
                    
                    <table>
                        
                        <caption>Дополнительные важные внутренние мтоды объектов функции</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr id="internal-call">
                           
                            <td>[[Call]]</td>
                            
                            <td>(<em>any, a List of any</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Этот метод вызывает функцию, запуская выполнение кода внутри нее, которой передается список аргументов (<em>List of any</em>) и <strong>this</strong> (<em>any</em>). Этот метод запускает оператор вызова функции.</td>
                            
                        </tr>
                        
                        <tr id="internal-construct">
                           
                            <td>[[Construct]]</td>
                             
                            <td>(<em>a List of any, Object</em>) <span>&#8594;</span> <em>Object</em></td>
                            
                            <td>Этот метод вызывает функцию, которая производит объект. Значения своих свойств создаваемый объект получает из входящего списка аргументов (<em>List of any</em>). Этот метод запускают операторы вызова конструктора: <strong>new</strong> и <strong>super</strong>. Оператору <strong>new</strong> также передается прототип для производных объектов (<em>Object</em>), который этот метод получает во втором аргументе, что не является обязательным. Функции, что реализовывают этот метод, называются конструкторами.</td>
                            
                        </tr>
                        
                    </table>
                    
                </article>
                
                <p>У внутренних методов есть определенные <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-invariants-of-the-essential-internal-methods">признаки</a>. Также существует еще кучища известных встроенных объектов, и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-well-known-intrinsic-objects">тут</a> дается их перечень.</p>
               
           </section>
           
       </section>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-specification-types">Типы спецификации ECMAScript</a></h3>
               
           </header>
           
           <p>Существуют еще скрытые типы, которые используются алгоритмами языка. Их значения используются внутри алгоритмов для описания семантики конструкций и типов ECMAScript. К скрытым типам относятся Ссылка (Reference), Список (List), Завершение (Completion), Описание свойства (Property Descriptor), Лексическое окружение (Lexical Environment), Запись об окружении (Environment Record) и Блок данных (Data Block). Значения, что относятся к этим типам, являются "артефактами" и не могут хранится в свойствах объекта или в переменных ECMAScript.</p>
           
           <article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-list-and-record-specification-type">Типы списка и записи</a></h4>
                   
               </header>
               
               <p>Этот тип объясняет определение списков из аргументов в выражениях оператора <strong>new</strong>, в вызовах функциий и в других алгоритмах. Список является простой упорядоченной последовательностью элементов, которые содержат конкретные значения.</p>
               
               <p>Тип записи объясняет агрегацию (обьединение) данных внутри алгоритмов. Данный тип содержит одно или более именованных полей со значениями ECMAScript, либо абстрактными значениями. Имена полей используются для определения конкретных разновидностей агрегации.</p>
               
               <article>
               
                   <header class="header header--center">

                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completion-record-specification-type">Запись выполнения</a></h4>

                   </header>

                   <p>Этот тип определяет, как передаются значения среды выполнения, и контролирует поведение инструкций (<strong>break</strong>, <strong>continue</strong>, <strong>return</strong> и <strong>throw</strong>), что выполняют нелокальную передачу контроля.</p>

                   <p>Поля типа записи выполнения и их значения наводятся <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-8">ниже</a>:</p>

                   <table>

                            <caption>Поля записи выполнения</caption>

                            <colgroup>

                                <col />

                                <col />

                            </colgroup>

                            <tr>

                                <th>Поле</th>

                                <th>Значение</th>

                                <th>Смысл</th>

                            </tr>

                            <tr>

                                <td>[[Type]]</td>

                                <td>одно из значений <strong>normal</strong>, <strong>return</strong>, <strong>break</strong>, <strong>continue</strong> или <strong>throw</strong></td>

                                <td>Тип выполнения</td>

                            </tr>

                            <tr>

                                <td>[[Value]]</td>

                                <td>любое ECMAScript значение или <strong>empty</strong></td>

                                <td>Созданное значение</td>

                            </tr>

                            <tr>

                                <td>[[Target]]</td>

                                <td>любая строка ECMAScript или <strong>empty</strong></td>

                                <td>Метка передачи контроля</td>

                            </tr>

                        </table>

               </article>
               
           </article>
          
           <section>
               
               <header class="header">
                   
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-reference-specification-type">Тип ссылки</a></h4>
                   
               </header>
               
               <p>Тип ссылки объясняет поведение операторов <strong>delete</strong>, <strong>typeof</strong>, <strong>super</strong>, назначения и других фичей языка, где на что-то ссылаются.</p>
               
               <p>Ссылка это обработанное имя или привязка свойства и состоит она из таких компонентов:</p>
               
               <ol class="list">
                   
                   <li>базового значения - это то, на что ссылается ссылка. Его возвращает <strong>GetBase</strong>;</li>
                   
                   <li>имени ссылки, на которое ссылаются. Его возвращает <strong>GetReferencedName</strong>;</li>
                   
                   <li>признака строгости ссылки - идентификатор, что указывает, используется ли строгая семантика выполнения кода, или нет. Его возвращает <strong>IsStrictReference</strong>;</li>
                   
                   <li>компонента <em>thisValue</em>, что существует только в ссылке, которая выражается через оператор <strong>super</strong> - указывает на значение <strong>this</strong>.</li>
                   
               </ol>
               
               <p>Базовым значением может быть <em>undefined</em>, объект, булевское значение, строка, символ, число, или запись окружения (ссылка, созданная оператором <strong>super</strong>, не ссылается на окружение). Имя, на которое ссылаются, это либо строка, либо символ.</p>
               
               <p>Для работы со ссылкой используются определенные абстрактные операции.</p>
               
            <article>
                   
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-getvalue"><em>GetValue(V)</em></a></h4>
                       
                   </header>
                   
                   <p>Эта операция извлекает значение из ссылки (<em>V</em>).</p>
                   
                   <ol class="list">
                       
                       <li>Возвращается входящее значение, предполагаемое как ссылка (<em>V</em>) <span>&#8594;</span> <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>Проверяется его тип (<em>V</em>) <span>&#8594;</span> <strong>Type(V)</strong>. Если это не ссылка (<strong>Type(V)</strong> не <span>&#8594;</span> <em>Reference</em>), возвращается данное значение (<em>V</em>).</li>
                       
                       <li>Если это ссылка (<strong>Type(V)</strong> <span>&#8594;</span> <em>Reference</em>), возвращается ее базовое значение (<em>base</em>) <span>&#8594;</span> <strong>GetBase(V)</strong>.</li>
                       
                       <li>Проверяется, является ли ссылка (<em>V</em>) обрабатываемой <span>&#8594;</span> <strong>IsUnresolvableReference(V)</strong>. Если ссылка (<em>V</em>) ни на что не ссылается, ее базовое значение (<em>base</em>) будет <strong>undefined</strong>, и в этом случае она не может быть обработана как привязка в окружении, что выкинет <strong>ReferenceError</strong> (<strong>IsUnresolvableReference(V)</strong> <span>&#8594;</span> <strong>true</strong> <span>&#8594;</span> <strong>ReferenceError</strong>).</li>
                       
                       <li>Когда ссылка (<em>V</em>) обрабатываемая (<strong>IsUnresolvableReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), проверяется, ссылается ли она на ECMAScript значение <span>&#8594;</span> <strong>IsPropertyReference(V)</strong>.
                       
                           <ol class="list" type="a">
                               
                               <li>Сначала проверяется, ссылается ли ссылка на примитивное значение типа <em>Boolean</em>, <em>String</em>, <em>Number</em> или <em>Symbol</em> <span>&#8594;</span> <strong>HasPrimitiveBase(V)</strong>.
                               
                                   <ol class="list" type="i">
                                      
                                       <li>Если базовове значение ссылки (<em>base</em>) относится к одному из перечисленных примитивных типов (<strong>HasPrimitiveBase(V)</strong> <span>&#8594;</span> <strong>true</strong>), оно преобразовывается в соответствующий объект <span>&#8594;</span> <strong><a href="#toobject-abstr">ToObject</a>(base)</strong>.</li>
                                       
                                       <li>Если базовое значение ссылки это не примитивное значение соответствующего типа (<strong>HasPrimitiveBase(V)</strong> <span>&#8594;</span> <strong>false</strong>), проверяется дополнительное условие <strong>IsPropertyReference(V)</strong> - является ли базовое значение объектом.</li>
                                       
                                   </ol>
                               
                               </li>
                               
                               <li>Если базовое значение ссылки (<em>base</em>) это объект (<em>Object</em>), или оно является примитивным значением, которое удовлетворяет проверку <strong>HasPrimitiveBase(V)</strong> и поэтому может быть обращено в объект (<strong>IsPropertyReference(V)</strong> <span>&#8594;</span> <strong>true</strong>), тогда из него по имени ссылки извлекается ее значение <span>&#8594;</span> <strong>base.<a href="#internal-get">[[Get]]</a>(GetReferencedName(V), <a href="#get_refer_this">GetThisValue</a>(V))</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если ссылка не ссылается на ECMAScript значение (<strong>IsPropertyReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), тогда она ссылается на свое окружение, где ее имя это привязка, и базовое значение ссылки (<em>base</em>) будет соответствующей записью (<strong>Environment Record</strong>). В этом случае извлекается значение ссылки (<em>V</em>) из ее окружения <span>&#8594;</span> <strong>base.<a href="#get_bind_value">GetBindingValue</a>(GetReferencedName(V), IsStrictReference(V))</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-putvalue"><em>PutValue(V, W)</em></a></h4>
                       
                   </header>
                   
                   <p>Эта операция записывает ссылке (<em>V</em>) новое значение (<em>W</em>).</p>
                   
                   <ol class="list">
                      
                       <li>Возвращается входящее значение, предполагаемое как ссылка (<em>V</em>) <span>&#8594;</span> <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>Затем возвращается новое значение ссылки (<em>W</em>) <span>&#8594;</span> <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>Проверяется тип значения, предполагаемое как ссылка (<em>V</em>) <span>&#8594;</span> <strong>Type(V)</strong>. Если это не ссылка (<strong>Type(V)</strong> не <span>&#8594;</span> <em>Reference</em>), выкинет <span>&#8594;</span> <strong>ReferenceError</strong>.</li>
                       
                       <li>Если это ссылка (<strong>Type(V)</strong> <span>&#8594;</span> <em>Reference</em>), возвращается ее базовое значение (<em>base</em>) <span>&#8594;</span> <strong>GetBase(V)</strong>.</li>
                       
                       <li>Проверяется, является ли ссылка (<em>V</em>) обрабатываемой <span>&#8594;</span> <strong>IsUnresolvableReference(V)</strong>. Если базовое значение (<em>base</em>) <strong>undefined</strong> (<strong>IsUnresolvableReference(V)</strong> <span>&#8594;</span> <strong>true</strong>), тогда
                          
                           <ol class="list" type="a">
                              
                               <li>Если ссылка (<em>V</em>) строгая (<strong>IsStrictReference(V)</strong> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>ReferenceError</strong>.</li>
                               
                               <li>Если ссылка (<em>V</em>) не строгая (<strong>IsStrictReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), извлекается глобальный объект (<em>globalObj</em>) <span>&#8594;</span> <strong><a href="#get_glob_obj">GetGlobalObject</a>()</strong>.</li>
                               
                               <li>Ссылке (<em>V</em>) присваивается новое значение (<em>W</em>), поскольку в глобальном объекте (<em>globalObj</em>) создается свойство с именем ссылки и инициализированным значением <strong>undefined</strong> <span>&#8594;</span> <strong><a href="#set-abstr">Set</a>(globalObj, GetReferencedName(V), W, false)</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если базовове значение ссылки не <strong>undefined</strong> (<strong>IsUnresolvableReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), проверяется, ссылается ли эта ссылка (<em>V</em>) на ECMAScript значение <span>&#8594;</span> <strong>IsPropertyReference(V)</strong>.
                       
                           <ol class="list" type="a">
                               
                               <li>Если базовое значение ссылки (<em>base</em>) принадлежит к одному из примитивных типов ECMAScript, что удовлетворяют проверку <strong>HasPrimitiveBase(V)</strong> (<strong>HasPrimitiveBase(V)</strong> <span>&#8594;</span> <strong>true</strong>), тогда преобразовывается в соответствующий объект <span>&#8594;</span> <strong><a href="#toobject">ToObject</a>(base)</strong>.</li>
                               
                               <li>Если базовое значение (<em>base</em>) это объект (<em>Object</em>), или оно преобразовано в него (<strong>IsPropertyReference(V)</strong> <span>&#8594;</span> <strong>true</strong>), тогда ссылке (<em>V</em>) записывается новое значение (<em>W</em>) <span>&#8594;</span> <strong><em>base.<a href="#internal-set">[[Set]]</a>(GetReferencedName(V), W, GetThisValue(V))</em></strong> (<em>succes</em>).</li>
                               
                               <li>Если записать новое значение ссылке (<em>V</em>), которая является строгой (<strong>IsStrictReference(V)</strong> <span>&#8594;</span> <strong>true</strong>) не удалось (<em>succes</em> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                               
                               <li>Возвращается результат того, было ли записано ссылке (<em>V</em>) новое значение (<em>succes</em>).</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если ссылка не ссылается на ECMAScript значение (<strong>IsPropertyReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), тогда она ссылается на свое окружение (<em>base</em> <span>&#8594;</span> <strong>Environment Record</strong>), где имя ссылки (<em>V</em>) привязка. Этой привязке (<em>V</em>) записывается новое значение (<em>W</em>) <span>&#8594;</span> <strong>base.<a href="#set_mut_bind">SetMutableBinding</a>(GetReferencedName(V), W, IsStrictReference(V))</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article id="get_refer_this">
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getthisvalue"><em>GetThisValue(V)</em></a></h4>
                       
                   </header>
                   
                   <p>Эта операция возвращает значение <strong>this</strong>, которое определяет контекст выполнения. Эта операция применяется только к ссылке, что ссылается на ECMAScript значение (<strong>IsPropertyReference(V)</strong> <span>&#8594;</span> <strong>true</strong>).</p>
                   
                   <ol class="list">
                      
                       <li>Проверяется, создана ли ссылка оператором <strong>super</strong> <span>&#8594;</span> <strong>IsSuperReference(V)</strong>. Если да (<strong>IsSuperReference(V)</strong> <span>&#8594;</span> <strong>true</strong>), вернется значение <strong>this</strong> из компонента <strong>thisValue</strong>.</li>
                       
                       <li>Если ссылка не создана оператором <strong>super</strong> (<strong>IsSuperReference(V)</strong> <span>&#8594;</span> <strong>false</strong>), вернется базовое значение ссылки, которое используется в качестве <strong>this</strong> <span>&#8594;</span> <strong>GetBase(V)</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-initializereferencedbinding"><em>InitializeReferencedBinding(V, W)</em></a></h4>
                       
                   </header>
                   
                   <p>Эта операция записывает новое значение <strong>W</strong> существующей неинициализированной привязке в окружении, на которое ссылаются (<em>V</em>).</p>
                   
                   <ol class="list">
                      
                       <li>Возвращается ссылка (<em>V</em>), которая всегда является обрабатываемой (<strong>IsUnresolvableReference(V)</strong> <span>&#8594;</span> <strong>false</strong>) <span>&#8594;</span> <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>Затем возвращается новое значение ссылки (<em>W</em>) - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>Извлекается базовое значение (<em>base</em>) ссылки (<em>V</em>), которое будет записью окружения (<em>Environment Record</em>) <span>&#8594;</span> <strong>GetBase(V)</strong>.</li>
                       
                       <li>В этой записи окружения (<em>base</em>) инициализируется существующая привязка с новым значением (<em>W</em>) и именем ссылки <span>&#8594;</span> <strong>base.<a href="#init_binding_env">InitializeBinding</a>(<em>GetReferencedName(V), W</em>)</strong>.</li>
                       
                   </ol>
                   
               </article>
               
           </section>
           
           <section id="prop_desc">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-descriptor-specification-type">Тип описания свойства</a> (<em>Property Descriptor</em>)</h4>
                   
               </header>
               
               <p>Тип описания свойства используется, чтобы управлять атрибутами свойства, реализовывая это через запись, где имена полей это имена атрибутов, а значения полей - это значения соответствующих атрибутов.</p>
               
               <p>Есть описания свойств данных и доступа. Описание свойства данных включает в себя поля с именами <a href="#value_attr"><strong>[[Value]]</strong></a> и <a href="#write_attr"><strong>[[Writable]]</strong></a> (либо одно из них, либо оба). Описание свойства доступа включает в себя поля с именами <a href="#get_attr"><strong>[[Get]]</strong></a> и <a href="#set_attr"><strong>[[Set]]</strong></a> (либо одно из них, либо оба). Каждое описание свойства имеет поля с именами <a href="#enum_attr"><strong>[[Enumerable]]</strong></a> и <a href="#config_attr"><strong>[[Configurable]]</strong></a>. Кроме этих описаний свойств, есть еще общее и полностю заполненное описание свойства. Общее описание свойства является описанием ни свойства доступа, ни свойства данных (в нем присутствуют только поля атрибутов <a href="#enum_attr"><strong>[[Enumerable]]</strong></a> и <a href="#config_attr"><strong>[[Configurable]]</strong></a>). Полностю заполненное описание свойства это описание либо свойства доступа, либо свойства данных, и имеет оно все соответствующие поля атрибутов.</p>
               
               <p>Существуют абстрактные операции, которые работают с описаниями свойства.</p>
               
               <article id="descr_access">
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isaccessordescriptor"><em>IsAccessorDescriptor(Desc)</em></a></h4>
                       
                   </header>
                   
                   <p>Проверяет, имеет ли свойство атрибуты доступа.</p>
                   
                   <ol class="list">
                      
                       <li>Если описания нет (<em>Desc</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>false</strong>.</li>
                       
                       <li>Если в описании (<em>Desc</em>) свойства нет обоих полей атрибутов <a href="#get_attr"><strong>[[Get]]</strong></a> и <a href="#set_attr"><strong>[[Set]]</strong></a>, вернется <strong>false</strong>.</li>
                       
                       <li>Если есть хотя бы одно из них, вернется <strong>true</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article id="descr_data">
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isdatadescriptor"><em>IsDataDescriptor(Desc)</em></a></h4>
                       
                   </header>
                   
                   <p>Проверяет, имеет свойство атрибуты данных.</p>
                   
                   <ol class="list">
                      
                       <li>Если описания нет (<em>Desc</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>false</strong>.</li>
                       
                       <li>Если в описании (<em>Desc</em>) свойства нет обоих полей для атрибутов <a href="#value_attr"><strong>[[Value]]</strong></a> и <a href="#write_attr"><strong>[[Writable]]</strong></a>, вернется <strong>false</strong>.</li>
                       
                       <li>Если есть хотя бы одно из них, вернется <strong>true</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article id="descr_generic">
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isgenericdescriptor"><em>IsGenericDescriptor(Desc)</em></a></h4>
                       
                   </header>
                   
                   <p>Проверяет, является ли описание общим.</p>
                   
                   <ol class="list">
                      
                       <li>Если описания нет (<em>Desc</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>false</strong>.</li>
                       
                       <li>Если данное описание либо свойства данных (<strong><a href="#descr_data">IsAccessorDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>true</strong>), либо свойства доступа (<strong><a href="#descr_access">IsAccessorDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>.</li>
                       
                       <li>Если данное описание ни свойства данных (<strong><a href="#descr_data">IsAccessorDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>false</strong>), ни свойства доступа (<strong><a href="#descr_access">IsAccessorDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>false</strong>), вернется <strong>true</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article id="descr_from_prop_descr">
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-frompropertydescriptor"><em>FromPropertyDescriptor(Desc)</em></a></h4>
                       
                   </header>
                   
                   <p>Создает объект из описания свойства (<em>Desc</em>).</p>
                   
                   <ol class="list">
                      
                       <li>Если описания нет (<em>Desc</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>undefined</strong>.</li>
                       
                       <li>Создается обычный расширяемый объект (<em>obj</em>) без собственных свойств, у которого прототипом является глобальный объект <span>&#8594;</span> <strong><a href="#">ObjectCreate</a>(%ObjectPrototype%)</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#value_attr"><strong>[[Value]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"value"</strong> и значением этого атрибута (<em>Desc.[[Value]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "value", Desc.[[Value]])</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#write_attr"><strong>[[Writable]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"writable"</strong> и значением этого атрибута (<em>Desc.[[Writable]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "writable", Desc.[[Writable]])</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#get_attr"><strong>[[Get]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"get"</strong> и значением этого атрибута (<em>Desc.[[Get]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "get", Desc.[[Get]])</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#set_attr"><strong>[[Set]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"set"</strong> и значением этого атрибута (<em>Desc.[[Set]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "set", Desc.[[Set]])</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#enum_attr"><strong>[[Enumerable]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"enumerable"</strong> и значением этого атрибута (<em>Desc.[[Enumerable]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "enumerable", Desc.[[Enumerable]])</strong>.</li>
                       
                       <li>Если в описании свойства (<em>Desc</em>) есть поле атрибута <a href="#enum_attr"><strong>[[Configurable]]</strong></a>, тогда в объекте (<em>obj</em>) создается свойство с именем <strong>"configurable"</strong> и значением этого атрибута (<em>Desc.[[Configurable]]</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(obj, "configurable", Desc.[[Configurable]])</strong>.</li>
                       
                       <li>Возвращается этот объект (<em>obj</em>) этими созданными свойствами.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-topropertydescriptor"><em>ToPropertyDescriptor(Obj)</em></a></h4>
                       
                   </header>
                   
                   <p>Возвращает описание свойства из объекта (<em>Obj</em>).</p>
                   
                   <ol class="list">
                      
                       <li>Проверяется тип входящего значения (<em>Obj</em>) <span>&#8594;</span> <strong>Type(Obj)</strong>. Если это не объект (<em>Object</em>), вернется <strong>TypeError</strong>.</li>
                       
                       <li>Создается пустое описание свойства (<em>desc</em>) без полей.</li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем <strong>"enumerable"</strong> (<em>hasEnumerable</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "enumerable")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasEnumerable</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства, которое затем преобразовывается в булевское значение (<em>enum</em>) <span>&#8594;</span> <strong><a href="#toboolean-abstr">ToBoolean</a>(<a href="#get-abstr">Get</a>(Obj, "enumerable"))</strong>.</li>
                               
                               <li>В описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#enum_attr"><strong>[[Enumerable]]</strong></a>, которому присваивается полученное булевское значение (<em>enum</em>) <span>&#8594;</span> <strong>desc.<a href="#enum_attr">[[Enumerable]]</a></strong> = <strong>enum</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем <strong>"configurable"</strong> (<em>hasConfigurable</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "configurable")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasConfigurable</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства, которое затем преобразовывается в булевское значение (<em>conf</em>) <span>&#8594;</span> <strong><a href="#toboolean-abstr">ToBoolean</a>(<a href="#get-abstr">Get</a>(Obj, "configurable"))</strong>.</li>
                               
                               <li>В описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#config_attr"><strong>[[Configurable]]</strong></a>, которому присваивается полученное булевское значение (<em>conf</em>) <span>&#8594;</span> <strong>desc.<a href="#config_attr">[[Configurable]]</a></strong> = <strong>conf</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем (<em>hasValue</em>) <strong>"value"</strong> <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "value")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasValue</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства (<em>value</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(Obj, "value")</strong>.</li>
                               
                               <li>В описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#value_attr"><strong>[[Value]]</strong></a>, которому присваивается полученное значение (<em>value</em>) <span>&#8594;</span> <strong>desc.<a href="#value_attr">[[Value]]</a></strong> = <strong>value</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем <strong>"writable"</strong> (<em>hasWritable</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "writable")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasWritable</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства, которое затем преобразовывается в булевское значение (<em>writable</em>) <span>&#8594;</span> <strong><a href="#toboolean-abstr">ToBoolean</a>(<a href="#get-abstr">Get</a>(Obj, "writable"))</strong>.</li>
                               
                               <li>В описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#write_attr"><strong>[[Writable]]</strong></a>, которому присваивается полученное булевское значение (<em>writable</em>) <span>&#8594;</span> <strong>desc.<a href="#write_attr">[[Writable]]</a></strong> = <strong>writable</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем <strong>"get"</strong> (<em>hasGet</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "get")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasGet</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства (<em>getter</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(Obj, "get")</strong>.</li>
                               
                               <li>Если полученное значение (<em>getter</em>) не функция (<strong><a href="#iscallable-abstr">IsCallable</a>(getter)</strong> <span>&#8594;</span> <strong>false</strong>) и не <strong>undefined</strong>, выкинет <strong>TypeError</strong>.</li>
                               
                               <li>Если это значение (<em>getter</em>) функция (<strong><a href="#iscallable-abstr">IsCallable</a>(getter)</strong> <span>&#8594;</span> <strong>true</strong>), или <strong>undefined</strong>, тогда в описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#get_attr"><strong>[[Get]]</strong></a>, которому присваивается полученное значение (<em>getter</em>) <span>&#8594;</span> <strong>desc.<a href="#get_attr">[[Get]]</a></strong> = <strong>getter</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Проверяется, имеет ли объект (<em>Obj</em>) свойство с именем <strong>"set"</strong> (<em>hasSet</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(Obj, "set")</strong>.
                       
                           <ol class="list" type="a">
                              
                               <li>Если имеет (<em>hasSet</em> <span>&#8594;</span> <strong>true</strong>), тогда извлекается значение этого свойства (<em>setter</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(Obj, "set")</strong>.</li>
                               
                               <li>Если полученное значение (<em>setter</em>) не функция (<strong><a href="#iscallable-abstr">IsCallable</a>(setter)</strong> <span>&#8594;</span> <strong>false</strong>) и не <strong>undefined</strong>, выкинет <strong>TypeError</strong>.</li>
                               
                               <li>Если это значение (<em>setter</em>) функция (<strong><a href="#iscallable-abstr">IsCallable</a>(setter)</strong> <span>&#8594;</span> <strong>true</strong>), или <strong>undefined</strong>, тогда в описании свойства (<em>desc</em>) создается поле, что соответствует атрибуту <a href="#set_attr"><strong>[[Set]]</strong></a>, которому присваивается полученное значение (<em>setter</em>) <span>&#8594;</span> <strong>desc.<a href="#set_attr">[[Set]]</a></strong> = <strong>setter</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если в полученном описании свойства (<em>desc</em>) есть хотя бы одно из полей атрибутов <a href="#get_attr"><strong>[[Get]]</strong></a> (<em>desc.[[Get]]</em>) или <a href="#set_attr"><strong>[[Set]]</strong></a> (<em>desc.[[Set]]</em>), при этом в нем также есть хотя бы одно из полей атрибутов <a href="#value_attr"><strong>[[Value]]</strong></a> (<em>desc.[[Value]]</em>) или <a href="#write_attr"><strong>[[Writable]]</strong></a> (<em>desc.[[Writable]]</em>), выкинет <strong>TypeError</strong>.</li>
                       
                       <li>Если в полученном описании свойства (<em>desc</em>) атрибуты свойств данных и доступа не пересекаются, возвращается данное описание свойства (<em>desc</em>).</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completepropertydescriptor"><em>CompletePropertyDescriptor(Desc)</em></a></h4>
                       
                   </header>
                   
                   <p>Добавляет описанию свойства недостающие поля атрибутов.</p>
                   
                   <ol class="list">
                      
                       <li>Эта операция получает описание свойства (<em>Desc</em>), которое дополняется отсуствующими полями атрибутов. Эти поля получают дэфолтные значения из созданной записи (<em>like</em>) <span>&#8594;</span> <strong>Record{<a href="#value_attr"><strong>[[Value]]</strong></a>: undefined, <a href="#write_attr"><strong>[[Writable]]</strong></a>: false, <a href="#get_attr"><strong>[[Get]]</strong></a>: undefined, <a href="#set_attr"><strong>[[Set]]</strong></a>: undefined, <a href="#enum_attr"><strong>[[Enumerable]]</strong></a>: false, <a href="#config_attr"><strong>[[Configurable]]</strong></a>: false}</strong>.</li>
                       
                       <li>Если описание свойства (<em>Desc</em>) общее (<strong><a href="#descr_generic">IsGenericDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>true</strong>), при этом из него необходимо сделать описание свойства данных, либо оно уже является таким (<strong><a href="#descr_data">IsDataDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>true</strong>), тогда оно будет дополнено необходимыми полями. 
                       
                           <ol class="list" type="a">
                              
                               <li>Если в этом описании свойства (<em>Desc</em>) отсуствует поле атрибута <a href="#value_attr"><strong>[[Value]]</strong></a>, оно создается (<em>Desc.[[Value]]</em>) и ему присваивается дэфолтное значение (<em>like.[[Value]]</em>) <span>&#8594;</span> <strong>Desc.[[Value]]</strong> = <strong>like.[[Value]]</strong>.</li>
                               
                               <li>Если же в этом описании свойства (<em>Desc</em>) отсуствует поле атрибута <a href="#write_attr"><strong>[[Writable]]</strong></a>, оно создается (<em>Desc.[[Writable]]</em>) и ему присваивается дэфолтное значение (<em>like.[[Writable]]</em>) <span>&#8594;</span> <strong>Desc.[[Writable]]</strong> = <strong>like.[[Writable]]</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если описание свойства (<em>Desc</em>) общее (<strong><a href="#descr_generic">IsGenericDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>true</strong>), при этом из него необходимо сделать описание свойства доступа, либо оно уже является таким (<strong><a href="#descr_access">IsDataDescriptor</a>(Desc)</strong> <span>&#8594;</span> <strong>false</strong>), тогда оно будет дополнено необходимыми полями. 
                       
                           <ol class="list" type="a">
                              
                               <li>Если в этом описании свойства (<em>Desc</em>) отсуствует поле атрибута <a href="#get_attr"><strong>[[Get]]</strong></a>, оно создается (<em>Desc.[[Get]]</em>) и ему присваивается дэфолтное значение (<em>like.[[Get]]</em>) <span>&#8594;</span> <strong>Desc.[[Get]]</strong> = <strong>like.[[Get]]</strong>.</li>
                               
                               <li>Если же в этом описании свойства (<em>Desc</em>) отсуствует поле атрибута <a href="#set_attr"><strong>[[Set]]</strong></a>, оно создается (<em>Desc.[[Set]]</em>) и ему присваивается дэфолтное значение (<em>like.[[Set]]</em>) <span>&#8594;</span> <strong>Desc.[[Set]]</strong> = <strong>like.[[Set]]</strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если в описании свойства нет поля атрибута <a href="#enum_attr"><strong>[[Enumerable]]</strong></a>, оно создается (<em>Desc.[[Enumerable]]</em>) и ему присваивается дэфолтное значение (like.[[Enumerable]]) <span>&#8594;</span> <strong>Desc.[[Enumerable]]</strong> = <strong>like.[[Enumerable]]</strong>.</li>
                       
                       <li>Если же в описании свойства нет поля атрибута <a href="#config_attr"><strong>[[Configurable]]</strong></a>, оно создается (<em>Desc.[[Configurable]]</em>) и ему присваивается дэфолтное значение (like.[[Configurable]]) <span>&#8594;</span> <strong>Desc.[[Configurable]]</strong> = <strong>like.[[Configurable]]</strong>.</li>
                       
                       <li>Возвращается полученное описание свойства (<em>Desc</em>).</li>
                       
                   </ol>
                   
               </article>
               
           </section>
           
       </section>
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-operations">Абстрактные операции</a></h2>
           
       </header>
       
       <p>Существуют абстрактные операции, которые описывают семантику языка.</p>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-type-conversion">Преобразование типов</a></h3>
               
           </header>
           
           <p>При необходимости ECMAScript неявно выполняет автоматическое преобразование типов. Абстрактные операции преобразования типов полиморфные принимают значения любого типа ECMAScript.</p>
           
           <section id="toprim-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive"><em>ToPrimitive ( input [ , PreferredType ] )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>input</em>) в примитивное. Для входящего значения типа <em>Object</em> используется указание (<em>PreferredType</em>) для преобразования в примитивное значение. Эта операция принимает значения всех типов ECMAScript.</p>
               
               <ol class="list">
                  
                   <li>Проверяется тип входящего значения (<em>input</em>) <span>&#8594;</span> <strong>Type(input)</strong>. Если входящее значение (<em>input</em>) это объект (<strong>Type(input)</strong> <span>&#8594;</span> <em>Object</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Рассматривается, в какое примитивное значение следует преобразовать объект (<em>input</em>) в зависимости от указания (<em>PreferredType</em>). Если нет никакого указания на тип преобразования (<em>PreferredType</em>), тогда по умолчанию оно получит значение (<em>hint</em>) <strong>"default"</strong>.</li>
                           
                           <li>Если передается указание (<em>PreferredType</em>) на строку (<em>String</em>), тогда его значение (<em>hint</em>) будет <strong>"string"</strong>.</li>
                           
                           <li>Если же передается указание (<em>PreferredType</em>) на число (<em>Number</em>), тогда его значение (<em>hint</em>) <strong>"number"</strong>.</li>
                           
                           <li>Когда вопрос с указанием на примитивный тип (<em>PreferredType</em>) решен, алгоритм выполнит преобразование объекта (<em>input</em>) в зависимости от того, является ли он обычным или необычным. Если объект (<em>input</em>) необычный, используется его метод <a href="#symb_toprim"><strong>@@toPrimitive</strong></a> для преобразования <span>&#8594;</span> <strong><a href="#get_method-abstr">GetMethod</a>(input, @@toPrimitive)</strong> (<em>exoticToPrim</em>).</li>
                           
                           <li>Если значение метода <a href="#symb_toprim"><strong>@@toPrimitive</strong></a> (<em>exoticToPrim</em>) не <strong>undefined</strong>, тогда
                           
                               <ol class="list" type="i">
                                   
                                   <li>Вызывается функция этого метода (<em>exoticToPrim</em>) <span>&#8594;</span> <strong><a href="call-abstr">Call</a>(exoticToPrim, input, "hint")</strong> (<em>result</em>).</li>
                                   
                                   <li>Проверяется тип полученного значения (<em>result</em>) <span>&#8594;</span> <strong>Type(result)</strong>. Вернется это значение (<em>result</em>), если оно не объект (<strong>Type(result)</strong> не <span>&#8594;</span> <em>Object</em>).</li>
                                   
                                   <li>Если это объект (<strong>Type(result)</strong> <span>&#8594;</span> <em>Object</em>), выкинет <strong>TypeError</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                            <li>Если объект (<em>input</em>) обычный и указанию (<em>PreferredType</em>) передается значение (<em>hint</em>) <strong>"default"</strong>, тогда он будет преобразован с указанием на тип числа (<em>hint</em> <span>&#8594;</span> <strong>"number"</strong>).</li>
                            
                            <li>Преобразовывается обычный объект <span>&#8594;</span> <strong><a href="#ordinary_toprim-abstr">OrdinaryToPrimitive</a>(input, hint)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же входящее значение (<em>input</em>) это не объект (<strong>Type(input)</strong> не <span>&#8594;</span> <em>Object</em>), тогда вернется это значение (<em>input</em>).</li>
                   
               </ol>
               
               <p>Объекты <em>Date</em> и <em>Symbol</em> единственные, которые переопределяют стандартное поведение операции <a href="#toprim-abstr"><strong>ToPrimitive</strong></a>.</p>
               
               <article id="ordinary_toprim-abstr">
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive"><em>OrdinaryToPrimitive ( O, hint )</em></a></h4>
                       
                   </header>
                   
                   <p>Эта операция преобразовывает обычные объекты в примитивное значение.</p>
                   
                   <ol class="list">
                      
                       <li>Эта операция получает два значения для указания на тип преобразования (<em>hint</em>) объекта: <strong>"string"</strong> или <strong>"number"</strong>.</li>
                       
                       <li>Если получено значение (<em>hint</em>) <strong>"string"</strong>, к объекту (<em>O</em>) применяется такая последовательность методов (<em>methodNames</em>) для преобразования: " <strong>'toString'</strong>, <strong>'valueOf'</strong> ". Эти методы достаются из глобального объекта через наследование.</li>
                       
                       <li>Если же получено значение (<em>hint</em>) <strong>"number"</strong>, последовательность применяемых к объекту (<em>O</em>) методов (<em>methodNames</em>), меняется: " <strong>'valueOf'</strong>, <strong>'toString'</strong> ".</li>
                       
                       <li>Каждый метод (<em>name</em>) в порядке списка (<em>methodNames</em>) применяется к объекту (<em>O</em>):
                       
                           <ol class="list" type="a">
                               
                               <li>Сначала извлекается значение метода (<em>name</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(O, name)</strong> (<em>method</em>).</li>
                               
                               <li>Затем проверяется, является ли это значение (<em>method</em>) функцией <span>&#8594;</span> <strong><a href="#iscallable-abstr">IsCallable</a>(method)</strong>. Если проверка подтвердилась (<strong>IsCallable</strong> <span>&#8594;</span> <strong>true</strong>), тогда:
                               
                                   <ol class="list" type="i">
                                       
                                       <li>Эта функция (<em>method</em>) <span>&#8594;</span> вызывается <strong><a href="#call-abstr">Call</a>(method, O)</strong> (<em>result</em>).</li>
                                       
                                       <li>Проверяется, к какому типу ECMAScript принадлежит полученное значение (<em>result</em>) <span>&#8594;</span> <strong>Type(result)</strong>. Если это не объект (<strong>Type(result)</strong> не <span>&#8594;</span> <em>Object</em>), вернется значение (<em>result</em>). А если полученное значение (<em>result</em>) объект (<strong>Type(result)</strong> <span>&#8594;</span> <em>Object</em>), выполняется следующий метод  (<em>name</em>) из списка (<em>methodNames</em>).</li>
                                       
                                   </ol>
                               
                               </li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если полученное значение (<em>method</em>) из метода (<em>name</em>) не вызываемое, выкинет <strong>TypeError</strong>.</li>
                       
                   </ol>
                   
                   <p>Когда указанию (<em>hint</em>) передается значение <strong>"string"</strong>, сперва выполняется метод <a href="#"><strong>toString</strong></a>, что возвращает строку (<em>result</em>). После этого метод <a href="#"><strong>valueOf</strong></a> не выполняется, поскольку необходимое примитивное значение уже есть.</p>
                   
                   <p>В случае, когда указанию (<em>hint</em>) передается значение <strong>"number"</strong>, первым выполняется метод <a href="#"><strong>valueOf</strong></a>, что возвращает значение (<em>result</em>) типа <em>Object</em>. После этого будет выполнен метод <a href="#"><strong>toString</strong></a>, который преобразует полученный объект (<em>result</em>) в строку.</p>
                   
               </article>
               
           </section>
           
           <article id="toboolean-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toboolean"><em>ToBoolean ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в булевское.</p>
               
               <table>

                    <caption>Преобразование в булевское значение</caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернется <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернется <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернется входящее значение (<em>argument</em>) без преобразования.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Если дано <strong>+0</strong>, <strong>-0</strong> или <strong>NaN</strong>, тогда вернется <strong>false</strong>; в остальных случаях - <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Если дано пустую строку, тогда вернется <strong>false</strong>; в остальных случаях - <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернется <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернется <strong>true</strong>.</td>

                    </tr>

                </table>
               
           </article>
           
           <article id="tonumber-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber"><em>ToNumber ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в число.</p>
               
               <table>

                    <caption>Преобразование в число</caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернется <strong>NaN</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернется <strong>+0</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если входящее значение (<em>argument</em>) это булевское <strong>true</strong>, тогда вернется 1; когда <strong>false</strong> - 0.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернется входящее значение (<em>argument</em>) без преобразования.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернется значение согласно <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber-applied-to-the-string-type">алгоритму преоразования</a>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Выполняются операции:
                        
                            <ol class="list">
                               
                                <li><strong><a href="#toprim-abstr">ToPrimitive</a>(argument, hint Number)</strong> (<em>primValue</em>);</li>
                                
                                <li><strong><a href="#tonumber-abstr">ToNumber</a>(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Если входящее значение (<em>argument</em>) это строка, что не может быть истолкована как число (<em>StringNumericLiteral</em>), тогда результатом будет <strong>NaN</strong>. Итак, если строка имеет вид "трали-вали", тогда получим  на выходе <strong>NaN</strong>. Если же строка имеет вид десятичного, двоичного, восьмеричного или шестнадцатиричного числа, тогда она преобразуется в число ("123" <span>&#8594;</span> 123).</p>
                
                <p>Число в виде строки (<em>StringNumericLiteral</em>) имеет свои особенности:</p>
                
                <ul class="list">
                   
                    <li>Может включать в себя пробел, что начинает и/или завершает строку, и/или символы конца строки (т.е. " 123 " это норм и будет <span>&#8594;</span> 123).</li>
                    
                    <li>Ему может предшествовать любое количество нулей (т.е. "000000123" <span>&#8594;</span> 123).</li>
                    
                    <li>Может включать в себя <strong>+ / -</strong>, чтобы указать свой знак (т.е. "-123" <span>&#8594;</span> -123).</li>
                    
                    <li>Пустая строка или пробел преобразовывется в <strong>+0</strong> (т.е. " " <span>&#8594;</span> 0).</li>
                    
                    <li>Значения <strong>Infinity</strong> и <strong>-Infinity</strong> распознаются как строка и преобразовываются в настолько огромедное число (10<sup>10000</sup>), что округляются к <strong>+&#8734;</strong> или <strong>-&#8734;</strong>.</li>
                    
                </ul>
                
                <p>Семантика преобразования строки в число дается <a href="https://www.ecma-international.org/ecma-262/#sec-runtime-semantics-mv-s"><strong>тут</strong></a>.</p>
               
           </article>
           
           <article id="tostring-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tostring"><em>ToString ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в строку.</p>
               
               <table>

                    <caption>Преобразование в строку</caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернется <strong>"undefined"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернется <strong>"null"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>При булевском <em>true</em> вернется <strong>"true"</strong>; при <em>false</em> - <strong>"false"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернется значение согласно <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type">алгоритму преоразования</a>.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернется входящее значение (<em>argument</em>) без преобразования.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Выполняются операции:
                        
                            <ol class="list">
                               
                                <li><strong><a href="#toprim-abstr">ToPrimitive</a>(argument, hint String)</strong> (<em>primValue</em>);</li>
                                
                                <li><strong><a href="#tostring-abstr">ToString</a>(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Cемантика преобразования числа в строку дается <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type"><strong>тут</strong></a>.</p>
               
           </article>
           
           <article id="toobject-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toobject"><em>ToObject ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в объект.</p>
               
               <table>

                    <caption>Преобразование в объект</caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернется <a href="https://www.ecma-international.org/ecma-262/#sec-boolean-objects">булевский объект</a>, а его внутреннему слоту <strong>[[BooleanData]]</strong> назначается входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернется <a href="https://www.ecma-international.org/ecma-262/#sec-number-objects">числовой объект</a>, а его внутреннему слоту <strong>[[NumberData]]</strong> назначается входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернется <a href="https://www.ecma-international.org/ecma-262/#sec-string-objects">строковый объект</a>, а его внутреннему слоту <strong>[[StringData]]</strong> назначается входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернется <a href="https://www.ecma-international.org/ecma-262/#sec-symbol-objects">объект символа</a>, а его внутреннему слоту <strong>[[SymbolData]]</strong> назначается входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернется входящее значение (<em>argument</em>) без преобразования.</td>

                    </tr>

                </table>
               
           </article>
           
           <article id="tointeger-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tointeger"><em>ToInteger ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в целое число.</p>
               
               <ol class="list">
                  
                   <li>Возвращается число <span>&#8594;</span> <strong><a href="#tonumber">ToNumber</a>(argument)</strong> (<em>number</em>).</li>
                   
                   <li>Если полученный результат (<em>number</em>) это <strong>NaN</strong>, тогда вернется <strong>+0</strong>.</li>
                   
                   <li>Если полученный результат (<em>number</em>) это <strong>+0</strong>, <strong>-0</strong>, <strong>+&#8734;</strong> или <strong>-&#8734;</strong>, тогда он (<em>number</em>) вернется.</li>
                   
                   <li>В остальных случаях вернется число (<em>number</em>), что сводится к абсолютному значению, которое округляется к меньшему целому числу <span>&#8594;</span> <strong>floor(abs(number))</strong> (т.е. 5.66666 будет <span>&#8594;</span> 5).
                   
               </ol>
               
           </article>
           
           <article id="toprop_key-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-topropertykey"><em>ToPropertyKey ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в ключ свойства.</p>
               
               <ol class="list">
                  
                  <li>Входящее значение (<em>argument</em>) сводится к примитивному <strong><a href="#toprim-abstr">ToPrimitive</a>(argument, hint String)</strong> (<em>key</em>).</li>
                  
                  <li>Проверяется тип полученного значения (<em>key</em>) <span>&#8594;</span> <strong>Type(key)</strong>. Если это символ (<strong>Type(key)</strong> <span>&#8594;</span> <em>Symbol</em>), оно вернется.</li>
                  
                  <li>Затем полученное значение (<em>key</em>), если это не символ, преобразовывается в строку <span>&#8594;</span> <strong><a href="#tostring-abstr">ToString</a>(key)</strong>.</li> 

               </ol>
               
           </article>
           
           <article id="tolength-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tolength"><em>ToLength ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в число длины массивоподобного объекта.</p>
               
               <ol class="list">
                  
                  <li>Возвращается целое число (<em>len</em>) <span>&#8804;</span> <strong><a href="#tointeger-abstr">ToInteger</a>(argument)</strong>.</li>
                  
                  <li>Если полученное значение (<em>len</em>) меньше или равно нулю, тогда вернется <strong>+0</strong>.</li>
                  
                  <li>Если полученное значение (<em>len</em>) больше нуля, оно вернется <span>&#8594;</span> <strong>min(<em>len</em>, 2<sup>53</sup>-1)</strong>. Данное значение не должно превышать 2<sup>53</sup>-1.</li>

               </ol>
               
           </article>
           
           <article id="toindex-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-toindex"><em>ToIndex ( value )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>value</em>) в число индекса.</p>
               
               <ol class="list">
                  
                  <li>Если входящее значение (<em>value</em>) это <strong>undefined</strong>, индекс (<em>index</em>) будет 0.</li>
                  
                  <li>В ином случае
                  
                      <ol class="list" type="a">
                         
                          <li>Входящее значение преобразовывается в целое число (<em>integerIndex</em>) <span>&#8594;</span> <strong><a href="#tointeger-abstr">ToInteger</a>(value)</strong>.</li>
                          
                          <li>Если полученное число меньше нуля (<em>integerIndex</em> <span>&#60;</span> 0), выкинет <strong>RangeError</strong>.</li>
                          
                          <li>Затем полученное число (<em>integerIndex</em>) сводится к значению, которое не должно превышать максимально допустимую длину массивоподобного объекта (<em>index</em>) <span>&#8594;</span> <strong><a href="#tolength-abstr">ToLength</a>(integerIndex)</strong>. Это значение и будет индексом.</li>
                          
                          <li>Выполняется сравнение полученных чисел <span>&#8594;</span> <strong><a href="#same_value_zero-abstr">SameValueZero</a>(integerIndex, index)</strong>. Если получилось так, что они не равны друг другу (<a href="#same_value_zero-abstr"><strong>SameValueZero</strong></a> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>RangeError</strong>.</li>
                      </ol>
                  
                  </li>
                  
                  <li>А если равны (<a href="#same_value_zero-abstr"><strong>SameValueZero</strong></a> <span>&#8594;</span> <strong>true</strong>), вернется индекс (<em>index</em>).</li>
                  
               </ol>
               
           </article>
           
           <article id="canon_num_ind_str-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-canonicalnumericindexstring"><em>CanonicalNumericIndexString ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает входящее значение (<em>argument</em>) в число, если ожидается, что оно это число в виде строки, которое возвращает операция <a href="#tostring-abstr"><strong>ToString</strong></a> или строка  <strong>"-0"</strong>.</p>
               
               <ol class="list">
                  
                  <li>Входящее значение (<em>argument</em>) это строка. Если это строка в виде <strong>"-0"</strong>, вернется <strong>-0</strong>.</li>
                  
                  <li>Входящяя строка (<em>argument</em>) преобразовывается в число (<em>n</em>) <span>&#8594;</span> <strong><a href="#tonumber-abstr">ToNumber</a>(argument)</strong>.</li>
                  
                  <li>Выподняется сравнение полученного числа (<em>n</em>), которое для этого преобразовывается в строку, с входящим аргументом (<em>argument</em>) <span>&#8594;</span> <strong><a href="#same_value-abstr">SameValue</a>(<strong><a href="#tostring-abstr">ToString</a>(n)</strong>, argument)</strong>. Если эти обе строки не одинаковые (<a href="#same_value-abstr"><strong>SameValue</strong></a> <span>&#8594;</span> <strong>false</strong>), вернется <strong>undefined</strong>.</li>
                  
                  <li>Если же они одинаковые (<a href="#same_value-abstr"><strong>SameValue</strong></a> <span>&#8594;</span> <strong>true</strong>), вернется полученное число (<em>n</em>).</li>

               </ol>
               
           </article>
           
           <div>
              
               <p>Существует еще операции, что преобразовывают входящее значение:</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint32"><strong><em>ToInt32 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>32</sup> целочисленных значений в диапазоне от -2<sup>31</sup> до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint32"><strong><em>ToUint32 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>32</sup> целочисленных значений в диапазоне от 0 до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint16"><strong><em>ToInt16 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>16</sup> целочисленных значений в диапазоне от -32768 до 32767 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint16"><strong><em>ToUint16 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>16</sup> целочисленных значений в диапазоне от 0 до 2<sup>16</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint8"><strong><em>ToInt8 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>8</sup> целочисленных значений в диапазоне от -128 до 127 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8"><strong><em>ToUint8 ( argument )</em></strong></a> - преобразовывает входящее значение в одно из 2<sup>8</sup> целочисленных значений в диапазоне от 0 до 255 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8clamp"><strong><em>ToUint8Clamp ( argument )</em></strong></a>.</li>
                   
               </ul>
               
           </div>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-testing-and-comparison-operations">Операции тестирования и сравнения</a></h3>
               
           </header>
           
           <article id="req_obj_coerc-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-requireobjectcoercible"><em>RequireObjectCoercible ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, возможно ли преобразовать входящее значение (<em>argument</em>) в объект.</p>
               
               <table>

                    <caption>Результаты проверки <strong>RequireObjectCoercible</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернется <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернется <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернется входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернется входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернется входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернется входящее значение (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернется входящее значение (<em>argument</em>).</td>

                    </tr>

                </table>
               
           </article>
           
           <article id="isarray-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isarray"><em>IsArray ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли входящее значение (<em>argument</em>) массивом (<em>Array</em>) или прокси-объектом (<em>Proxy</em>).</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это не объект (<strong>Type(argument)</strong> не <span>&#8594;</span> <em>Object</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это массив (<em>Array</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если это прокси-объект (<em>Proxy</em>), тогда
                   
                   <ol class="list" type="a">
                       
                       <li>Если значение слота <strong>[[ProxyHandler]]</strong> этого объекта (<em>argument</em>) <strong>null</strong>, выкинет <strong>TypeError</strong> (<strong>argument.[[ProxyHandler]]</strong> <span>&#8594;</span> <strong>null</strong> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                       
                       <li>В ином случае, значение этого слота (<strong>argument.[[ProxyHandler]]</strong>) используется для данной проверки (<em>target</em>).</li>
                       
                       <li>Выполняется <strong><a href="#isarray-abstr">IsArray</a>(target)</strong>.</li>
                       
                   </ol>
                   
                   
                   </li>
                   
                   <li>Когда имеем другие объекты (<em>argument</em>), вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="iscallable-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-iscallable"><em>IsCallable ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли входящее значение (<em>argument</em>) функцией с внутренним методом <a href="#internal-call"><strong>[[Call]]</strong></a>.</p>
               
               <ol class="list">
                  
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это не объект (<strong>Type(argument)</strong> не <span>&#8594;</span> <em>Object</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это объект (<strong>Type(argument)</strong> <span>&#8594;</span> <em>Object</em>) и он имеет внутренний метод вызова <a href="#internal-call"><strong>[[Call]]</strong></a>, вернется <strong>true</strong>.</li>
                   
                   <li>Если этот объект (<em>argument</em>) не имеет внутреннего метода вызова, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isconstr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isconstructor"><em>IsConstructor ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли входящее значение (<em>argument</em>) функцией с внутренним методом <a href="#internal-construct"><strong>[[Construct]]</strong></a>.</p>
               
               <ol class="list">
                  
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это не объект (<strong>Type(argument)</strong> не <span>&#8594;</span> <em>Object</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это объект (<strong>Type(argument)</strong> <span>&#8594;</span> <em>Object</em>) и он имеет внутренний метод <a href="#internal-construct"><strong>[[Construct]]</strong></a>, вернется <strong>true</strong>.</li>
                   
                   <li>Если этот объект (<em>argument</em>) не имеет внутреннего метода конструктора, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isextensible-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isextensible-o"><em>IsExtensible ( O )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, могут ли дополнительные свойства быть добавлены объекту (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Происходит проверка типа входящего значения, хоть это всегда объект (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                   
                   <li>Выполняется внутренний метод, который определяет возможность добавить объекту (<em>O</em>) новые свойтсва <span>&#8594;</span> <strong>O.<a href="#internal-isextensible">[[IsExtensible]]</a>()</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isinteger-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isinteger"><em>IsInteger ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли входящее значение (<em>argument</em>) конечным целым числом.</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это не число (<strong>Type(argument)</strong> не <span>&#8594;</span> <em>Number</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это число (<strong>Type(argument)</strong> <span>&#8594;</span> <em>Number</em>) и оно <strong>NaN</strong>, <strong>+&#8734;</strong>, или <strong>-&#8734;</strong>, вернется <strong>false</strong>.</li>
                   
                   <li>Если входящее значение (<em>argument</em>) это конечное число, которое округляется (<strong>floor(abs(argument))</strong> <span>&#8800;</span> <strong>abs(argument)</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если входящее значение (<em>argument</em>) это конечное целое число, вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isprop_key-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ispropertykey"><em>IsPropertyKey ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, может ли входящее значение (<em>argument</em>) использоваться как ключ свойства.</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это строка (<strong>Type(argument)</strong> <span>&#8594;</span> <em>String</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если это символ (<strong>Type(argument)</strong> <span>&#8594;</span> <em>Symbol</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если же входящее значение не принадлежит ни к одному из перечисленных типов, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="isregexp-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-isregexp"><em>IsRegExp ( argument )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, является ли входящее значение (<em>argument</em>) регулярным выражением (<em>RegExp</em>).</p>
               
               <ol class="list">
                  
                   <li>Проверяется тип входящего значения (<em>argument</em>) <span>&#8594;</span> <strong>Type(argument)</strong>. Если это не объект (<strong>Type(argument)</strong> не <span>&#8594;</span> <em>Object</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это объект (<strong>Type(argument)</strong> <span>&#8594;</span> <em>Object</em>), извлекается значение его метода <a href="#symb_match"><strong>@@match</strong></a> (<em>isRegExp</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(argument, @@match)</strong>.</li>
                   
                   <li>Если значение метода <a href="#symb_match"><strong>@@match</strong></a> (<em>isRegExp</em>) не <strong>undefined</strong>, из него возвращается булевское значение <span>&#8594;</span> <strong><a href="#toboolean-abstr">ToBoolean</a>(isRegExp)</strong>.</li>
                   
                   <li>Если же полученное значение метода (<em>isRegExp</em>) это <strong>undefined</strong>, проверяется, имеет ли входящий объект (<em>argument</em>) внутренний слот <strong>[[RegExpMatcher]]</strong>. Если имеет, вернется <strong>true</strong>.</li>
                   
                   <li>Если объект (<em>argument</em>) этого слота не имеет, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="same_value-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevalue"><em>SameValue ( x, y )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, являются ли входящие значения (<em>x</em> и <em>y</em>) одинаковыми.</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящих значений (<em>x</em> и <em>y</em>) <span>&#8594;</span> <strong>Type(x)</strong> и <strong>Type(y)</strong>. Если эти значения (<em>x</em> и <em>y</em>) имеют разные типы, вернется <strong>false</strong>.</li>
                   
                   <li>Если эти значения числа (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Number</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это <strong>NaN</strong>, они равны друг другу и вернется <strong>true</strong>.</li>
                           
                           <li>Если одно из значений это <strong>+0</strong>, а другое <strong>-0</strong>, они не равны друг другу и вернется <strong>false</strong>.</li>
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это одинаковое число, вернется <strong>true</strong>.</li>
                           
                           <li>Если же каждое из значений (<em>x</em> и <em>y</em>) это разное число, вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Когда эти значения не числа (<strong>Type(x)</strong> и <strong>Type(y)</strong> не <span>&#8594;</span> <em>Number</em>), тогда выполняется сравнение для других типов значений <span>&#8594;</span> <strong><a href="#same_value_non_number-abstr">SameValueNonNumber</a>(x, y)</strong>.</li>
                   
               </ol>
               
               <div id="same_value_zero-abstr">
                  
                   <p>Кроме данной операции сравнения есть <a href="https://www.ecma-international.org/ecma-262/#sec-samevaluezero"><strong><em>SameValueZero ( x, y )</em></strong></a>, которая имеет такую же семантику с одним отличием: если одно из входящих значений это <strong>+0</strong>, а другое <strong>-0</strong>, они равны друг другу и вернется <strong>true</strong>.</p>
                   
               </div>
               
           </article>
           
           <article id="same_value_non_number-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-samevaluenonnumber"><em>SameValueNonNumber ( x, y )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, являются ли входящие значения, которые не числовые (<em>x</em> и <em>y</em>), одинаковыми.</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящих значений (<em>x</em> и <em>y</em>) <span>&#8594;</span> <strong>Type(x)</strong> и <strong>Type(y)</strong>. Каждое из них принадлежит к одному и тому же типу и не является числовым (<strong>Type(x)</strong> и <strong>Type(y)</strong> не <span>&#8594;</span> <em>Number</em>).</li>
                   
                   <li>Если эти значения <strong>undefined</strong> (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Undefined</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если эти значения <strong>null</strong> (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Null</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если эти значения строки (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>String</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это строка такой же длины с одинаковой последовательностью элементов, вернется <strong>true</strong>.</li>
                           
                           <li>Если это разные строки (<em>x</em> и <em>y</em>), вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
                   <li>Если эти значения булевские (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это одинаковое булевское значение, вернется <strong>true</strong>.</li>
                           
                           <li>Если это разные булевские значения (<em>x</em> и <em>y</em>), вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если эти значения символы (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Symbol</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это одинаковый символ, вернется <strong>true</strong>.</li>
                           
                           <li>Если это разные символы (<em>x</em> и <em>y</em>), вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если эти значения объекты (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Object</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это одинаковый объект, вернется <strong>true</strong>.</li>
                           
                           <li>Если это разные объекты (<em>x</em> и <em>y</em>), вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
               </ol>
               
           </article>
           
           <article id="equality-compare-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><em>Равенство (x == y)</em></a></h4>
                   
               </header>
               
               <p>Это операция проверяет, равны ли входящие значения (<em>x</em> и <em>y</em>) другу другу.</p>
               
               <ol class="list">
                  
                   <li>Проверяется тип входящих значений (<em>x</em> и <em>y</em>) <span>&#8594;</span> <strong>Type(x)</strong> и <strong>Type(y)</strong>. Если они имеют одинаковый тип, выполняется операция строгого равенства <span>&#8594;</span> <strong><a href="#equality_compare_strict-abstr">x === y</a></strong>.</li>
                   
                   <li>Если одно из входящих значений это <strong>null</strong> (<strong>Type(x)</strong> или <strong>Type(y)</strong> <span>&#8594;</span> <em>Null</em>), а другое <strong>undefined</strong> (<strong>Type(y)</strong> или <strong>Type(x)</strong> <span>&#8594;</span> <em>Undefined</em>), вернется <strong>true</strong>.</li>
                   
                   <li>Если одно из входящих значений это число (<strong>Type(x)</strong> или <strong>Type(y)</strong> <span>&#8594;</span> <em>Number</em>), а другое строка (<strong>Type(y)</strong> или <strong>Type(x)</strong> <span>&#8594;</span> <em>String</em>), тогда значение со строкой преобразовывается в число и вернется результат равенства <span>&#8594;</span> <strong>x == <a href="#tonumber-abstr">ToNumber</a>(y)</strong> или <strong><a href="#tonumber-abstr">ToNumber</a>(x) == y</strong>.</li>
                   
                   <li>Если одно из входящих значений булевское (<strong>Type(x)</strong> или <strong>Type(y)</strong> <span>&#8594;</span> <em>Boolean</em>), тогда оно преобразовывается в число и вернется результат равенства <span>&#8594;</span> <strong><a href="#tonumber-abstr">ToNumber</a>(x) == y</strong> или <strong>x == <a href="#tonumber-abstr">ToNumber</a>(y)</strong>.</li>
                   
                   <li>Если одно из входящих значений это объект (<strong>Type(x)</strong> или <strong>Type(y)</strong> <span>&#8594;</span> <em>Object</em>), а другое либо строка, либо число, либо символ (<strong>Type(y)</strong> или <strong>Type(x)</strong> <span>&#8594;</span> либо <em>String</em>, либо <em>Number</em>, либо <em>Symbol</em>), тогда значение с объектом преобразовывается в примитивное и вернется результат равенства <span>&#8594;</span> <strong><a href="#toprim-abstr">ToPrimitive(x)</a> == y</strong> или <strong>x == <a href="#toprim-abstr">ToPrimitive(y)</a></strong>.</li>
                   
                   <li>Если входящие значения (<em>x</em> и <em>y</em>) не приравниваются друг к другу, вернется <strong>false</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="equality_compare_strict-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison"><em>Строгое равенство (x === y)</em></a></h4>
                   
               </header>
               
               <p>Это операция проверяет, равны ли входящие значения одного типа (<em>x</em> и <em>y</em>) другу другу.</p>
               
               <ol class="list">
                   
                   <li>Проверяется тип входящих значений (<em>x</em> и <em>y</em>) <span>&#8594;</span> <strong>Type(x)</strong> и <strong>Type(y)</strong>. Если эти значения (<em>x</em> и <em>y</em>) имеют разные типы, вернется <strong>false</strong>.</li>
                   
                   <li>Если входящие значения (<em>x</em> и <em>y</em>) это числа (<strong>Type(x)</strong> и <strong>Type(y)</strong> <span>&#8594;</span> <em>Number</em>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это <strong>NaN</strong>, они не равны друг другу и вернется <strong>false</strong>.</li>
                           
                           <li>Если одно из значений это <strong>+0</strong>, а другое <strong>-0</strong>, они равны друг другу и вернется <strong>true</strong>.</li>
                           
                           <li>Если каждое из значений (<em>x</em> и <em>y</em>) это одинаковое число, вернется <strong>true</strong>.</li>
                           
                           <li>Если же каждое из значений (<em>x</em> и <em>y</em>) это разное число, вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Когда эти значения не числа (<strong>Type(x)</strong> и <strong>Type(y)</strong> не <span>&#8594;</span> <em>Number</em>), тогда выполняется сравнение для других типов значений <span>&#8594;</span> <strong><a href="#same_value_non_number-abstr">SameValueNonNumber</a>(x, y)</strong>.</li>
                   
               </ol>
               
               <p>Семантика строгого равенства отличается от <a href="#same_value-abstr"><strong>SameValue</strong></a> в обращении с нулями и <strong>NaN</strong>.</p>
               
           </article>
           
           <article id="relation_compare-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison"><em>Относительное сравнение (x &#60; y)</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, какое из входящих значений (<em>x</em> и <em>y</em>) является больше другого. Она имеет булевский идентификатор <em>LeftFirst</em>, который определяет последовательность операций, что выполняются над входящими значениями (<em>x</em> и <em>y</em>). По дефолту параметр <em>LeftFirst</em> принимает значение <strong>true</strong> для вычислений слева направо. Если параметр <em>LeftFirst</em> имеет значение <strong>false</strong>, вычисления происходят справа налево.</p>
               
               <ol class="list">
                   
                   <li>Если вычисления происходят слева направо (<em>LeftFirst</em> <span>&#8594;</span> <strong>true</strong>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Сначала входящее значение слева (<em>x</em>) преобразовывается в примитивное (<em>px</em>) <span>&#8594;</span> <strong><a href="#toprim-abstr">ToPrimitive</a>(x, hint Number)</strong>.</li>
                           
                           <li>Затем входящее значение справа (<em>y</em>) преобразовывается в примитивное (<em>py</em>) <span>&#8594;</span> <strong><a href="#toprim-abstr">ToPrimitive</a>(y, hint Number)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если вычисления происходят справа налево (<em>LeftFirst</em> <span>&#8594;</span> <strong>false</strong>), тогда
                   
                       <ol class="list" type="a">
                           
                           <li>Сначала входящее значение справа (<em>y</em>) преобразовывается в примитивное (<em>py</em>) <span>&#8594;</span> <strong><a href="#toprim-abstr">ToPrimitive</a>(y, hint Number)</strong>.</li>
                           
                           <li>Затем входящее значение слева (<em>x</em>) преобразовывается в примитивное (<em>px</em>) <span>&#8594;</span> <strong><a href="#toprim-abstr">ToPrimitive</a>(x, hint Number)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если полученные примитивные значения (<em>px</em> и <em>py</em>) это строки, тогда для выражения <em>x &#60; y</em>
                   
                       <ol class="list" type="a">
                           
                           <li>Если строка справа (<em>py</em>) это префикс строки слева (<em>px</em>), вернется <strong>false</strong>.</li>
                           
                           <li>Если строка слева (<em>px</em>) это префикс строки справа (<em>py</em>), вернется <strong>true</strong>.</li>
                           
                           <li>Если же ни одна из строк не является префиксом другой, тогда в каждой строке рассматриваются первые элементы, которые не равны друг другу, с соответствующими индексами. Операция сравнения на них заканчивается и дальше она выполнятся не будет. Поэтому, если элементы с индексом 0 в кажой строке одинаковые, рассматриваются следующие с индексом 1 и тд. Каждый элемент строки это кодовая единица, что имеет свое целочисленное значение. Если целочисленное значение конкретного элемента в строке слева (<em>px</em>) меньше, чем значение элемента с соответствующим индексом в строке справа (<em>py</em>), вернется <strong>true</strong>. Если же целочисленное значение конкретного элемента в строке слева (<em>px</em>) больше, чем значение элемента с соответствующим индексом в строке справа (<em>py</em>), вернется <strong>false</strong>. К примеру, выражение <em>"ab" &#60; "az"</em> вернет <strong>true</strong>, поскольку элементы <em>"а"</em> одинаковые и сравнение поднимется индексом выше, а символ <em>"z"</em> имеет большее целочисленное значение, чем <em>"b"</em>. Если обе строки одинаковые, вернется <strong>false</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если полученные примитивные значения (<em>px</em> и <em>py</em>) не строки, тогда для выражения <em>x &#60; y</em>
                      
                       <ol class="list" type="a">
                          
                           <li>Они преобразовываются в числа (<em>nx</em> и <em>ny</em>) <span>&#8594;</span> <strong><a href="#tonumber-abstr">ToNumber</a>(px)</strong> и <strong><a href="#tonumber-abstr">ToNumber</a>(py)</strong>.</li>
                           
                           <li>Если одно из значений (<em>nx</em> или <em>ny</em>) это <strong>NaN</strong>, вернется <strong>undefined</strong>.</li>
                           
                           <li>Если каждое из значений (<em>nx</em> и <em>ny</em>) одинаковое, вернется <strong>false</strong>.</li>
                           
                           <li>Если одно из значений это <strong>+0</strong>, а другое <strong>-0</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>Если значение слева в выражении (<em>nx</em>) это <strong>+&#8734;</strong>, вернется <strong>false</strong>. Если значение справа в выражении (<em>ny</em>) это <strong>+&#8734;</strong>, вернется <strong>true</strong>.</li>
                           
                           <li>Если значение слева в выражении (<em>nx</em>) это <strong>-&#8734;</strong>, вернется <strong>true</strong>. Если значение справа в выражении (<em>ny</em>) это <strong>-&#8734;</strong>, вернется <strong>false</strong>.</li>
                           
                           <li>Если значение слева (<em>nx</em>) меньше значения справа (<em>ny</em>) в выражении, вернется <strong>true</strong>. Если больше, вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </li>
                   
               </ol>
               
           </article>
           
       </section>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-operations-on-objects">Операции над объектами</a></h3>
               
           </header>
           
           <article id="get-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-get-o-p"><em>Get ( O, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция извлекает значение из свойства (<em>P</em>) объекта (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Извлекается значение соответствующего свойства (<em>P</em>) объекта (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get">[[Get]]</a>(P, O)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="get_value-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getv"><em>GetV ( V, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция извлекает значение из свойства (<em>P</em>) ECMAScript значения (<em>V</em>). И если ECMAScript значение (<em>V</em>) это не объект, используется объектная оболочка для этого значения.</p>
               
               <ol class="list">
                  
                   <li>Создается объектная оболочка (<em>O</em>) для ECMAScript значения (<em>V</em>) <span>&#8594;</span> <strong><a href="#toobject-abstr">ToObject</a>(V)</strong>.</li>
                   
                   <li>Извлекается значение соответствующего свойства (<em>P</em>) объекта (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get">[[Get]]</a>(P, V)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="set-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-o-p-v-throw"><em>Set ( O, P, V, Throw )</em></a></h4>
                   
               </header>
               
               <p>Эта операция присваивает значение (<em>V</em>) свойству (<em>P</em>) объекта (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Соответствующему свойству (<em>P</em>) объекта (<em>O</em>) записывается значение (<em>V</em>) <span>&#8594;</span> <strong>O.<a href="#internal-set">[[Set]]</a>(P, V, O)</strong> (<em>succes</em>).</li>
                   
                   <li>Если значение (<em>V</em>) свойству (<em>P</em>) не записано (<em>success</em>) <span>&#8594;</span> <strong>false</strong>), при этом используется строгая семантика выполнения (<em>Throw</em> <span>&#8594;</span> <strong>true</strong>), тогда выкинет <strong>TypeError</strong>.</li>
                   
                   <li>В остальных случаях вернется результат (<em>success</em>) того, было ли записано новое значение (<em>V</em>) свойству (<em>P</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="create_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdataproperty"><em>CreateDataProperty ( O, P, V )</em></a></h4>
                   
               </header>
               
               <p>Эта операция создает новое собственное свойство (<em>P</em>) в объекте (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Новое свойство (<em>P</em>) в объекте (<em>O</em>) получает такое описание (<em>newDesc</em>) <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Создается новое собственное свойство (<em>P</em>) в объекте (<em>O</em>) и вернется результат <span>&#8594;</span> <strong>O.<a href="#internal-define_prop_o">[[DefineOwnProperty]]</a>(P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>По идее, такого свойства (<em>P</em>) не существует. Если же такое свойство (<em>P</em>) существует, при этом оно не настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>), или объект (<em>O</em>), где оно создается, не расширяемый (<strong>O.<a href="#internal-isextensible">[[IsExtensible]]</a>()</strong> <span>&#8594;</span> <strong>false</strong>), тогда вернется <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createmethodproperty"><em>CreateMethodProperty ( O, P, V )</em></a></h4>
                   
               </header>
            
               <p>Эта операция создает новое собственное свойство (<em>P</em>) в объекте (<em>O</em>), которое используется в качестве метода.</p>
               
               <ol class="list">
                  
                   <li>Новое свойство (<em>P</em>) в объекте (<em>O</em>) получает такое описание (<em>newDesc</em>) <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: false, <a href="#config_attr">[[Configurable]]</a>: true}</strong>.</li>
                   
                   <li>Создается новое собственное свойство (<em>P</em>) в объекте (<em>O</em>) и вернется результат <span>&#8594;</span> <strong>O.<a href="#internal-define_prop_o">[[DefineOwnProperty]]</a>(P, newDesc)</strong>.</li>
                   
               </ol>
               
               <p>По идее, такого свойства (<em>P</em>) не существует. Если же такое свойство (<em>P</em>) существует, при этом оно не настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: false</strong>), или объект (<em>O</em>), где оно создается, не расширяемый (<strong>O.<a href="#internal-isextensible">[[IsExtensible]]</a>()</strong> <span>&#8594;</span> <strong>false</strong>), тогда вернется <strong>false</strong>.</p>
               
           </article>
           
           <article id="create_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createdatapropertyorthrow"><em>CreateDataPropertyOrThrow ( O, P, V )</em></a></h4>
                   
               </header>
               
               <p>Эта операция создает новое собственное свойство (<em>P</em>) в объекте (<em>O</em>) и выкинет <strong>TypeError</strong>, если свойство (<em>P</em>) не было создано.</p>
               
               <ol class="list">
                  
                   <li>Создается новое собственное свойство (<em>P</em>) в объекте (<em>O</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(O, P, V)</strong> (<em>success</em>).</li>
                   
                   <li>Если новое свойство не было создано (<em>success</em> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
                   <li>Если свойство было создано (<em>success</em> <span>&#8594;</span> <strong>true</strong>), вернется результат (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="define_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-definepropertyorthrow"><em>DefinePropertyOrThrow ( O, P, desc )</em></a></h4>
                   
               </header>
               
               <p>Эта операция меняет существующее свойство (<em>P</em>) в объекте (<em>O</em>) и выкинет <strong>TypeError</strong>, если свойство не было изменено.</p>
               
               <ol class="list">
                  
                   <li>Вносятся изменения в существующее свойство (<em>P</em>) в объекте (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-define_prop_o">[[DefineOwnProperty]]</a>(P, desc)</strong> (<em>success</em>).</li>
                   
                   <li>Если существующее свойство не было изменено (<em>success</em> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
                   <li>Если свойство было изменено (<em>success</em> <span>&#8594;</span> <strong>true</strong>), вернется результат (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="delete_prop_throw-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-deletepropertyorthrow"><em>DeletePropertyOrThrow ( O, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция удаляет свойство (<em>P</em>) в объекте (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Удаляется соответствующее свойство (<em>P</em>) в объекте (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-delete">[[Delete]]</a>(P)</strong> (<em>success</em>).</li>
                   
                   <li>Если свойство не было удалено (<em>success</em> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
                   <li>Если свойство было удалено (<em>success</em> <span>&#8594;</span> <strong>true</strong>), вернется результат (<em>success</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="get_method-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getmethod"><em>GetMethod ( V, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция извлекает функцию из свойства (<em>P</em>) ECMAScript значения (<em>V</em>). И если ECMAScript значение (<em>V</em>) это не объект, используется объектная оболочка для этого значения.</p>
               
               <ol class="list">
                  
                   <li>Из соответствующего свойства (<em>P</em>) ECMAScript значения (<em>V</em>) извлекается значение (<em>func</em>) <span>&#8594;</span> <strong><a href="#get_value-abstr">GetV</a>(V, P)</strong>.</li>
                   
                   <li>Если полученное значение (<em>func</em>) это <strong>undefined</strong> или <strong>null</strong>, вернется <strong>undefined</strong>.</li>
                   
                   <li>Если полученное значение (<em>func</em>) относится к другим типам ECMAScript, проверяется, является ли оно функцией <span>&#8594;</span> <strong><a href="#iscallable-abstr">IsCallable</a>(func)</strong>. Если это значение (<em>func</em>) не функция (<a href="#iscallable-abstr"><strong>IsCallable</strong></a> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
                   <li>Если это значение (<em>func</em>) функция (<a href="#iscallable-abstr"><strong>IsCallable</strong></a> <span>&#8594;</span> <strong>true</strong>), оно вернется.</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasproperty"><em>HasProperty ( O, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, имеет ли объект (<em>O</em>) соответствующее свойство (<em>P</em>).</p>
               
               <ol class="list">
                  
                   <li>Проверяется наличие соответствующего свойства (<em>P</em>) в объекте (<em>O</em>) и вернется результат <span>&#8594;</span> <strong>O.<a href="#internal-has_prop">[[HasProperty]]</a>(P)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="has_prop_o-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasownproperty"><em>HasOwnProperty ( O, P )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, имеет ли объект (<em>O</em>) соответствующее собственное свойство (<em>P</em>).</p>
               
               <ol class="list">
                  
                   <li>Извлекается описание (<em>desc</em>) соответствующего собственного свойства (<em>P</em>) объекта (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_prop_o">[[GetOwnProperty]]</a>(P)</strong>.</li>
                   
                   <li>Если полученное значение (<em>desc</em>) это <strong>undefined</strong>, вернется <strong>false</strong>.</li>
                   
                   <li>Если полученное значение (<em>desc</em>) это описание свойства, вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="call-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-call"><em>Call ( F, V [ , argumentsList ] )</em></a></h4>
                   
               </header>
               
               <p>Эта операция вызывает функцию (<em>F</em>).</p>
               
               <ol class="list">
                  
                   <li>Если аргументы (<em>argumentsList</em>) не были переданы функции (<em>F</em>), вместо них используется пустой список.</li>
                   
                   <li>Проверяется, имеет ли входящее значение (<em>F</em>), что передается в качестве функции, внутренний метод вызова <span>&#8594;</span> <strong><a href="#iscallable-abstr">IsCallable</a>(F)</strong>. Если это значение (<em>F</em>) не имеет внутреннего метода вызова (<a href="#iscallable-abstr"><strong>IsCallable</strong></a> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
                   <li>Если это значение (<em>F</em>) имеет внутренний метод вызова (<a href="#iscallable-abstr"><strong>IsCallable</strong></a> <span>&#8594;</span> <strong>true</strong>), тогда оно вызывается и вернется результат <span>&#8594;</span> <strong>F.<a href="#internal-call">[[Call]]</a>(V, argumentsList)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="constructor-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-construct"><em>Construct ( F [ , argumentsList [ , newTarget ]] )</em></a></h4>
                   
               </header>
               
               <p>Эта операция создает объект из функции-конструктора (<em>F</em>).</p>
               
               <ol class="list">
                  
                   <li>Если не был передан объект (<em>newTarget</em>), что используется оператором <strong>new</strong>, тогда в качестве этого объекта используется функция-конструктор (<em>F</em>). В таком случае эта операция эквивалентна <strong>new F(...argumentsList)</strong>.</li>
                   
                   <li>Если аргументы (<em>argumentsList</em>) не были переданы функции-конструктору (<em>F</em>), вместо них используется пустой список.</li>
                   
                   <li>Создается объект, что является экземпляром функции-конструктора (<em>F</em>), и вернется результат <span>&#8594;</span> <strong>F.<a href="#internal-construct">[[Construct]]</a>(argumentsList, newTarget).</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="set_integr_level-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-setintegritylevel"><em>SetIntegrityLevel ( O, level )</em></a></h4>
                   
               </header>
               
               <p>Эта операция делает объект (<em>O</em>) и его собственные свойства неизменяемыми.</p>
               
               <ol class="list">
                  
                   <li>Входящий объект (<em>O</em>) становится нерасширяемым (<em>status</em>) <span>&#8594;</span> <strong>O.<a href="#internal-prev_exts">[[PreventExtensions]]</a>()</strong>.</li>
                   
                   <li>Если входящий объект (<em>O</em>) не стал нерясширяемым (<em>status</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если входящий объект (<em>O</em>) стал нерясширяемым (<em>status</em> <span>&#8594;</span> <strong>true</strong>), возвращается список его собственных свойств (<em>keys</em>) <span>&#8594;</span> <strong>O.<a href="internal-prop_keys_o">[[OwnPropertyKeys]]</a>()</strong>.</li>
                   
                   <li>Если объекту (<em>O</em>) передается изолированный уровень неизменяемости свойств (<em>level</em> <span>&#8594;</span> <strong>"sealed"</strong>), тогда каждое свойство (<em>k</em>), что в списке (<em>keys</em>), становится не настраиваемым <span>&#8594;</span> <strong><a href="#define_prop_throw-abstr">DefinePropertyOrThrow</a>(O, k, <a href="#prop_descr">PropertyDescriptor</a>{<a href="#config_attr">[[Configurable]]</a>: false})</strong>.</li>
                   
                   <li>Если объекту (<em>O</em>) передается фиксированный уровень неизменяемости свойств (<em>level</em> <span>&#8594;</span> <strong>"frozen"</strong>), тогда из каждого свойства (<em>k</em>), что в списке (<em>keys</em>),
                   
                       <ol class="list" type="a">
                           
                           <li>Извлекается описание (<em>currentDesc</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_prop_o">[[GetOwnProperty]]</a>(k)</strong>.</li>
                           
                           <li>Если полученное описание (<em>currentDesc</em>) не <strong>undefined</strong>,
                           
                               <ol class="list" type="i">
                                   
                                   <li>Проверяется, какое это свойство (<em>k</em>): доступа или данных <span>&#8594;</span> <strong><a href="№descr_access">IsAccessorDescriptor</a>(currentDesc)</strong>. Если это свойство (<em>k</em>) доступа (<strong><a href="№descr_access">IsAccessorDescriptor</a>(currentDesc)</strong> <span>&#8594;</span> <strong>true</strong>), тогда оно станет не настраиваемым, что отображается в описании (<em>desc</em>) <span>&#8594;</span> <strong><a href="#prop_descr">PropertyDescriptor</a>{<a href="#config_attr">[[Configurable]]</a>: false}</strong>.</li>
                                   
                                   <li>Если это свойство (<em>k</em>) данных (<strong><a href="№descr_access">IsAccessorDescriptor</a>(currentDesc)</strong> <span>&#8594;</span> <strong>false</strong>), тогда оно станет не настраиваемым и ему нельзя будет записать новое значение, что отображается в описании (<em>desc</em>) <span>&#8594;</span> <strong><a href="#prop_descr">PropertyDescriptor</a>{<a href="#write_attr">[[Writable]]</a>: false, <a href="#config_attr">[[Configurable]]</a>: false}</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Вносятся соответствующие изменения в свойство (<em>k</em>) <span>&#8594;</span> <strong><a href="#define_prop_throw-abstr">DefinePropertyOrThrow</a>(O, k, desc)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>После внесения соответствующих изменений во все собственные свойства (<em>keys</em>) объекта (<em>O</em>), вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="test_integr_level-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-testintegritylevel"><em>TestIntegrityLevel ( O, level )</em></a></h4>
                   
               </header>
               
               <p>Эта операция проверяет, являются ли объект (<em>O</em>) и его собственные свойства неизменяемыми.</p>
               
               <ol class="list">
                  
                   <li>Проверяется, является ли входящий объект (<em>O</em>) расширяемым (<em>status</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(O)</strong>.</li>
                   
                   <li>Если входящий объект (<em>O</em>) рясширяемый (<em>status</em> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если входящий объект (<em>O</em>) нерасширяемый, возвращается список его собственных свойств (<em>keys</em>) <span>&#8594;</span> <strong>O.<a href="internal-prop_keys_o">[[OwnPropertyKeys]]</a>()</strong>.</li>
                   
                   <li>Из каждого свойства (<em>k</em>), что в списке (<em>keys</em>),

                       <ol class="list" type="a">
                           
                           <li>Извлекается описание (<em>currentDesc</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_prop_o">[[GetOwnProperty]]</a>(k)</strong>.</li>
                           
                           <li>Если полученное описание (<em>currentDesc</em>) не <strong>undefined</strong>,
                           
                               <ol class="list" type="i">
                                   
                                   <li>Извлекается значение атрибута, что устанавливает настраиваемость свойства (<em>k</em>) <span>&#8594;</span> <strong>currentDesc.<a href="#config_attr">[[Configurable]]</a></strong>. Если полученное значение указывает на то, что свойство (<em>k</em>) настраиваемое (<strong>currentDesc.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>.</li>
                                   
                                   <li>Если свойство не настраиваемое (<strong>currentDesc.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>false</strong>), проверяется, какое оно (<em>k</em>): доступа или данных <span>&#8594;</span> <strong><a href="№descr_access">IsAccessorDescriptor</a>(currentDesc)</strong>. Если это свойство (<em>k</em>) данных (<strong><a href="#descr_data">IsDataDescriptor</a>(currentDesc)</strong> <span>&#8594;</span> <strong>true</strong>) и если объекту (<em>O</em>) передается фиксированный уровень неизменяемости свойств (<em>level</em> <span>&#8594;</span> <strong>"frozen"</strong>), извлекается значение атрибута, что устанавливает возможность записать новое значение свойству (<em>k</em>) <span>&#8594;</span> <strong>currentDesc.<a href="#write_attr">[[Writable]]</a></strong>. Если полученное значение указывает на то, что свойству (<em>k</em>) может быть записано новое значение (<strong>currentDesc.<a href="#write_attr">[[Writable]]</a></strong> <span>&#8594;</span> <strong>true</strong>), вернется <strong>false</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если объекту (<em>O</em>) передается изолированный уровень неизменяемости свойств (<em>level</em> <span>&#8594;</span> <strong>"sealed"</strong>) и каждое его свойство (<em>k</em>) не настраиваемое (<strong>currentDesc.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>false</strong>), или если объекту (<em>O</em>) передается фиксированный уровень неизменяемости свойств (<em>level</em> <span>&#8594;</span> <strong>"frozen"</strong>) и каждое его свойство не настраиваемое, а свойствам данных (<strong><a href="#descr_data">IsDataDescriptor</a>(currentDesc)</strong> <span>&#8594;</span> <strong>true</strong>) нельзя записать новые значения (<strong>currentDesc.<a href="#write_attr">[[Writable]]</a></strong> <span>&#8594;</span> <strong>false</strong>), вернется <strong>true</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="create_arr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-createarrayfromlist"><em>CreateArrayFromList ( elements )</em></a></h4>
                   
               </header>
               
               <p>Эта операция создает массив и списка элементов (<em>elements</em>).</p>
               
               <ol class="list">
                  
                   <li>Создается массив (<em>array</em>) без элементов <span>&#8594;</span> <a href="#"><strong>ArrayCreate(0)</strong></a>.</li>
                   
                   <li>Устанавливается начальный индекс (<em>n = 0</em>).</li>
                   
                   <li>Из каждого элемента (<em>e</em>), что в списке (<em>elements</em>),

                       <ol class="list" type="a">
                           
                           <li>Создается свойство (<em>status</em>) в полученном массиве (<em>array</em>), у которого ключом будет индекс (<em>n</em>) в виде строки, а его значением будет этот элемент (<em>e</em>) <span>&#8594;</span> <strong><a href="#create_prop-abstr">CreateDataProperty</a>(array, <a href="#tostring-abstr">ToString</a>(n), e)</strong>.</li>
                           
                           <li>После создания свойства (<em>status</em> <span>&#8594;</span> <strong>true</strong>), индекс увеличивается на единицу (<em>n + 1</em>) и свойства в массиве (<em>array</em>) создаются до тех пор, пока не закончатся все элементы (<em>e</em>) в списке (<em>elements</em>).</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Возвращается массив (<em>array</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="create_list-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-createlistfromarraylike"><em>CreateListFromArrayLike ( obj [ , elementTypes ] )</em></a></h4>
                   
               </header>
               
               <p>Эта операция создает список из значений свойств массивоподобного объекта (<em>obj</em>).</p>
               
               <ol class="list">
                  
                   <li>Этой операции по дэфолту передаются типы ECMAScript <strong>« Undefined, Null, Boolean, String, Symbol, Number, Object »</strong> (<em>elementTypes</em>), если они не установлены. Эти типы определяют, какие значения элементов могут быть в списке.</li>
                   
                   <li>Проверяется тип входящего значения  (<em>obj</em>), что передается в качестве массивоподобного объекта <span>&#8594;</span> <strong>Type(obj)</strong>. Если это значение (<em>obj</em>) не объект, выкинет <strong>TypeError</strong> (<strong>Type(obj)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>Если это объект (<strong>Type(obj)</strong> <span>&#8594;</span> <em>Object</em>), извлекается его длина (<em>len</em>) <span>&#8594;</span> <strong><a href="#tolength-abstr">ToLength</a>(<a href="#get-abstr">Get</a>(obj, "length"))</strong>.</li>
                   
                   <li>Создается пустой список (<em>list</em>).</li>
                   
                   <li>Устанавливается начальный индекс (<em>index = 0</em>).</li>
                   
                   <li>Пока индекс (<em>index</em>) меньше длины (<em>len</em>) массивоподобного объекта (<em>obj</em>) (<em>index <span>&#60;</span> len</em>), в список (<em>list</em>) добавляются элементы, следуя такому комплексу операций:
                       
                       <ol class="list" type="a">
                          
                           <li>Индекс (<em>index</em>) преобразовывается в строку (<em>indexName</em>), которая используется как ключ свойства массивоподобного объекта (<em>obj</em>) <span>&#8594;</span> <strong><a href="#tostring-abstr">ToString</a>(index)</strong>.</li>
                           
                           <li>Извлекается значение (<em>next</em>) свойства массивоподобного объекта (<em>obj</em>) за полученным ключом (<em>indexName</em>) <span>&#8594;</span> <strong><a href="get-abstr">Get</a>(obj, indexName)</strong>.</li>
                           
                           <li>Проверяется тип полученного значения (<em>next</em>) <span>&#8594;</span> <strong>Type(next)</strong>. Если оно (<em>next</em>) не принадлежит к входящим типам ECMAScript (<em>elementTypes</em>), выкинет <strong>TypeError</strong> (<strong>Type(next)</strong> не <span>&#8594;</span> <em>elementTypes</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                           
                           <li>Если это значение ECMAScript (<strong>Type(next)</strong> <span>&#8594;</span> <em>elementTypes</em>), оно добавляется в список (<em>list</em>) с конца.</li>
                           
                           <li>После добавления полученного значения (<em>next</em>) в список (<em>list</em>), индекс увеличивается на единицу (<em>index + 1</em>). Значения (<em>next</em>) добавляются в список (<em>list</em>) до тех пор, пока их количество не сравняется с длиной (<em>len</em>) массивоподобного объекта (<em>obj</em>).</li>
                           
                       </ol>
                       
                   </li>
                   
                   <li>Возвращается список (<em>list</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="invoke-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-invoke"><em>Invoke ( V, P [ , argumentsList ] )</em></a></h4>
                   
               </header>
               
               <p>Эта операция вызывает метод ECMAScript значения.</p>
               
               <ol class="list">
                  
                   <li>Если аргументы (<em>argumentsList</em>) не были переданы методу, вместо них используется пустой список.</li>
                   
                   <li>Извлекается значение (<em>func</em>) свойства (<em>P</em>) ECMAScript значения (<em>V</em>) <span>&#8594;</span> <strong><a href="#get_value-abstr">GetV</a>(V, P)</strong>.</li>
                   
                   <li>Вызывается полученное значение (<em>func</em>) и возвращается результат <span>&#8594;</span> <strong><a href="#call-abstr">Call</a>(func, V, argumentsList)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="ord_has_inst-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinaryhasinstance"><em>OrdinaryHasInstance ( C, O )</em></a></h4>
                   
               </header>
               
               <p>Эта операция определяет, является ли объект (<em>O</em>) экземпляром конструктора (<em>C</em>).</p>
               
               <ol class="list">
                  
                   <li>Проверяется, является ли входящее значение (<em>C</em>), что передается в качестве конструктора, функцией <span>&#8594;</span> <strong><a href="#iscallable-abstr">IsCallable</a>(C)</strong>. Если нет (<strong><a href="#iscallable-abstr">IsCallable</a>(C)</strong> <span>&#8594;</span> <strong>false</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это значение функция (<strong><a href="#iscallable-abstr">IsCallable</a>(C)</strong> <span>&#8594;</span> <strong>true</strong>), проверяется, имеет ли она внутренний слот <strong>[[BoundTargetFunction]]</strong>.
                   
                       <ol class="list" type="a">
                          
                           <li>Если имеет, извлекается значение (<em>BC</em>) этого слота <span>&#8594;</span> <strong>C.[[BoundTargetFunction]]</strong>.</li>
                           
                           <li>Проверяется, является ли входящий объект (<em>O</em>) экземпляром полученного значения (<em>BC</em>) из слота <strong>[[BoundTargetFunction]]</strong>, которое используется в качестве конструктора этого объекта <span>&#8594;</span> <strong><a href="#">InstanceofOperator</a>(O, BC)</strong>.</li>
                           
                       </ol>
                   
                   <li>Если функция-конструктор (<em>C</em>) не имеет внутреннего слота <strong>[[BoundTargetFunction]]</strong>, проверяется тип входящего значения (<em>O</em>), что передается в качестве объекта-экземпляра <span>&#8594;</span> <strong>Type(O)</strong>. Если это не объект (<strong>Type(O)</strong> не <span>&#8594;</span> <em>Object</em>), вернется <strong>false</strong>.</li>
                   
                   <li>Если это объект (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>), извлекается прототип входящей функции-конструктора (<em>P</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(C, "prototype")</strong>.</li>
                   
                   <li>Проверяется тип полученного значения прототипа (<em>P</em>) функции-конструктора <span>&#8594;</span> <strong>Type(P)</strong>. Если это не объект, выкинет <strong>TypeError</strong> (<strong>Type(P)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>Если это объект (<strong>Type(P)</strong> <span>&#8594;</span> <em>Object</em>), извлекается прототип объекта-экземпляра (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_proto">[[GetPrototypeOf]]</a>()</strong>.</li>
                   
                   <li>Если объект-экземпляр не имеет прототипа (<strong>O.<a href="#internal-get_proto">[[GetPrototypeOf]]</a>()</strong> <span>&#8594;</span> <strong>null</strong>), вернется <strong>false</strong>.</li>
                   
                   <li>Если имеет (<strong>O.<a href="#internal-get_proto">[[GetPrototypeOf]]</a>()</strong> <span>&#8594;</span> <strong>Object</strong>), тогда прототипы объекта-экземпляра (<em>O</em>) и конструктора (<em>P</em>) сравниваются между собой <span>&#8594;</span> <strong><a href="#same_value-abstr">SameValue</a>(P, O)</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="spec_constr-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-speciesconstructor"><em>SpeciesConstructor ( O, defaultConstructor )</em></a></h4>
                   
               </header>
               
               <p>Эта операция извлекает из объекта (<em>O</em>) значение его конструктора.</p>
               
               <ol class="list">
                  
                   <li>Из объекта (<em>O</em>) извлекается значение конструктора (<em>C</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(O, "constructor")</strong>.</li>
                   
                   <li>Если полученное значение конструктора (<em>C</em>) из объекта (<em>O</em>) это <strong>undefined</strong>, вернется дэфолтная функция-конструктор (<em>defaultConstructor</em>).</li>
                   
                   <li>Проверяется тип полученного значения конструктора (<em>C</em>) <span>&#8594;</span> <strong>Type(C)</strong>. Если это не объект, выкинет <strong>TypeError</strong> (<strong>Type(C)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>Если это объект (<strong>Type(C)</strong> <span>&#8594;</span> <em>Object</em>), из него извлекается функция (<em>S</em>), что используется в качестве конструктора <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(C, <a href="#symb_species">@@species</a>)</strong>.</li>
                   
                   <li>Если полученное значение это <strong>undefined</strong> или <strong>null</strong>, вернется дэфолтная функция-конструктор (<em>defaultConstructor</em>).</li>
                   
                   <li>Проверяется, является ли полученное значение функцией-конструктором (<em>S</em>) <span>&#8594;</span> <strong><a href="#isconstr-abstr">IsConstructor</a>(S)</strong>. Если это функция-конструктор (<strong><a href="#isconstr-abstr">IsConstructor</a>(S)</strong> <span>&#8594;</span> <strong>true</strong>), она (<em>S</em>) вернется.</li>
                   
                   <li>Если это не функция-конструктор (<strong><a href="#isconstr-abstr">IsConstructor</a>(S)</strong> <span>&#8594;</span> <strong>false</strong>), выкинет <strong>TypeError</strong>.</li>
                   
               </ol>
               
           </article>
           
           <article id="enum_prop_o-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-enumerableownproperties"><em>EnumerableOwnProperties ( O, kind )</em></a></h4>
                   
               </header>
               
               <p>Эта операция возвращает список значений из собственных перечисляемых свойств объекта (<em>O</em>).</p>
               
               <ol class="list">
                  
                   <li>Извлекается список собственных свойств (<em>ownKeys</em>) объекта (<em>O</em>) <span>&#8594;</span> <strong>O.<a href="#internal-prop_keys_o">[[OwnPropertyKeys]]</a>()</strong>.</li>
                   
                   <li>Создается пустой список (<em>properties</em>) для хранения значений из собственных свойств объекта (<em>O</em>).</li>
                   
                   <li>Для каждого свойства (<em>key</em>), что в списке (<em>ownKeys</em>), выполняются такие действия:
                   
                       <ol class="list" type="a">
                          
                           <li>Проверяется тип ключа свойства (<em>key</em>) <span>&#8594;</span> <strong>Type(key)</strong>. Если это строка (<strong>Type(key)</strong> <span>&#8594;</span> <em>String</em>), извлекается описание (<em>desc</em>) этого свойства (<em>key</em>) <span>&#8594;</span> <strong>O.<a href="#internal-get_prop_o">[[GetOwnProperty]]</a>(key)</strong>.</li>
                           
                           <li>Если полученное описание (<em>desc</em>) не <strong>undefined</strong>, из него извлекается значение атрибута, что определяет, является ли это свойство перечисляемым <span>&#8594;</span> <strong>desc.<a href="#enum_attr">[[Enumerable]]</a></strong>. Если свойство (<em>key</em>) перечисляемое (<strong>desc.<a href="#enum_attr">[[Enumerable]]</a></strong> <span>&#8594;</span> <strong>true</strong>), из него извлекаются значения, что соответствуют указанию (<em>kind</em>).
                           
                               <ol class="list" type="i">
                                  
                                   <li>Если указанию (<em>kind</em>) передается значение <strong>key</strong>, тогда в список (<em>properties</em>) вносится ключ свойства (<em>key</em>).</li>
                                   
                                   <li>Если указанию (<em>kind</em>) не передается значение <strong>key</strong>,
                                   
                                       <ol class="list">
                                          
                                           <li>Извлекается значение (<em>value</em>) свойства (<em>key</em>) <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(O, key)</strong>.</li>
                                           
                                           <li>Если указанию (<em>kind</em>) передается значение <strong>value</strong>, тогда в список (<em>properties</em>) вносится извлеченное значение (<em>value</em>) свойства (<em>key</em>).</li>
                                           
                                           <li>Если указанию (<em>kind</em>) не передается ни значение <strong>key</strong>, ни значение <strong>value</strong>, тогда оно будет <strong>key + value</strong>.
                                           
                                               <ol class="list" type="a">
                                                  
                                                   <li>Создается массив (<em>entry</em>), что состоит из имени свойства (<em>key</em>) и его значения (<em>value</em>) <span>&#8594;</span> <strong><a href="#create_arr-abstr">CreateArrayFromList</a>(« key, value »)</strong>.</li>
                                                   
                                                   <li>Полученный массив (<em>entry</em>) вносится в список (<em>properties</em>).</li>
                                                   
                                               </ol>
                                           
                                           </li>
                                           
                                       </ol>
                                   
                                   </li>
                                   
                               </ol>
                           
                           </li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Элементы полученного списка (<em>properties</em>) упорядычиваются таким способом, который вернул бы итератор (<em>Iterator</em>) от операции <a href="#"><strong>EnumerateObjectProperties</strong></a> вызванной с объектом (<em>O</em>).</li>
                   
                   <li>Вернется список (<em>properties</em>) из полученных значений собственных свойств объекта (<em>O</em>).</li>
                   
               </ol>
               
           </article>
           
           <article id="funct_realm-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getfunctionrealm"><em>GetFunctionRealm ( obj )</em></a></h4>
                   
               </header>
               
               <p>Эта операция возвращает область текущего контекста выполнения функции (<em>obj</em>).</p>
               
               <ol class="list">
                  
                   <li>Если функция (<em>obj</em>) имеет внутренний слот <strong>[[Realm]]</strong>, извлекается его значение и возвращается результат <span>&#8594;</span> <strong>obj.[[Realm]]</strong>.</li>
                   
                   <li>Если это (<em>obj</em>) связанная функция (<em>Bound Function</em>),
                   
                       <ol class="list" type="a">
                          
                           <li>Извлекается значение слота <strong>[[BoundTargetFunction]]</strong> (<em>target</em>) <span>&#8594;</span> <strong>obj.[[BoundTargetFunction]]</strong>.</li>
                           
                           <li>Извлекается область текущего контекста выполнения функции и возвращается результат <span>&#8594;</span> <strong><a href="#funct_realm-abstr">GetFunctionRealm</a>(target)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если эта функция (<em>obj</em>) прокси-объект (<em>Proxy Object</em>),
                   
                       <ol class="list" type="a">
                          
                           <li>Извлекается значение слота <strong>[[ProxyHandler]]</strong> (<em>proxyTarget</em>) <span>&#8594;</span> <strong>obj.[[ProxyHandler]]</strong>.</li>
                           
                           <li>Если оно <strong>null</strong>, выкинет <strong>TypeError</strong> (<strong>obj.[[ProxyHandler]]</strong> <span>&#8594;</span> <strong>null</strong> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                           
                           <li>Извлекается область текущего контекста выполнения функции и возвращается результат <span>&#8594;</span> <strong><a href="#funct_realm-abstr">GetFunctionRealm</a>(proxyTarget)</strong>.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если функция не имеет слота <strong>[[Realm]]</strong>, не является связанной (<em>Bound Function</em>) или прокси-объектом (<em>Proxy Object</em>), вернется ее область текущего контекста выполнения (<em>Realm Record</em>).</li>
                   
               </ol>
               
           </article>
           
       </section>
       
       <!--<section id="iterator_oper-abstr">
           
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-operations-on-iterator-objects">Операции над объектами-итераторами</a></h3>
               
           </header>
           
           <p>Объекты-итераторы еще будут рассматриваться далее, а пока пересмотрим те абстрактные операции, что выполняются над ними.</p>
           
           <article id="get_iter-abstr">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-getiterator">GetIterator ( obj [ , method ] )</a></h4>
                   
               </header>
               
               <p>Эта операция возвращает объект-итератор. Шаги выполнения:</p>
               
               <ol class="list">
                  
                   <li>Если метод (<em>method</em>) объекта (<em>obj</em>), что возвращает итератор не был передан, тогда вместо него будет использован тот метод, который возвращает дэфолтный итератор <span>&#8594;</span> <strong><a href="#get_method-abstr">GetMethod</a>(obj, <a href="#symb_iterator">@@iterator</a>)</strong>.</li>
                   
                   <li>Выполняется вызов этого метода (<em>method</em>) в контексте данного объекта (<em>obj</em>) <span>&#8594;</span> <strong><a href="#call-abstr">Call</a>(method, obj)</strong> (<em>iterator</em>).</li>
                   
                   <li>И если вернувшийся результат (<em>iterator</em>) не является объектом, выкинет <strong>TypeError</strong> (<strong>Type(iterator)</strong> не <span>&#8594;</span> <em>Object</em> <span>&#8594;</span> <strong>TypeError</strong>).</li>
                   
                   <li>В ином случае возвращается итератор (<em>iterator</em>).</li>

               </ol>
               
           </article>
           
       </section>-->
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-executable-code-and-execution-contexts">Выполняемый код и контекст выполнения</a></h2>
           
       </header>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-lexical-environments">Лексическое окружение</a></h3>
               
           </header>
           
           <p>Лексическое окружение это участок кода, который создается каждый раз, когда объявляется функция, применяется выражение блока или выполняется условие <em>Catch</em> выражения <em>Try</em>. Лексическое окружение определяет связь своих идентификаторов с переменными и функциями программы ECMAScript на основании вложенности, когда одно окружение находится внутри другого. Идентификатор это привязка к конкретному окружению.</p>
           
           <section id="envir_record">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-environment-records">Записи окружения</a></h4>
                   
               </header>
               
               <p>С точки зрения ECMAScript движка, лексическое окружение это запись окружения (<em>Environment Record</em>) с ссылкой на внешнее лексическое окружение, если оно существует. (Для удобства будем называть запись окружения просто окружением.) Выделяют:</p>
               
               <ul class="list">
                  
                   <li>декларативное окружение, где идентификаторы связываются с ECMAScript значениями и</li>
                   
                   <li>окружение объекта, где идентификаторы связываются со свойствами определенного объекта.</li>
                   
               </ul>
               
                <p>К декларативному окружению относится окружение функции и модуля. А к окружению объекта частично относится глобальное окружение, что используется для глобальных объявлений.</p>
                
               <p>Есть абстрактные методы, что работают с окружением:</p>
               
               <table>
                   <tr>
                       <th>Метод</th>
                       <th>Для чего используется</th>
                   </tr>
                   <tr>
                       <td><strong>HasBinding(N)</strong></td>
                       <td>Определяет, имеет ли окружение определенную привязку (<em>N</em>).</td>
                   </tr>
                   <tr>
                       <td><strong>CreateMutableBinding(N, D)</strong></td>
                       <td>Создает в окружении новую изменяемую привязку с определенным именем (<em>N</em>). Такая привязка еще не инициализирована.  Также этот метод принимает булевский идентификатор (<em>D</em>), который обозначает, может ли привязка быть удалена: <strong>true</strong> означает, что привязка удаляемая.</td>
                   </tr>
                   <tr>
                       <td><strong>CreateImmutableBinding(N, S)</strong></td>
                       <td>Создает в окружении новую неизменяемую привязку с определенным именем (<em>N</em>). Такая привязка еще не инициализирована. Также этот метод принимает булевский идентификатор (<em>S</em>), который указывает на строгость привязки: <strong>true</strong> означает, что привязка строгая.</td>
                   </tr>
                   <tr>
                       <td><strong>InitializeBinding(N, V)</strong></td>
                       <td>Инициализирует в окружении новосозданную привязку с определенным именем (<em>N</em>) и значением (<em>V</em>). Когда привязка создается, она немедленно инициализируется.</td>
                   </tr>
                   <tr>
                       <td><strong>SetMutableBinding(N, V, S)</strong></td>
                       <td>Записывает новое значение (<em>V</em>) существующей изменяемой привязке с определенным именем (<em>N</em>) в окружении. Такая привязка обычно уже существует и инициализирована, а если нет, тогда она создается как изменяемая и инициализируется. Также этот метод принимает булевский идентификатор (<em>S</em>), который указывает на строгость привязки: <strong>true</strong> означает, что привязка строгая.</td>
                   </tr>
                   <tr>
                       <td><strong>GetBindingValue(N, S)</strong></td>
                       <td>Возвращает значение (<em>V</em>) существующей привязки с определенным именем (<em>N</em>) в окружении. Также этот метод принимает булевский идентификатор (<em>S</em>), который указывает на строгость привязки: <strong>true</strong> означает, что привязка строгая.</td>
                   </tr>
                   <tr>
                       <td><strong>DeleteBinding(N)</strong></td>
                       <td>Удаляет из окружения привязку с определенным именем (<em>N</em>), что обозначена как удаляемая.</td>
                   </tr>
                   <tr>
                       <td><strong>HasThisBinding()</strong></td>
                       <td>Определяет, устанавливает ли окружение привязку <strong>this</strong>.</td>
                   </tr>
                   <tr>
                       <td><strong>HasSuperBinding()</strong></td>
                       <td>Определяет, устанавливает ли окружение привязку метода <strong>super</strong>.</td>
                   </tr>
                   <tr>
                       <td><strong>WithBaseObject()</strong></td>
                       <td>Если окружение связано с выражением <strong>with</strong>, вернется связанный объект. В ином случае вернется <strong>undefined</strong>.</td>
                   </tr>
               </table>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records">Декларативное</a> окружение</h4>
                       
                   </header>
                   
                   <p>Декларативное окружение связано с областью видимости программы ECMAScript, что содержит объявления переменных, <em>const</em>, <em>let</em>, классов, модулей, импорта и/или функций. Эти идентификаторы, что создаются внутри области видимости и определены объявлениями, привязываются к окружению.</p>
                   
                   <p>Методы, применяемые в декларативном окружении:</p>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasbinding-n"><em>HasBinding ( N )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Если в декларативном окружении (<em>envRec</em>) существует определенная привязка (<em>N</em>), вернется <strong>true</strong>.</li>
                           
                           <li>Если ее нет, вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createmutablebinding-n-d"><em>CreateMutableBinding ( N, D )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>В окружении (<em>envRec</em>) создается изменяемая привязка (<em>N</em>).</li>
                           
                           <li>Возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-createimmutablebinding-n-s"><em>CreateImmutableBinding ( N, S )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>В окружении (<em>envRec</em>) создается неизменяемая привязка (<em>N</em>).</li>
                           
                           <li>Возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article id="init_binding_env">
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-initializebinding-n-v"><em>InitializeBinding ( N, V )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Новосозданной привязке (<em>N</em>) в окружении (<em>envRec</em>) присваивается значение (<em>V</em>).</li>
                           
                           <li>Данная привязка (<em>N</em>) инициализируется в окружении (<em>envRec</em>).</li>
                           
                           <li>Возвращается завершающая запись <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-setmutablebinding-n-v-s"><em>SetMutableBinding ( N, V, S )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Если в окружении (<em>envRec</em>) нет определенной привязки (<em>N</em>),
                           
                               <ol class="list" type="a">
                                  
                                   <li>При этом семантика выполнения строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>ReferenceError</strong>.</li>
                                   
                                   <li>Если семантика выполнения не строгая (<em>S</em> <span>&#8594;</span> <strong>false</strong>), в окружении (<em>envRec</em>) создается данная привязка (<em>N</em>), которая обозначена как удаляемая <span>&#8594;</span> <strong>envRec.<a href="#">CreateMutableBinding</a>(N, true)</strong>.</li>
                                   
                                   <li>Созданная привязка (<em>N</em>) в окружении (<em>envRec</em>) инициализируется со значением (<em>V</em>) <span>&#8594;</span> <strong>envRec.<a href="#">InitializeBinding</a>(N, V)</strong>.</li>
                                   
                                   <li>Возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Если в окружении (<em>envRec</em>) уже существует эта привязка (<em>N</em>) как строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>) и она не была инициализирована, выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>Если в окружении (<em>envRec</em>) уже существует эта привязка (<em>N</em>) как изменяемая и она инициализирована, ей присвивается новое значение (<em>V</em>).</li>
                           
                           <li>Если в окружении (<em>envRec</em>) уже существует эта привязка (<em>N</em>) как неизменяемая и она инициализирована,
                           
                               <ol class="list">
                                  
                                   <li>При этом не является строгой (<em>S</em> <span>&#8594;</span> <strong>false</strong>), ее текущее значение не будет перезаписано.</li>
                                   
                                   <li>Если эта привязка (<em>N</em>) строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-getbindingvalue-n-s"><em>GetBindingValue ( N, S )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Если в окружении определенная привязка (<em>N</em>) не инициализирована, выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>Если она инициализирована, вернется ее значение (<em>V</em>).</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-deletebinding-n"><em>DeleteBinding ( N )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Если в окружении (<em>envRec</em>) определенная привязка (<em>N</em>) не может быть удалена, поскольку она не была обозначена для удаления (<em>D</em> <span>&#8594;</span> <strong>false</strong>), или из-за других причин, вернется <strong>false</strong>.</li>
                           
                           <li>Привязка (<em>N</em>) удаляется из окружения (<em>envRec</em>).</li>
                           
                           <li>Вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hasthisbinding"><em>HasThisBinding ( )</em></a></h4>
                           
                       </header>
                       
                       <p>Обычное декларативное окружение не предоставляет привязки <strong>this</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-hassuperbinding"><em>HasSuperBinding ( )</em></a></h4>
                           
                       </header>
                       
                       <p>Обычное декларативное окружение не предоставляет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-declarative-environment-records-withbaseobject">WithBaseObject ( )</a></h4>
                           
                       </header>
                       
                       <p>Декларативное окружение всегда возвращает <strong>undefined</strong> в качестве связанного объекта для выражения <strong>with</strong>.</p>
                       
                   </article>
                   
                   <section>
                      
                       <header class="header header--center">
                          
                           <h4>Окружение <a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records">функции</a></h4>
                           
                       </header>
                       
                       <p>Окружение функции декларативное и используется для представления области видимости функции. Если функция не стрелочная (<em>Arrow Function</em>), ее окружение предоставляет привязку <strong>this</strong>. Если не стрелочная функция имеет ссылку <strong>super</strong>, тогда ее окружение содержит состояние, что используется для выполнения метода <strong>super</strong> внутри функции.</p>
                       
                       <p>В записи окружения функции есть дополнительные поля состояния:</p>
                       
                       <table>
                           <tr>
                               <th>Имя поля</th>
                               <th>ECMAScript значение</th>
                               <th>Смысловое значение</th>
                           </tr>
                           <tr id="this_value_field">
                               <td><em>[[ThisValue]]</em></td>
                               <td>Любое ECMAScript значение</td>
                               <td>Здесь хранится значение <strong>this</strong>, что используется для вызова функции.</td>
                           </tr>
                           <tr id="this_bind_status_field">
                               <td><em>[[ThisBindingStatus]]</em></td>
                               <td><strong>"lexical"</strong> | <strong>"initialized"</strong> | <strong>"uninitialized"</strong></td>
                               <td><strong>"lexical"</strong> означает, что функция стрелочная и не имеет локально установленного значения <strong>this</strong>.</td>
                           </tr>
                           <tr id="func_object_field">
                               <td><em>[[FunctionObject]]</em></td>
                               <td><em>Object</em></td>
                               <td>Здесь хранится функция, вызов которой создает окружение.</td>
                           </tr>
                           <tr id="home_object_field">
                               <td><em>[[HomeObject]]</em></td>
                               <td><em>Object</em> | <strong>undefined</strong></td>
                               <td>Если функция, которая не является стрелочной, обращается к методу <strong>super</strong>, тогда значение здесь это объект, с которым эта функция связана. <strong>undefined</strong> это дэфолтное значение и означает, что такого объекта нет.</td>
                           </tr>
                           <tr id="new_target_field">
                               <td><em>[[NewTarget]]</em></td>
                               <td><em>Object</em> | <strong>undefined</strong></td>
                               <td>Если окружение было создано внутренним методом <a href="#internal-construct"><strong>[[Construct]]</strong></a>, тогда значение здесь это объект, который использует оператор <strong>new</strong>.</td>
                           </tr>
                       </table>
                       
                       <p>Окружение функции поддерживает все методы, применяемые в декларативном окружении, только с некоторыми отличиями в <a href="#"><strong>HasThisBinding</strong></a> и <a href="#"><strong>HasSuperBinding</strong></a>. В окружении функции используются еще дополнительные методы:</p>
                       
                       <table>
                           <tr>
                               <th>Метод</th>
                               <th>Для чего используется</th>
                           </tr>
                           <tr>
                               <td><strong>BindThisValue(V)</strong></td>
                               <td>Присваивает значение привязке <strong>this</strong> и инициализирует ее в окружении функции. В окружении стрелочной функции (<a href="#this_bind_status_field"><strong>[[ThisBindingStatus]]</strong></a>: <strong>"lexical"</strong>) нет своей привязки <strong>this</strong>, поэтому в нем этот метод не используется.</td>
                           </tr>
                           <tr>
                               <td><strong>GetThisBinding()</strong></td>
                               <td>Возвращает значение привязки <strong>this</strong> окружения функции. В окружении стрелочной функции (<a href="#this_bind_status_field"><strong>[[ThisBindingStatus]]</strong></a>: <strong>"lexical"</strong>) нет своей привязки <strong>this</strong>, поэтому в нем этот метод не используется.</td>
                           </tr>
                           <tr>
                               <td><strong>GetSuperBase()</strong></td>
                               <td>Возвращает объект, что является основанием для обращения к методу <strong>super</strong> внутри функции. <strong>undefined</strong> означает, что метод <strong>super</strong> не связывает функцию ни с каким объектом.</td>
                           </tr>
                       </table>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-bindthisvalue"><em>BindThisValue ( V )</em></a></h4>

                           </header>

                           <ol class="list">

                               <li>Извлекается состояние привязки <strong>this</strong> в окружении функции (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong>. Если эта привязка <strong>this</strong> уже инициализирована, выкинет <strong>ReferenceError</strong> (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"initialized"</strong> <span>&#8594;</span> <strong>ReferenceError</strong>).</li>

                               <li>Если привязка <strong>this</strong> в окружении функции (<em>envRec</em>) не инициализирована (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"uninitialized"</strong>), ей присваивается значение (<em>V</em>) <span>&#8594;</span> <strong>envRec.<a href="#this_value_field">[[ThisValue]]</a> = V</strong>.</li>

                               <li>После этого привязка <strong>this</strong> инициализируется <span>&#8594;</span> <strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a> = "initialized"</strong>.</li>

                               <li>Возвращается значение <strong>this</strong> (<em>V</em>).</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-hasthisbinding"><em>HasThisBinding ( )</em></a></h4>

                           </header>

                           <ol class="list">

                               <li>Извлекается состояние привязки <strong>this</strong> в окружении функции (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong>. Если привязка лексическая (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"lexical"</strong>), вернется <strong>false</strong>.</li>

                               <li>Если привязка не лексическая (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> не <span>&#8594;</span> <strong>"lexical"</strong>), вернется <strong>true</strong>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-hassuperbinding"><em>HasSuperBinding ( )</em></a></h4>

                           </header>

                           <ol class="list">

                               <li>Извлекается состояние привязки <strong>this</strong> в окружении функции (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong>. Если привязка лексическая (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"lexical"</strong>), вернется <strong>false</strong>.</li>

                               <li>Если привязка не лексическая (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> не <span>&#8594;</span> <strong>"lexical"</strong>), извлекается объект привязки <strong>super</strong> в окружении функции (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#home_object_field">[[HomeObject]]</a></strong>. Если функция не связана ни с каким объектом через свойство <strong>super</strong> (<strong>envRec.<a href="#home_object_field">[[HomeObject]]</a></strong> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>false</strong>. Если такой объект есть (<strong>envRec.<a href="#home_object_field">[[HomeObject]]</a></strong> <span>&#8594;</span> <em>Object</em>), вернется <strong>true</strong>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-function-environment-records-getthisbinding"><em>GetThisBinding ( )</em></a></h4>

                           </header>

                           <ol class="list">
                               
                               <li>Извлекается состояние привязки <strong>this</strong> в окружении функции (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong>. Если эта привязка <strong>this</strong> не инициализирована, выкинет <strong>ReferenceError</strong> (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"uninitialized"</strong> <span>&#8594;</span> <strong>ReferenceError</strong>).</li>

                               <li>Если привязка <strong>this</strong> в окружении функции (<em>envRec</em>) инициализирована (<strong>envRec.<a href="#this_bind_status_field">[[ThisBindingStatus]]</a></strong> <span>&#8594;</span> <strong>"initialized"</strong>), извлекается значение этой привязки и вернется результат <span>&#8594;</span> <strong>envRec.<a href="#this_value_field">[[ThisValue]]</a></strong>.</li>

                           </ol>

                       </article>
                       
                       <article>
                      
                           <header class="header header--center">

                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-getsuperbase"><em>GetSuperBase ( )</em></a></h4>

                           </header>

                           <ol class="list">

                               <li>Извлекается объект (<em>home</em>), с которым связывается функция через метод <strong>super</strong> <span>&#8594;</span> <em>envRec.<a href="#home_object_field">[[HomeObject]]</a></em>.</li>

                               <li>Если привязка <strong>super</strong> не связывает функцию ни с каким объектом (<em>home</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>undefined</strong>.</li>
                               
                               <li>Если такой объект есть (<em>home</em> <span>&#8594;</span> <em>Object</em>), извлекается его прототип и вернется результат <span>&#8594;</span> <strong>home.<a href="#internal-get_proto">[[GetPrototypeOf]]</a>()</strong>.</li>

                           </ol>

                       </article>
                       
                   </section>
                   
                   <section>
                      
                       <header class="header header--center">
                          
                           <h4>Окружение <a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records">модуля</a></h4>
                           
                       </header>
                       
                       <p>Окружение модуля декларативное и используется для представления внешней области видимости модуля. В окружении модуля есть неизменяемые непрямые привязки импорта, которые дают доступ к необходимым целевым привязкам, что существуют внутри модуля. Привязки в окружении модуля являются строгими (<em>S</em> <span>&#8594;</span> <strong>true</strong>).</p>
                       
                       <p>Окружение модуля поддерживает все методы, применяемые в декларативном окружении, только с некоторыми отличиями в <a href="#"><strong>GetBindingValue</strong></a>, <a href="#"><strong>DeleteBinding</strong></a>, <a href="#"><strong>HasThisBinding</strong></a> и <a href="#"><strong>GetThisBinding</strong></a>. В этом окружении используются также дополнительные методы:</p>
                       
                       <table>
                           <tr>
                               <th>Метод</th>
                               <th>Для чего используется</th>
                           </tr>
                           <tr>
                               <td><strong>CreateImportBinding(N, M, N2)</strong></td>
                               <td>Создает новую неизменяемую непрямую привязку импорта (<em>N</em>) в окружении модуля (<em>M</em>), которая ссылается на целевую привязку (<em>N2</em>) в этом модуле. При обращении к непрямой привязке (<em>N</em>) неявно извлекается значение целевой (<em>N2</em>).</td>
                           </tr>
                           <tr>
                               <td><strong>GetThisBinding()</strong></td>
                               <td>Возвращает значение привязки <strong>this</strong> в окружении модуля.</td>
                           </tr>
                       </table>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-getbindingvalue-n-s"><em>GetBindingValue ( N, S )</em></a></h4>
                               
                           </header>
                           
                           <ol class="list">
                              
                               <li>Если это непрямая привязка импорта (<em>N</em>), тогда
                               
                                   <ol class="list" type="a">
                                       
                                       <li>Извлекается лексическое окружение функции (<em>targetEnv</em>), куда импортируется целевая привязка (<em>N2</em>) модуля (<em>M</em>) <span>&#8594;</span> <strong>M.[[Environment]]</strong>. Если такого окружения нет (<em>targetEnv</em> <span>&#8594;</span> <strong>undefined</strong>), вернется <strong>ReferenceError</strong>.</li>
                                       
                                       <li>Полученное окружение используется в качестве окружения этого модуля (<em>targetER</em>).</li>
                                       
                                       <li>Извлекается значение целевой привязки (<em>N2</em>) в окружении модуля (<em>targetER</em>) и вернется результат <span>&#8594;</span> <strong>targetER.<a href="#">GetBindingValue</a>(N2, true)</strong>.</li>
                                       
                                   </ol>
                               
                               </li>
                               
                               <li>Если привязка (<em>N</em>) в окружении модуля (<em>envRec</em>) прямая и неинициализированная, вернется <strong>ReferenceError</strong>.</li>
                               
                               <li>Если привязка (<em>N</em>) в окружении модуля (<em>envRec</em>) прямая и инициализированная, вернется ее значение (<em>V</em>).</li>
                               
                           </ol>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-deletebinding-n"><em>DeleteBinding ( N )</em></a></h4>
                               
                           </header>
                           
                           <p>Метод <a href="#"><strong>DeleteBinding</strong></a> не вызывается к привязкам в окружении модуля.</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-hasthisbinding"><em>HasThisBinding ( )</em></a></h4>
                               
                           </header>
                           
                           <p>Окружение модуля имеет привязку <strong>this</strong>, поэтому вернется <strong>true</strong>.</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-module-environment-records-getthisbinding"><em>GetThisBinding ( )</em></a></h4>
                               
                           </header>
                           
                           <p>Окружение модуля не имеет своего значения <strong>this</strong>, поэтому вернется <strong>undefined</strong>.</p>
                           
                       </article>
                       
                       <article>
                          
                           <header class="header header--center">
                              
                               <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-createimportbinding"><em>CreateImportBinding ( N, M, N2 )</em></a></h4>
                               
                           </header>
                           
                           <ol class="list">
                              
                               <li>Создается неизменяемая непрямая привязка в окружении модуля (<em>envRec</em>) с определенным именем (<em>N</em>), что ссылается на целевую привязку (<em>N2</em>) в модуле (<em>M</em>). Эта новая привязка инициализируется в окружении модуля (<em>envRec</em>).</li>
                               
                               <li>Возвращается запись завершения <span>&#8594;</span> <a href="#"><strong>NormalCompletion(empty)</strong></a>.</li>
                               
                           </ol>
                           
                       </article>
                       
                   </section>
                   
               </section>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4>Окружение <a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records">объекта</a></h4>
                       
                   </header>
                   
                   <p>Данное окружение создается объектом и привязывается к нему. Такой объект называется объектом привязки. В окружении объекта идентификаторами являются его свойства в виде строки. Если ключ свойства это не строка, тогда данное свойство не является идентификатором в окужении своего объекта. К идентификаторам окружения объекта относятся собственные и унаследованные свойства. Поскольку свойства динамически добавляются в объект или удаляются из него, набор идентификаторов в таком окружении меняется. Поэтому каждая привязка, что создается в результате таких побочных действий, в окружении своего объекта изменяемая. Неизменяемых привязок в окружении объекта не существует.</p>
                   
                   <p>Окружение объекта, что создается для выражения <strong>with</strong>, предоставляет свой объект как неявно определенное значение <strong>this</strong> для вызовов функции. Данную возможность контролирует указатель <em>withEnvironment</em>, который определяет, используется ли окружение объекта для выражения <strong>with</strong>: <strong>false</strong> означает, что не используется (это дэфолтное значение). Этот указатель существует для каждого окружения объекта.</p>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-hasbinding-n"><em>HasBinding ( N )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Проверяется, имеет ли объект привязки (<em>bindings</em>) соответствующее свойство (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(bindings, N)</strong> (<em>foundBinding</em>).</li>
                           
                           <li>Если в этом объекте (<em>bindings</em>) такого свойства (<em>N</em>) нет (<em>foundBinding</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>false</strong>.</li>
                           
                           <li>Если в этом объекте (<em>bindings</em>) такое свойство (<em>N</em>) есть (<em>foundBinding</em> <span>&#8594;</span> <strong>true</strong>) и его окружение (<em>envRec</em>) не используется выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>true</strong>.</li>
                           
                           <li>Если в этом объекте (<em>bindings</em>) такое свойство (<em>N</em>) есть (<em>foundBinding</em> <span>&#8594;</span> <strong>true</strong>) и его окружение (<em>envRec</em>) используется выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>true</strong>), извлекается объект, у которого свойства не являются привязками окружения для выражения <strong>with</strong> (<em>unscopables</em>) <span>&#8594;</span> <strong><a href="get-abstr">Get</a>(bindings, <a href="#symb_unscop">@@unscopables</a>)</strong>.</li>
                           
                           <li>Проверяется тип полученного значения <span>&#8594;</span> <strong>Type(unscopables)</strong>. Если получили объект (<strong>Type(unscopables)</strong> <span>&#8594;</span> <em>Object</em>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Из него (<em>unscopables</em>) извлекается значение соответствующего свойства (<em>N</em>), которое преобразовывается в булевское значение (<em>blocked</em>) <span>&#8594;</span> <strong><a href="#toboolean-abstr">ToBoolean</a>(<a href="#get-abstr">Get</a>(unscopables, N))</strong>. Предполагается, что полученный объект (<em>unscopables</em>) и есть тем объектом привязки (<em>bindings</em>).</li>
                                   
                                   <li>Если такое свойство в этом объекте существует (<em>blocked</em> <span>&#8594;</span> <strong>true</strong>), оно исключено как привязка из окружения для выражения <strong>with</strong> и вернется <strong>false</strong>.
                                   </li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Если нет такого объекта (<em>unscopables</em>), у которого свойства не являются привязками окружения для выражения <strong>with</strong> (<strong>Type(unscopables)</strong> <span>&#8594;</span> <em>Undefined</em>); или когда он есть (<strong>Type(unscopables)</strong> <span>&#8594;</span> <em>Object</em>) и в нем нет соответствующего свойства (<em>blocked</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-createmutablebinding-n-d"><em>CreateMutableBinding ( N, D )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Создается определенное свойство (<em>N</em>) в объекте привязки (<em>bindings</em>) и вернется результат <span>&#8594;</span> <strong><a href="#define_prop_throw-abstr">DefinePropertyOrThrow</a>(bindings, N, <a href="#prop_desc">PropertyDescriptor</a>{<a href="#value_attr">[[Value]]</a>: undefined, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: D})</strong>. Если свойство с таким именем (<em>N</em>) уже существует, оно заменяется или скрывается (в том случае, когда такой метод унаследованный).</li>
                           
                       </ol>
                       
                       <p>Это свойство инициализируется изначально со значением <strong>undefined</strong>. Если привязка отмечается как удаляемая (<em>D</em> <span>&#8594;</span> <strong>true</strong>), тогда это свойство настраиваемое (<a href="#config_attr"><strong>[[Configurable]]</strong></a> <span>&#8594;</span> <strong>true</strong>), и наоборот.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-createimmutablebinding-n-s"><em>CreateImmutableBinding ( N, S )</em></a></h4>
                           
                       </header>
                       
                       <p>Данный метод не применяется в окружении объекта, поскольку все привязки в нем являются изменяемыми.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-initializebinding-n-v"><em>InitializeBinding ( N, V )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Данная привязка (<em>N</em>) инициализируется в окружении объекта (<em>envRec</em>).</li>
                           
                           <li>Этой привязке (<em>N</em>) в окружении объекта (<em>envRec</em>) присваивается значение (<em>V</em>) и вернется результат <span>&#8594;</span> <strong>envRec.<a href="#">SetMutableBinding</a>(N, V, false)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/#sec-object-environment-records-setmutablebinding-n-v-s"><em>SetMutableBinding ( N, V, S )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Определенному свойству (<em>N</em>) объекта привязки (<em>bindings</em>) записывается новое значение (<em>V</em>) с указанием на строгость (<em>S</em>) и вернется результат <span>&#8594;</span> <strong><a href="#set-abstr">Set</a>(bindings, N, V, S)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                    <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-getbindingvalue-n-s"><em>GetBindingValue ( N, S )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Проверяется, имеет ли объект привязки (<em>bindings</em>) соответствующее свойство (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop-abstr">HasProperty</a>(bindings, N)</strong> (<em>value</em>).</li>
                           
                           <li>Если такого свойства (<em>N</em>) нет (<em>value</em> <span>&#8594;</span> <strong>false</strong>) и привязка не строгая (<em>S</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>undefined</strong>; а если привязка строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>ReferenceError</strong>.</li>
                           
                           <li>Если такое свойство (<em>N</em>) существует (<em>value</em> <span>&#8594;</span> <strong>true</strong>), извлекается его значение и вернется оезультат <span>&#8594;</span> <strong><a href="#get-abstr">Get</a>(bindings, N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-deletebinding-n"><em>DeleteBinding ( N )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Определенное свойство (<em>N</em>) удаляется из объекта привязки (<em>bindings</em>) и вернется результат <span>&#8594;</span> <strong>bindings.<a href="#internal-delete">[[Delete]]</a>(N)</strong>.</li>
                           
                       </ol>
                       
                       <p>Удаляются из окружения объекта только настраиваемые свойства (<em>bindings</em>.<a href="#config_attr"><strong>[[Configurable]]</strong></a> <span>&#8594;</span> <strong>true</strong>).</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-hasthisbinding"><em>HasThisBinding ( )</em></a></h4>
                           
                       </header>
                       
                       <p>Обычное окружение объекта не предоставляет привязки <strong>this</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-hassuperbinding"><em>HasSuperBinding ( )</em></a></h4>
                           
                       </header>
                       
                       <p>Обычное окружение объекта не предоставляет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-environment-records-withbaseobject"><em>WithBaseObject ( )</em></a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Если окружение объекта (<em>envRec</em>) используется выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>true</strong>), вернется объект привязки.</li>
                           
                           <li>Если окружение объекта не используется выражением <strong>with</strong> (<em>withEnvironment</em> <span>&#8594;</span> <strong>false</strong>), вернется <strong>undefined</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
               </section>
               
               <section>
                  
                   <header class="header header--center">
                      
                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records">Глобальное</a> окружение</h4>
                       
                   </header>
                   
                   <p>Глобальное окружение это внешняя область видимости высшего уровня, которая является общей для всех ECMAScript элементов, что обрабатываются в одной области внутри скрипта. Глобальное окружение предоставляет привязки для встроенных глобальных объектов, их свойств и для всех объявлений высшего уровня внутри скрипта.</p>
                   
                   <p>Глобальное окружение это смесь из окружения глобального объекта и декларативного окружения. В окружении глобального объекта существуют привязки всех встроенных глобальных объектов и все привязки, что внесены объявлениями функций, генераторов, асинхронных функций и переменных в глобальном коде. Данное окружение привязывается к глобальному объекту, который является объектом привязки. Привязки для остальных ECMAScript объявлений в глобальном коде содержаться в соответствующем декларативном окружении.</p>
                   
                   <p>В глобальном окружении существуют дополнительные поля:</p>
                   
                   <table>
                       <tr>
                           <th>Имя поля</th>
                           <th>Значения</th>
                           <th>Для чего используется</th>
                       </tr>
                       <tr>
                           <td><em>[[ObjectRecord]]</em></td>
                           <td>Окружение глобального объекта</td>
                           <td>Здесь содержутся такие глобальные встроенные привязки как объявления функций, асинхронных функций, генераторов и переменных в глобальном коде для связанной области.</td>
                       </tr>
                       <tr>
                           <td><em>[[GlobalThisValue]]</em></td>
                           <td>Объект</td>
                           <td>Здесь содержится значение <strong>this</strong> в глобальной области видимости.</td>
                       </tr>
                       <tr>
                           <td><em>[[DeclarativeRecord]]</em></td>
                           <td>Глобальное декларативное окружение</td>
                           <td>Здесь содержутся привязки для всех объявлений в глобальном коде для связанной области, кроме привязок объявлений функций, асинхронных функций, генераторов и переменных.</td>
                       </tr>
                       <tr>
                           <td><em>[[VarNames]]</em></td>
                           <td>Список из элементов в виде строки</td>
                           <td>Здесь содержутся имена, что привязаны к объявлениям функций, асинхронных функций, генераторов и переменных в глобальном коде для связанной области.</td>
                       </tr>
                   </table>
                   
                   <p>Также в глобальном окружении существуют дополнительные методы:</p>
                   
                   <table>
                       <tr>
                           <th>Метод</th>
                           <th>Для чего используется</th>
                       </tr>
                       <tr>
                           <td><strong>GetThisBinding()</strong></td>
                           <td>Возвращает значение привязки <strong>this</strong> этого окружения.</td>
                       </tr>
                       <tr>
                           <td><strong>HasVarDeclaration (N)</strong></td>
                           <td>Определяет, имеет ли идентификатор (<em>N</em>) этого окружения привязку, что создана через объявление переменной, генератора, функции или асинхронной функции.</td>
                       </tr>
                       <tr>
                           <td><strong>HasLexicalDeclaration (N)</strong></td>
                           <td>Определяет, имеет ли идентификатор (<em>N</em>) этого окружения привязку, что создана через лексическое объявление (объявление класса, <em>const</em> или <em>let</em>).</td>
                       </tr>
                       <tr>
                           <td><strong>HasRestrictedGlobalProperty (N)</strong></td>
                           <td>Определяет, может ли привязка (<em>N</em>) в глобальном объекте быть скрыта глобальной лексической привязкой.</td>
                       </tr>
                       <tr>
                           <td><strong>CanDeclareGlobalVar (N)</strong></td>
                           <td>Определяет, будет ли создана привязка переменной (<em>N</em>) в глобальном объекте.</td>
                       </tr>
                       <tr>
                           <td><strong>CanDeclareGlobalFunction (N)</strong></td>
                           <td>Определяет, будет ли создана привязка функции (<em>N</em>) в глобальном объекте.</td>
                       </tr>
                       <tr>
                           <td><strong>CreateGlobalVarBinding(N, D)</strong></td>
                           <td>Создает изменяемую привязку (<em>N</em>) глобальной переменной (<strong>var</strong>) и инициализирует ее со значением <strong>undefined</strong> в окружении глобального объекта.</td>
                       </tr>
                       <tr>
                           <td><strong>CreateGlobalFunctionBinding(N, V, D)</strong></td>
                           <td>Создает изменяемую привязку (<em>N</em>) глобальной функции (<strong>function</strong>) и инициализирует ее со значением (<em>V</em>) в окружении глобального объекта.</td>
                       </tr>
                   </table>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hasbinding-n">HasBinding ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, существует ли данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если сущесвтует, что ознаменуется значением <strong>true</strong>, тогда вернется <strong>true</strong>.</li>
                           
                           <li>Если же в декларативной записи глобального окружения (<em>DclRec</em>) этой привязки нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже в записи глобального окружения объекта (<em>ObjRec</em>) будет выполнен поиск соответствующей привязки (<em>N</em>) <span>&#8594;</span> <strong>ObjRec.HasBinding(N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-createmutablebinding-n-d">CreateMutableBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <p>Создает изменяемую привязку (<em>N</em>) в декларативной записи глобального окружения.</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                           
                           <li>А если нет, тогда будет создана соответствующая привязка (<em>N</em>) в декларативной записи глобального окружения (DclRec) <span>&#8594;</span> <strong>DclRec.CreateMutableBinding(N, D)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-createimmutablebinding-n-s">CreateImmutableBinding ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Создает неизменяемую привязку (<em>N</em>) в декларативной записи глобального окружения.</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), выкинет <strong>TypeError</strong>.</li>
                           
                           <li>А если нет, тогда будет создана соответствующая привязка (<em>N</em>) в декларативной записи глобального окружения (DclRec) <span>&#8594;</span> <strong>DclRec.CreateImmutableBinding(N, S)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-initializebinding-n-v">InitializeBinding ( N, V )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда ей будет назначено соответствующее значение (<em>V</em>) <span>&#8594;</span> <strong>DclRec.InitializeBinding(N, V)</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>. Если привязка существует, при этом в деклаларативной записи глобального окружения ее нет, тогда она должна быть в записи глобального окружения объекта.</li>
                           
                           <li>Привязке (<em>N</em>) в записи глобального окружения объекта (<em>ObjRec</em>) будет инициализировано значение (<em>V</em>) <span>&#8594;</span> <strong>ObjRec.InitializeBinding(N, V)</strong></li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-setmutablebinding-n-v-s">SetMutableBinding ( N, V, S )</a></h4>
                           
                       </header>
                       
                       <p>Если привязка неизменяемая и строгая (<em>S</em> <span>&#8594;</span> <strong>true</strong>), выкинет <strong>TypeError</strong>. Если привязки не существует, либо она не поддается записи (<a href="#write_attr"><strong>[[Writable]]</strong></a> <span>&#8594;</span> <strong>false</strong>), тогда обработка ошибок в этом случае будет определена значением строгости (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда ее текущее значение будет изменено на новое (<em>V</em>) <span>&#8594;</span> <strong>DclRec.SetMutableBinding ( N, V, S )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже там привязка (<em>N</em>) получит свое новое значение (<em>V</em>) <span>&#8594;</span> <strong>ObjRec.SetMutableBinding ( N, V, S )</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-getbindingvalue-n-s">GetBindingValue ( N, S )</a></h4>
                           
                       </header>
                       
                       <p>Если привязка неинициализирована, выкинет <strong>ReferenceError</strong>. Если привязки не существует, либо она не поддается записи (<a href="#write_attr"><strong>[[Writable]]</strong></a> <span>&#8594;</span> <strong>false</strong>), тогда обработка ошибок в этом случае будет определена значением строгости (<em>S</em>).</p>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда вернется ее текущее значение <span>&#8594;</span> <strong>DclRec.GetBindingValue ( N, S )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>И уже оттуда будет извлечено значение привязки (<em>N</em>) <span>&#8594;</span> <strong>ObjRec.GetBindingValue ( N, S )</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-deletebinding-n">DeleteBinding ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется проверка того, есть ли уже данная привязка (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>. Если она уже там есть (будет <strong>true</strong>), тогда удаляется <span>&#8594;</span> <strong>DclRec.DeleteBinding ( N )</strong>.</li>
                           
                           <li>А если ее там нет, тогда из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Затем из этой записи глобального окружения (<em>ObjRec</em>) берется объект привязки, который является глобальным (<em>globalObject</em>), и в нем выполняется поиск этой привязки (<em>N</em>) как свойства <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если свойство с таким именем (<em>N</em>) сущесвтует в глобальном объекте (<em>globalObject</em>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Эта привязка (<em>N</em>) удаляется из записи глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>ObjRec.DeleteBinding(N)</strong> (<em>status</em>).</li>
                                   
                                   <li>Если удаление привязки (<em>N</em>) было выполнено (<em>status</em> <span>&#8594;</span> <strong>true</strong>),
                                   
                                       <ol class="list" type="i">
                                          
                                           <li>Берется список имен привязок (<em>varNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                                           
                                           <li>И если имя удаленной привязки (<em>N</em>) есть в этом списке (<em>varNames</em>), тогда оно из него также удаляется.</li>
                                           
                                       </ol>
                                   
                                   </li>
                                   
                                   <li>Возвращается булевский результат выполнения операции удаления (<em>status</em>).</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>В том случае, когда такого свойства-привязки (<em>N</em>) в глобальном объекте (<em>globalObject</em>) не существует, вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hasthisbinding">HasThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Глобальное окружение имеет привязку <strong>this</strong>, поэтому вернется <strong>true</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-hassuperbinding">HasSuperBinding ( )</a></h4>
                           
                       </header>
                       
                       <p>Глобальное окружение не имеет привязки <strong>super</strong>, поэтому вернется <strong>false</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-withbaseobject">WithBaseObject ( )</a></h4>
                           
                       </header>
                       
                       <p>Выражение <strong>with</strong> не использует глобальный объект, поэтому вернется <strong>undefined</strong>.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-global-environment-records-getthisbinding">GetThisBinding ( )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Вовзращается значение <strong>this</strong> глобального окружения (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.[[GlobalThisValue]]</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasvardeclaration">HasVarDeclaration ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>) переменных и функций, что были объявлены в глобальном окружении (<em>envRec</em>) <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) есть нужное имя привязки (<em>N</em>), вернется <strong>true</strong>.</li>
                           
                           <li>А если его там нет, вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-haslexicaldeclaration">HasLexicalDeclaration ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается декларативная запись (<em>DclRec</em>) <span>&#8594;</span> <strong>envRec.[[DeclarativeRecord]]</strong>.</li>
                           
                           <li>Выполняется поиск данной привязки (<em>N</em>) в декларативной записи глобального окружения (<em>DclRec</em>) <span>&#8594;</span> <strong>DclRec.HasBinding(N)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-hasrestrictedglobalproperty">HasRestrictedGlobalProperty ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие привязки в качестве свойства с данным именем (<em>N</em>) в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) с помощью метода, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если вместо описания свойства (<em>existingProp</em>) получено <strong>undefined</strong>, тогда такого свойства-привязки нет (<em>N</em>) и вернется <strong>false</strong>.</li>
                           
                           <li>Если же вернулось описание (<em>existingProp</em>) свойства (<em>N</em>), в нем проверяется атрибут <a href="#config_attr"><strong>[[Configurable]]</strong></a>, который определяет, является ли свойство настраиваемым. Если этот атрибут имеет значение <strong>true</strong>, значит, свойство настраиваемое, и тогда вернется <strong>false</strong> (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>true</strong> <span>&#8594;</span> <strong>false</strong>).</li>
                           
                           <li>А когда свойство не изменяемое, а значит, оно с ограничениями, вернется <strong>true</strong>.</li>
                           
                       </ol>
                       
                       <p>Глобальная лексическая привязка не может быть создана с тем же именем, что и не настраиваемое свойство глобального объекта. Глобальное свойство <strong>undefined</strong> это его пример.</p>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-candeclareglobalvar">CanDeclareGlobalVar ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется, имеет ли глобальный объект (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязку в качестве свойства с данным именем (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>hasProperty</em>) (<em>hasProperty</em>).</li>
                           
                           <li>Если такое свойство (<em>N</em>) в глобальном объекте (<em>globalObject</em>) есть (<em>hasProperty</em> <span>&#8594;</span> <strong>true</strong>), тогда вернется <strong>true</strong>.</li>
                           
                           <li>Если же такого свойства (<em>N</em>) нет (<em>hasProperty</em> <span>&#8594;</span> <strong>false</strong>), тогда проверяется возможность его добавления в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-candeclareglobalfunction">CanDeclareGlobalFunction ( N )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязки в качестве свойства с данным именем (<em>N</em>) через метод, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если вместо описания свойства (<em>existingProp</em>) получено <strong>undefined</strong>, тогда такого свойства-привязки (<em>N</em>) нет и проверяется возможность его добавления в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong>.</li>
                           
                           <li>Если же вернулось описание (<em>existingProp</em>) свойства (<em>N</em>), в нем проверяется атрибут <a href="#config_attr"><strong>[[Configurable]]</strong></a>, который определяет, является ли свойство настриваемым. Если этот атрибут имеет значение <strong>true</strong>, значит, свойство настриваемое, и вернется <strong>true</strong> (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>true</strong> <span>&#8594;</span> <strong>true</strong>).</li>
                           
                           <li>В том случае, когда это свойство (<em>N</em>) не настриваемое (<strong>existingProp.<a href="#config_attr">[[Configurable]]</a></strong> <span>&#8594;</span> <strong>false</strong>), проверяется, является ли оно свойством данных. Если это свойство данных (<strong>IsDataDescriptor(existingProp)</strong> <span>&#8594;</span> <strong>true</strong>) и атрибуты записывемости и перечисляемости имеют значение <strong>true</strong> (<strong>{<a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true}</strong>), вернется <strong>true</strong>.</li>
                           
                           <li>Если же свойство не настриваемое, не записываемое и не перечисляемое (<strong>{<a href="#write_attr">[[Writable]]</a>: false, <a href="#enum_attr">[[Enumerable]]</a>: false, <a href="#config_attr">[[Configurable]]</a>: false}</strong>), вернется <strong>false</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createglobalvarbinding">CreateGlobalVarBinding ( N, D )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется, имеет ли глобальный объект (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязку глобальной переменной в качестве свойства с данным именем (<em>N</em>) <span>&#8594;</span> <strong><a href="#has_prop_o-abstr">HasOwnProperty</a>(globalObject, N)</strong> (<em>hasProperty</em>).</li>
                           
                           <li>И проверяется возможность добавления этого свойтсва-привязки (<em>N</em>) в глобальный объект (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#isextensible-abstr">IsExtensible</a>(globalObject)</strong> (<em>extensible</em>).</li>
                           
                           <li>Если такого свойства-привязки нет (<em>hasProperty</em> <span>&#8594;</span> <strong>false</strong>), при этом глобальный объект расширяемый (<em>extensible</em> <span>&#8594;</span> <strong>true</strong>), тогда
                           
                               <ol class="list" type="a">
                                  
                                   <li>Будет создана изменяемая привязка глобальной переменной с данным именем (<em>N</em>) в записи окружения глобального объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>ObjRec.CreateMutableBinding(N, D)</strong>.</li>
                                   
                                   <li>И затем она (<em>N</em>) будет инициализирована без значения <span>&#8594;</span> <strong>ObjRec.InitializeBinding(N, undefined)</strong>.</li>
                                   
                               </ol>
                           
                           </li>
                           
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) еще нет имени созданной привязки (<em>N</em>), тогда оно добавляется в него.</li>
                           
                           <li>Создается запись завершения <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>. В случае, когда такое свойство-привязка (<em>N</em>) уже есть (<em>hasProperty</em> <span>&#8594;</span> <strong>true</strong>), или глобальный объект (<em>globalObject</em>) не расширяемый (<em>extensible</em> <span>&#8594;</span> <strong>false</strong>), алгоритм завершит свое выполнение и никакой привязки глобальной переменной в окружении глобального объета создано не будет <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>.</li>
                           
                       </ol>
                       
                   </article>
                   
                   <article>
                      
                       <header class="header header--center">
                          
                           <h4 class="header__item--notbold"><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-createglobalfunctionbinding">CreateGlobalFunctionBinding ( N, V, D )</a></h4>
                           
                       </header>
                       
                       <ol class="list">
                          
                           <li>Из глобальной записи окружения (<em>envRec</em>) извлекается запись глобального окружения объекта (<em>ObjRec</em>) <span>&#8594;</span> <strong>envRec.[[ObjectRecord]]</strong>.</li>
                           
                           <li>Проверяется наличие в глобальном объекте (<em>globalObject</em>) этого окружения (<em>ObjRec</em>) привязки глоабльной функции в качестве свойства с данным именем (<em>N</em>) через метод, что возвращает описание свойства <span>&#8594;</span> <strong>globalObject.<a href="#get_prop_o-abstr">[[GetOwnProperty]]</a>(N)</strong> (<em>existingProp</em>).</li>
                           
                           <li>Если такого свойства-привязки (<em>N</em>) в глобальном объекте нет (<em>existingProp</em> <span>&#8594;</span> <strong>undefined</strong>), или есть и это свойство (<em>N</em>) настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: true</strong>), тогда описание этого свойства-привязки (<em>N</em>) будет изменено к такому виду <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="value_attr">[[Value]]</a>: V, <a href="#write_attr">[[Writable]]</a>: true, <a href="#enum_attr">[[Enumerable]]</a>: true, <a href="#config_attr">[[Configurable]]</a>: D}</strong> (<em>desc</em>).</li>
                           
                            <li>Если же свойство-привязка с таким именем (<em>N</em>) существует и оно не настраиваемое (<strong><a href="#config_attr">[[Configurable]]</a>: true</strong>), будет изменено только значение в описании свойства <span>&#8594;</span> <strong><a href="#prop_desc">PropertyDescriptor</a>{<a href="value_attr">[[Value]]</a>: V}</strong> (<em>desc</em>).</li>
                           
                           <li>Определив, каким будет описание (<em>desc</em>) свойства-привязки глобальной функции, создается новая привязка или меняется существующая с таким именем (<em>N</em>) в глобальном объекте (<em>globalObject</em>) <span>&#8594;</span> <strong><a href="#define_prop_or_throw">DefinePropertyOrThrow</a>(globalObject, N, desc)</strong></li>
                           
                           <li>Затем эта привязка (<em>N</em>) регистрируется как инициализированная в окружении глобального объекта (<em>ObjRec</em>).</li>
                           
                           <li>Этому инициализированному свойтсву-привязке (<em>N</em>) в глобальном объекте (<em>globalObject</em>) записывается значение  (<em>V</em>) <strong><a href="#set-abstr">Set</a>(globalObject, N, V, false)</strong>.</li>
                           
                           <li>Извлекается список имен привязок (<em>varDeclaredNames</em>), что были объявлены в окружении глобального объекта <span>&#8594;</span> <strong>envRec.[[VarNames]]</strong>.</li>
                           
                           <li>Если в этом списке (<em>varDeclaredNames</em>) еще нет имени созданной привязки (<em>N</em>), тогда оно добавляется в него.</li>
                           
                           <li>Создается запись завершения <span>&#8594;</span> <strong>NormalCompletion(empty)</strong>.</li>
                          
                       </ol>
                       
                   </article>
                   
               </section>
               
           </section>
           
       </section>
       
   </section>
    
</body>
</html>