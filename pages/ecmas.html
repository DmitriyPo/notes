<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>ECMAScript</title>
    <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  
    <header class="header">
        
        <h1>ECMAScript 2017</h1>
        
    </header>
    
    <p>Вот ссыль на <a href="https://www.ecma-international.org/ecma-262/">спецификацию</a> (самая свеженькая на даный момент - 8-ое издание), которую я рассмотрю здесь. Начнем с краткого обзора того, что такое ECMAScript (он же JavaScript).</p>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-overview">Краткий обзор</a></h2>
           
        </header>
           
        <p>ECMAScript это объектно-ориентированный язык программирования, что выполняется внутри своего окружения. <a href="https://www.ecma-international.org/ecma-262/#sec-web-scripting">Веб-браузер</a> предоставляет окружение для вычислений на стороне клиента (это объекты в виде окон, меню, диалоговых окон, фреймов, истории, куки, ввода/вывода, и другого разнообразия, а также способы для прикрепления кода к событиям мыши, отправки формы, загрузки страницы, ошибок, выбора и тд.). Веб-сервер предоставляет другое окружение для вычислений на своей стороне (а это объекты в виде запросов, клиентов, файлов, а также механизмы блокировки и обмена данными). Совместное выполнение скриптов на стороне браузера (клиента) и сервера  дает возможность распределить вычисление, предоставляя индивидуальный пользовательский интерфейс для веб-приложений. Каждый браузер и сервер вместе завершают окружение выполнения ECMAScript.</p>

        <div>

            <p>Перед тем, как дальше углубиться в дебри языка, рассмотрим в сжатом виде ECMAScript. Его основой являются объекты, ведь программа ECMAScript это набор взаимодействующих объектов. А объект это собрание свойств, у которых есть атрибуты. Свойства же в свою очередь это контейнеры для других объектов, примитивных значений, или функций. Примитивным есть значение, что представляет один из следующих заложенных внутри языка типов: <em>Undefined</em> (неопределенное), <em>Null</em> (значение для нихуя), <em>Boolean</em> (булевское значение true/false), <em>Number</em> (число), <em>String</em> (строка), и <em>Symbol</em> (символ); объект это представитель типа <em>Object</em>; а функция это вызываемый объект. Та функция, что связывается с объектом через свойство, зовется <em>методом</em>.</p>

            <p>Набор ECMAScript объектов включает в себя глобальный объект; основные объекты для динамической семантики (формальной модели) языка (<em>Object, Function, Boolean, Symbol, и Error</em>); объекты, что представляют и манипулируют числовыми значениями (<em>Math, Number, и Date</em>); объекты, обрабатывающие текст (<em>String и RegExp</em>); объекты, что являются пронумерованными наборами значений (<em>Array</em> и другие его виды); ключевые наборы (<em>Map и Set</em>); объекты, что поддерживают структурированные данные (<em>JSON, ArrayBuffer, SharedArrayBuffer, и DataView</em>); объекты, что поддерживают абстрактные понятия управления (<em>функции-генераторы и Promise</em>); отражающие объекты (<em>Proxy и Reflect</em>).</p>

            <p>Еще ECMAScript определяет набор операторов, среди которых унарные, запятые, логические, назначения, равенства, относительные и тд. Также большие програмы ECMAScript поддерживают модульность, что позволяет разделить программу на множество последовательностей из конструкций и объявлений. Модуль определяет, какие объявления предоставляются другими модулями, и какие из его объявлений доступны для использования другим модулям. Да и синтаксис языка лайтовый (нет, например, строгой типизации), хоть в нем и существует возможность использовать строгий режим.</p>

            <!-- <article>

               <header class="header">

                   <h3><a href="https://www.ecma-international.org/ecma-262/#sec-objects"><em>Объекты</em></a></h3>

               </header>

               <p>Объекты ECMAScript не основаны на классах, хоть ECMAScript и имеет в себе синтаксис для их определения. Объекты могут быть созданы разными способами, включая возможность их создания через литеральное описание или через конструкторы (объекты от конструкторов инициализируются через назначение их свойствам начальных значений). Конструктор является функцией, что имеет свойство <em>'prototype'</em>, которое используется, чтобы реализовать наследование, основанное на прототипировании и разделяемых свойствах.</p>

               <p>Каждый объект, созданный с помощью конструктора, имеет неявную ссылку (что зовется прототипом объекта) на значение свойства <em>'prototype'</em> его конструктора. Более того, у прототипа так же может быть прототип, на который можно неявно сослаться, и так далее, - это называется цепочкой прототипов. Когда в объекте делается ссылка на свойство, она ссылается на свойство с таким именем в первом попавшемся в цепочке объекте, в котором оно содержится (имеется в виду, что будут рассматриваться объекты в цепочке прототипов до тех пор, пока не будет найден именно тот первый объект, содержащий данное искомое свойство, на которое ссылаются).</p>

               <img src="https://i.gyazo.com/2101c448bb59baac2ec207c0b6bb014b.png" alt="Object/Prototype Relationships">

               <p>В ECMAScript состояние и методы переносятся объектами, и в то же время структура, поведение и состояние наследуются. Объекты, которые не содержат в себе конкретное свойство, что содержится в их прототипе, разделяют это свойство и его значение (через наследование).</p>

            </article> -->

            <article>

               <header class="header">

                   <h3><a href="https://www.ecma-international.org/ecma-262/#sec-strict-variant-of-ecmascript">Строгий вариант ECMAScript</a></h3>

               </header>

               <p>ECMAScript определяет строгий вариант языка. Он исключает некоторые определенные синтаксические и семантические свойства обычного ECMAScript и меняет детализированную семантику некоторых его свойств. Строгий вариант также определяет дополнительные условия для ошибок, которые должны быть зарегистрированы путем выкидывания соответствующих исключений в ситуациях, которые не определены как ошибочные в не строгой форме языка.</p>

               <p>Строгий вариант языка обычно указывается как строгий режим (<em>strict mode</em>). Строгий режим налагает ограничения, что имеют только локальный эфект внутри синтаксической единицы ECMAScript (на индивидуальном уровне для этой единицы). Програма может состоять из синтаксических единиц ECMAScript, что написаны в строгом и не строгом режиме.</p>

            </article>

        </div>
              
   </section>
   
   <section>
       
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-data-types-and-values">Типы данных и значений в ECMAScript</a></h2>
           
       </header>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types">Типы языка ECMAScript</a></h3>
               
           </header>
           
           <p>Типы языка есть следующие: <em>Undefined (неопределенный), Null (нулевой), Boolean (для булевских значений), String (для значений в виде строки), Symbol (для символов), Number (для числовый значений), и Object (для объектов)</em>. Кратко рассмотрим каждый тип.</p>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-undefined-type">Неопределенный тип (Undefined)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>undefined</strong>. Каждая переменная, которой не было назначено какое-либо значение, будет иметь в качестве него <em>undefined</em>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-null-type">Нулевой тип (Null)</a></h4>

               </header>
               
               <p>Этот тип имеет только одно значение - <strong>null</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-boolean-type">Булев тип (Boolean)</a></h4>

               </header>
               
               <p>Булев тип (логический) служит для представления логической сущности, что имеет два значения: <strong>true</strong> и <strong>false</strong>.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/index.html#sec-ecmascript-language-types-string-type">Строковый тип (String)</a></h4>

               </header>
               
               <p>Данный тип в основном используется, чтобы представить текстовую информацию в работающей програме ECMAScript, и в этом случае каждый элемент обрабатывается как значение единицы кода UTF-16 (UTF-16 это кодировка символов Юникода). Элемент тут рассматривается, как занимающий конкретную позицию внутри последовательности. А эти позиции, в свою очередь, индексируются не отрицательными целыми числами (первый элемент будет иметь индекс 0, второй - 1, и тд.). Длина строки это число элементов в ней (пустая строка имеет длину 0).</p>
               
               <p>Операции ECMAScript, интерпретирующие строковые значения, рассматривают каждый элемент как отдельную кодовую точку UTF-16. ECMAScript не накладывает никаких ограничений или требований на последовательность кодовых точек в значении строки. Операции, что не интерпретируют контент строки, обрабатывают его, как универсальные (нерасчлененные) 16-битные целочисленные переменные без знака.</p>
               
           </article>
           
           <article>
               
               <header class="header">
              
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-symbol-type">Тип для символов (Symbol)</a></h4>

               </header>
               
               <p>Этот тип является набором значений, что могут быть использованы, как ключи свойства объекта. Каждое возможное значение этого типа уникальное и неизменное.</p>
               
               <p>Известные символы как правило используются в качестве ключей свойств, чьи значения служат как точки расширения алгоритма спецификации, наводятся в этой <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-1">таблице</a>.</p>
               
           </article>
           
           <article>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-language-types-number-type">Числовой тип (Number)</a></h4>

                </header>

                <p>Данный тип представляет значения, которые являются 64-битными формата IEEE 754-2008, и их количество составляет дохера (2<sup>64</sup>-2<sup>53</sup>+3). Среди них есть особенные. Первым особенным значением есть <strong>NaN</strong> (“Not-a-Number”, которое производится программным выражением <strong>NaN</strong>). В коде ECMAScript <em>NaN</em> значения не отличимы друг от друга, при этом в некоторых реализациях код способен обнаружить разницу между разными <em>NaN</em> значениями (а разные значения <em>NaN</em> не равны друг другу).</p>

                <p>Еще одними особенными значениями есть позитивная и отрицательная беснонечности, которые изображают с помощью символов <strong>+&#8734;</strong> и <strong>-&#8734;</strong> (оба они производятся программными выражениями <strong>+Infinity</strong> (или просто <strong>Infinity</strong>) и <strong>-Infinity</strong>).</p>

                <p>Остальные значения являются конечными, и половина из них это позитивные значения, а другая - отрицательные. Для каждого конечного числового значения существует соответствющее ему отрицательное по модулю.</p>

                <p>Также в ECMAScript не один ноль, а два: позитивный и отрицательный. Выражаются они символами <strong>+0</strong> и <strong>-0</strong> (два этих значения, что по сути выражают ноль, производятся программными выражениями <strong>+0</strong> (или просто <strong>0</strong>) и <strong>-0</strong>).</p>
                
                <p>Все положительные и отрицательные целые числа, величина которых по модулю не превышает 2<sup>53</sup>, представлены в типе чисел.</p>
               
           </article>
           
            <section>
               
                <header class="header">

                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-object-type">Объектный тип (Object)</a></h4>

                </header>

                <p>Объект это собрание свойств. Есть свойства данных и свойства доступа:</p>
                
                <ul class="list">
                    
                    <li><em>свойство данных</em> связывает свой ключ со значением ECMAScript и набором соответствующих атрибутов;</li>
                    
                    <li><em>свойство доступа</em> связывает свой ключ с одной или двумя функциями доступа и набором соответствующих атрибутов. Функция доступа используется для хранения или извлечения значения ECMAScript, которое связано со свойством.</li>
                    
                </ul>
                
                <p>Свойства идентифицируются, используя ключ значений. Ключом значения свойства есть либо строка, либо символ ECMAScript. Все строки и символы, включая пустую строку, это корректные ключи свойств. Ключ, что выражает имя свойства, является строкой. Еще вместо именованных свойств используются целочисленные индексы, которые являются ключами свойства строкового типа и чьё числовое значение находится в диапазоне от +0 до 2<sup>53</sup>-1 включительно. В массивах индексы имеют значения +0 <span>&#8804;</span> <em>i</em> <span>&#60;</span> 2<sup>32</sup>-1.</p>
                
                <p>Ключи свойств используются, чтобы получить доступ к свойствам и их значениям. Существует два вида доступа к значениям свойств: получение (<em>get</em>) и запись (<em>set</em>), что соответствует либо операции извлечения значения, либо операции его назначения свойству. Свойства, доступные через получение и запись, могут быть собственными и унаследованными от другого связанного объекта (наследование в действии).</p>
                
                <p>Есть несколько форм объектов, что отличаются в своей семантике доступа и управления свойствами. Это обычные объекты и необычные, чья семантика свойств отличается от той, что предоставлена объектам по умолчанию (массивы, например). Теперь рассмотрим объекты пристальнее.</p>
                
                <article>
                    
                    <header class="header header--center">
                        
                        <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-attributes">Атрибуты свойства</a></h4>
                        
                    </header>
                    
                    <p>Атрибуты используются, чтобы определить и объяснить состояние свойств объекта. Свойство данных связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-2">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств данных</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Value]] (значение)</td>
                            
                            <td>Любой тип ECMAScript</td>
                            
                            <td>Значение, что извлекается при получении доступа к свойству.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Writable]] (перезаписи)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, возможно ли перезаписать значение атрибута [[Value]] соответствующего свойства. Если значением этого атрибута является <strong>false</strong>, тогда попытки изменить значение атрибута [[Value]], используя атрибут записи [[Set]], потерпят неудачу.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, будет ли свойство объекта перечислено при применении цыкла. Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В ином случае, свойство является не перечислимым (т.е. циклы его пропустят).</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Этот атрибут указывает на то, является ли свойтсво настраиваемым. Если значением этого атрибута является <strong>false</strong>, тогда попытки удалить или изменить свойство, чтобы оно стало свойством доступа, или изменить его атрибуты (кроме атрибута [[Value]] или [[Writable]] на <strong>false</strong>) потерпят неудачу (атрибут [[Writable]] может еще изменить свое значение на <strong>false</strong>, а вот обратно - уже нет).</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Свойство доступа связывает ключ значения с атрибутами, которые перечислены в <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-3">таблице</a> ниже:</p>
                    
                    <table>
                        
                        <caption>Атрибуты свойств доступа</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Область значения</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Get]] (получение)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). У функции же в свою очередь есть внутренний метод вызова [[Call]], который вызывается с пустым списком аргументов каждый раз, когда используется атрибут свойства доступа [[Get]], чтобы извлечь значение (работу метода ([[Call]]) рассмотрим позже).</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Set]] (запись)</td>
                            
                            <td>Объект | Неопределенный тип (Undefined)</td>
                            
                            <td>Если значение является объектом, тогда он должен быть вызываемым (функцией). Внутренний метод вызова функции [[Call]] вызывается со списком аргументов, что содержит новоназначаемое значение, каждый раз, когда используется атрибут свойства записи [[Set]], чтобы записать (присвоить) новое значение.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Enumerable]] (перечислимый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>true</strong>, тогда свойство будет перечислено с помощью циклов <em>for-in</em>. В другом случае, свойство не перечислимое.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Configurable]] (настраиваемый)</td>
                            
                            <td>Булевский тип ECMAScript</td>
                            
                            <td>Если значением этого атрибута является <strong>false</strong>, тогда попытки удалить свойство, изменить его, чтобы оно стало свойством данных, или изменить его атрибуты, потерпят неудачу.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Значения по умолчанию для атрибутов свойств следующие:</p>
                    
                    <table>
                        
                        <caption>Значения атрибутов по умолчанию</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Имя атрибута</th>
                            
                            <th>Значение по умолчанию</th>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Поддающийся записи ([[Writable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Перечислимый ([[Enumerable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Настраиваемый ([[Configurable]])</td>
                            
                            <td>false</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Значение ([[Value]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Получение ([[Get]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                        <tr>
                            
                            <td>Запись ([[Set]])</td>
                            
                            <td>undefined</td>
                            
                        </tr>
                        
                    </table>
                    
                </article>
                
                <article>
                    
                    <header class="header header--center">
                       
                        <h4><a href="https://www.ecma-international.org/ecma-262/#sec-object-internal-methods-and-internal-slots">Внутренние</a> методы объектов и слоты (ячейки)</h4>
                        
                    </header>
                    
                    <p>Внутренние методы это алгоритмы, что определяют фактическую семантику объектов (их поведение во время выполнения). Имена внутренних методов полиморфные, а это означает, что выполняются разные алгоритмы при вызове такого метода, если объект имеет для них разные значения. Если вызывается внутренний метод, который не поддерживается объектом, тогда программа выкинет исключение об ошибке <strong>TypeError</strong>. Внутренний метод возвращает завершающую запись и всегда имеет доступ к целевому объекту.</p>
                    
                    <p>Внутренние слоты соответствуют внутреннему состоянию, которое связано с объектами, и используются различными алгоритмами ECMAScript. Эти слоты не наследуются и являются частью создания объекта, при этом они не могут быть добавлены динамически. Внутреннее состояние может состоять из значений любого типа ECMAScript. Начальное значение внутреннего слота это <strong>undefined</strong>. ECMAScript не предоставляет прямого пути, чтобы связать внутренние слоты с объектом.</p>
                    
                    <p><a href="https://www.ecma-international.org/ecma-262/#table-5">Таблица</a> ниже обобщает важные внутренние методы, которые применимы ко всем объектам, что были созданы с помощью кода ECMAScript:</p>
                    
                    <table>
                        
                        <caption>Важные внутренние свойства</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[GetPrototypeOf]]</td>
                            
                            <td>() <span>&#8594;</span> Object | Null</td>
                            
                            <td>Для своего объекта этот метод определяет тот объект, который предоставляет наследуемые свойства (иными словами, с его помощью определяется прототип). Значение <strong>null</strong> указывает, что нет никаких наследуемых свойств (это значение у того объекта, который не имеет прототипов в своей цепочке, поскольку он в ней первый). Цепь прототипов имеет конечную длину при том условии, если в ней не встречаются необычные объекты, которые не используют обыкновенное определение этого метода, ведь тогда это может призвести к бесконечному цыклу при попытке получить доступ к свойствам объекта-прототипа.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[SetPrototypeOf]]</td>
                             
                            <td>(Object | Null) <span>&#8594;</span> Boolean</td>
                            
                            <td>Связывает свой объект с другим объектом, который предоставляет наследуемые свойства (записывает объекту прототип). Если в аргументе <strong>null</strong>, тогда оно указывает на то, что нет никаких наследуемых свойств. Если возвращаемое значение <strong>true</strong>, это указывает на успешное завершение операции, а если <strong>false</strong> - операция не была успешной.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[IsExtensible]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Определяет, разрешается ли добавить дополнительные свойства объекту.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[PreventExtensions]]</td>
                             
                            <td>() <span>&#8594;</span> Boolean</td>
                            
                            <td>Контролирует могут ли новые свойства быть добавлены объекту. Если операция по превращению объекта в нерасширяемый прошла успешно, тогда этот метод вернет <strong>true</strong> (после этого дополнительные свойства не смогут быть добавлены объекту, и после этого метод [[IsExtensible]] вернет <strong>false</strong>), в противном случае - <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[GetOwnProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Undefined | Property Descriptor</td>
                            
                            <td>Возвращает значение <em>Property Descriptor</em> (описание) для собственного свойства объекта, если оно существует (ключ свойства передается тут в качетсве аргумента - <em>propertyKey</em>). А если возвращает <strong>undefined</strong>, тогда это означает, что такого свойства не существует в этом объекте.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[DefineOwnProperty]]</td>
                             
                            <td>(<em>propertyKey, Property Descriptor</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Создает или меняет свобственное свойство (его ключ определен в первом аргументе - <em>propertyKey</em>), чтобы оно имело состояние, которое описывается во втором аргументе (Property Descriptor). Возвращает <strong>true</strong>, если свойство было создано/обновлено. В противном случае - <strong>false</strong>, если существует одно из следующих состояний: свойство не настраиваемое, объект не расширяемый или свойства не существует.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[HasProperty]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> Boolean</td>
                            
                            <td>Возвращает булевское значение, указывая, имеет ли данный объект собственное, или наследуемое свойство, ключ которого - <em>propertyKey</em> (<strong>true</strong>), или не имеет (<strong>false</strong>).</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Get]]</td>
                             
                            <td>(<em>propertyKey, Receiver</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Возвращает значение свойства объекта (ключ свойства - <em>propertyKey</em>). Если для того, чтобы извлечь значение свойства, нужно выполнить код ECMAScript, аргумент <em>Receiver</em> используется как значение <strong>this</strong>.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Set]]</td>
                             
                            <td>(<em>propertyKey, value, Receiver</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Записывает значение, что соответсвует второму аргументу (<em>value</em>), свойству с ключом <em>propertyKey</em>. Если для того, чтобы записать значение свойства, нужно выполнить код ECMAScript, аргумент <em>Receiver</em> используется как значение <strong>this</strong>. Возвращает <strong>true</strong>, если значение свойства было записано, а в противном случае - <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Delete]]</td>
                             
                            <td>(<em>propertyKey</em>) <span>&#8594;</span> <em>Boolean</em></td>
                            
                            <td>Удаляет собственное свойство, ключ которого это <em>propertyKey</em>, из объекта. Возвращает <strong>false</strong>, если свойство не было удалено и все еще находится в объекте, и <strong>true</strong>, если оно было удалено и не находится в объекте. Если свойство не настраиваемое ([[Configurable]] <span>&#8594;</span> <strong>false</strong>), тогда этот метод вернет <strong>false</strong>.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[OwnPropertyKeys]]</td>
                             
                            <td>() <span>&#8594;</span> <em>List of properties</em></td>
                            
                            <td>Возвращает список, элементами которого есть все ключи значений собственных свойств объекта.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Существуют еще <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-6">дополнительные</a> внутренние методы для объектов. Объект функции поддерживает внутренний метод вызова ([[Call]]), а конструктор это функция, что поддерживает внутренний метод построения ([[Construct]]).</p>
                    
                    <table>
                        
                        <caption>Дополнительные важные внутренние свойства объектов функции</caption>
                        
                        <colgroup>
                           
                            <col />
                            
                            <col />
                            
                        </colgroup>
                        
                        <tr>
                            
                            <th>Внутренний метод</th>
                            
                            <th>Запись, описывающая модель вызова</th>
                            
                            <th>Описание</th>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Call]]</td>
                            
                            <td>(<em>any, a List of any</em>) <span>&#8594;</span> <em>any</em></td>
                            
                            <td>Выполняет код (тот, что внутри функции), связанный с объектом. Вызывается через выражение вызова функции. Аргументами внутреннего метода есть <strong>this</strong> значение и список, что содержит аргументы, которые были переданы функции через выражение вызова. Объекты, что реализовывают этот метод, вызываемые. В общем, берет аргументы функции, выполняет код в контексте конкретного объекта, который соответствует значению <strong>this</strong>, и возвращает результат.</td>
                            
                        </tr>
                        
                        <tr>
                           
                            <td>[[Construct]]</td>
                             
                            <td>(<em>a List of any, Object</em>) <span>&#8594;</span> <em>Object</em></td>
                            
                            <td>Создает новый объект. Вызывается через операторы <strong>new</strong> и <strong>super</strong>. Первый аргумент этого метода это список из аргументов, что передаются выражению вызова конструктора через какой-то из операторов. Второй - объект, к которому первоначально применяется оператор <strong>new</strong>. Объекты, что реализовывают этот метод, называются конструкторами. В общем, этот метод берет список аргументов, как значения для свойств, и создает новый объект, прототипом которого является <em>Object</em> во втором аргументе.</td>
                            
                        </tr>
                        
                    </table>
                    
                    <p>Если какой-то из внутренних методов объекта не поддерживается реализацией, тогда выскочит <strong>TypeError</strong>.</p>
                    
                </article>
                
                <p>У внутренних методов объектов есть <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-invariants-of-the-essential-internal-methods">признаки</a>, которые наведены в спецификации.</p>
                
                <p>Существует еще кучища известных встроенных объектов, и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-well-known-intrinsic-objects">тут</a> дается их перечень.</p>
               
           </section>
           
       </section>
       
       <section>
           
           <header class="header">
               
               <h3><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-ecmascript-specification-types">Типы спецификации ECMAScript</a></h3>
               
           </header>
           
           <p>Существуют еще скрытые типы, которые используются внутри языка. При выполнении вычслений запускаются внутренние алгоритмы, которые используют значения, что относятся к скрытым типам. Значения этих типов используются внутри алгоритмов для описания семантики конструкций и типов ECMAScript, о которых упоминалось выше. К скрытым типам относятся Ссылка (Reference), Список (List), Завершение (Completion), Описание свойства (Property Descriptor), Лексическое окружение (Lexical Environment), Запись об окружении (Environment Record) и Блок данных (Data Block). Значения, что относятся к этим типам, являются "артефактами" и не могут хранится в свойствах объекта или в переменных ECMAScript.</p>
           
           <article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-list-and-record-specification-type">Типы списка и записи</a></h4>
                   
               </header>
               
               <p>Тип для списка используется, чтобы обьяснить определения списков из аргументов в выражениях оператора <strong>new</strong>, в вызовах функциий и в других алгоритмах, где нужен простой упорядоченный список. Список является просто упорядоченной последовательностью элементов, которые содержат конкретные значения.</p>
               
               <p>Тип для записи используется, чтобы обьяснить агрегацию (обьединение) данных внутри алгоритмов. Данный тип содержит одно или более именованных полей. Значение каждого поля это либо значение ECMAScript, либо абстрактное значение. Имена полей используются для определения конкретных разновидностей агрегации.</p>
               
               <article>
               
                   <header class="header header--center">

                       <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completion-record-specification-type">Тип записи выполнения</a></h4>

                   </header>

                   <p>Тип записи выполнения используется, чтобы обьяснить распостранение значений внутри своей среды и порядок, в котором осуществляется поведение инструкций (<strong>break</strong>, <strong>continue</strong>, <strong>return</strong> и <strong>throw</strong>), что выполняют нелокальную передачу контроля.</p>

                   <p>Значения и поля типа для записи выполнения определены <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#table-8">ниже</a>:</p>

                   <table>

                            <caption>Поля записи выполнения</caption>

                            <colgroup>

                                <col />

                                <col />

                            </colgroup>

                            <tr>

                                <th>Поле</th>

                                <th>Значение</th>

                                <th>Смысл</th>

                            </tr>

                            <tr>

                                <td>[[Type]]</td>

                                <td>одно из значений <strong>normal</strong>, <strong>return</strong>, <strong>break</strong>, <strong>continue</strong> или <strong>throw</strong></td>

                                <td>Тип выполнения</td>

                            </tr>

                            <tr>

                                <td>[[Value]]</td>

                                <td>любое значение ECMAScript или <strong>empty</strong></td>

                                <td>Созданное значение</td>

                            </tr>

                            <tr>

                                <td>[[Target]]</td>

                                <td>любая строка ECMAScript или <strong>empty</strong></td>

                                <td>Метка передачи контроля</td>

                            </tr>

                        </table>

               </article>
               
           </article>
           
           <!--<article>
               
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-set-and-relation-specification-type">Типы набора и отношения</a></h4>
                   
               </header>
               
               <p>Тип для набора используется, чтобы обьяснить собрание неупорядоченных элементов для использования в модели памяти. Хитромудятину про модель памяти я разбирать не особо намерен.</p>
               
               <p>Тип для отношений используется, чтобы обьяснить ограничения в наборе.</p>
               
           </article>-->
           
           <section>
               
               <header class="header">
                   
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-reference-specification-type">Тип ссылки</a></h4>
                   
               </header>
               
               <p>Тип для ссылки используется, чтобы обьяснить поведение операторов <strong>delete</strong>, <strong>typeof</strong>, <strong>super</strong>, назначения и других фичей языка, где без ссылки не обойтись.</p>
               
               <p>Ссылка это обработанное имя или привязка свойства. Она состоит из трех компонентов (ссылка, что выражается через оператор <strong>super</strong>, состоит из четырех):</p>
               
               <ol class="list">
                   
                   <li>базового значения;</li>
                   
                   <li>имени, на которое ссылаются;</li>
                   
                   <li>и признака состояния строгости ссылки;</li>
                   
                   <li>в ссылке, что выражается через оператор <strong>super</strong>, имеется еще дополнительный компонент, что указывает на значение <strong>this</strong> - <em>thisValue</em>.</li>
                   
               </ol>
               
               <p>Базовое значение принимает <em>undefined</em>, объект, булевское значение, строку, символ, число, или запись окружения (компонент базового значения ссылки, что выражается через оператор <strong>super</strong>, не принимает в себе запись окружения). Если базовое значение <em>undefined</em>, это указывает на то, что ссылка не может быть обработана в качестве привязки. Имя, на которое ссылаются, это либо строка, либо символ.</p>
               
               <p>Для работы с ссылкой используются некоторые абстрактные операции. Их важно рассмотреть, поскольку необходимо понимать, как значения излекаются и перезыписываются, когда на них ссылаются.</p>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-getvalue"><em>GetValue(V)</em></a></h4>
                       
                   </header>
                   
                   <p>Абстрактная операция <strong><em>GetValue(V)</em></strong> применяется, когда по ссылке должно быть извлечено значение.</p>
                   
                   <ol class="list">
                       
                       <li>Первый шаг это выполнение операции <strong>ReturnIfAbrupt(V)</strong>, что возвращает запись выполнения для значения <strong>V</strong> (тип выполнения в данном случае будет <em>return</em>).</li>
                       
                       <li>Далее проверяется тип значения <strong>V</strong> - <strong>Type(V)</strong>. Если значение <strong>V</strong> это не ссылка, тогда оно возвращается и на этом выполнение алгоритма закончится.</li>
                       
                       <li>В случае, когда значение <strong>V</strong> это ссылка, тогда будет выполнена операция <strong>GetBase(V)</strong>, которая возвращает базовое значение ссылки (<strong>base</strong>).</li>
                       
                       <li>После возвращения базового значения ссылки (<strong>base</strong>) идет проверка ее разрешаемости: настает время для операции <strong>IsUnresolvableReference(V)</strong>. Если базовое значение ссылки это <strong>undefined</strong>, тогда <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>, что станет причиной для <strong>ReferenceError</strong> и на этом выполнение алгоритма закончится. В другом случае <strong>IsUnresolvableReference(V)</strong> вернет <strong>false</strong> и выполнение алгоритма потопает дальше.</li>
                       
                       <li>Пройдя предыдущий этап, выполняется операция <strong>IsPropertyReference(V)</strong>. Эта операция вернет <strong>true</strong>, когда подтвердится одно из двух условий: либо базовое значение ссылки (<strong>base</strong>) имеет тип <em>Object</em> (т.е. является объектом), либо оно относится к одному из примитивных типов <em>Boolean, String, Symbol или Number</em> (без <em>Undefined и Null</em>).
                       
                           <ol class="list" type="a">
                               
                               <li>Принадлежность базового значения ссылки (<strong>base</strong>) к примитивному типу проверяется с помощью операции <strong>HasPrimitiveBase(V)</strong>. Если <strong>HasPrimitiveBase(V)</strong> возвращает <strong>true</strong>, это говорит о том, что базовое значение ссылки (<strong>base</strong>) имеет примитивный тип, и тогда оно будет превращено в соответствующий примитивному типу объект. Такое превращение сделает операция <a href="#toobject"><strong>ToObject(base)</strong></a>. Это необходимо для дальнейшего выполнения метода <strong>[[Get]]</strong>.</li>
                               
                               <li>Когда базовое значение ссылки (<strong>base</strong>) имеет тип <em>Object</em>, тогда алгоритм запустит внутренний метод <em>[[Get]]</em>. Имя ключа свойства объекта, на которое ссылаются, возвращает операция <strong>GetReferencedName(V)</strong>, а значение <strong>this</strong> для определения контекста выполнения - операция <a href="#getthisvalue"><strong>GetThisValue(V)</strong></a>. Итак, мы получим <strong><em>base.[[Get]](GetReferencedName(V), GetThisValue(V))</em></strong>.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернула <strong>false</strong>, тогда алгоритм приступит к последнему шагу. На этом этапе алгоритму ничего не остается, как признать базовое значение ссылки записью окружения (<strong>Environment Record</strong>). Для записи окружения будет применен внутренний метод <a href="#getbindingvalue"><strong>GetBindingValue(N, S)</strong></a>, который возвращает значение привязки. Он получает имя привязки, на которое ссылаются (его возвращает операция <strong>GetReferencedName(V)</strong>), и булевское значение, которое будет либо <strong>true</strong>, либо <strong>false</strong> в зависимости от того, строгая ли данная привязка, или нет (этот признак возвращается с помощью операции <strong>IsStrictReference(V)</strong>, что определяет строгость семантики ссылки). В конечном итоге будет выполнено: <strong><em>base.GetBindingValue(GetReferencedName(V), IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                      
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/#sec-putvalue"><em>PutValue(V, W)</em></a></h4>
                       
                   </header>
                   
                   <p>Алгоритм тут выполняет запись другог значения вместо текущего. Операции <strong><em>PutValue(V, W)</em></strong> передаются текущее значение (<strong>V</strong>) и то, которое его заменит (<strong>W</strong>).</p>
                   
                   <ol class="list">
                      
                       <li>Сперва алгоритм выполнит <strong>ReturnIfAbrupt(V)</strong> для начального значения.</li>
                       
                       <li>Затем для значения, которое заменит текущее - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>После получения этих двух записей алгоритм проверит тип текущего значения <strong>V</strong> - <strong>Type(V)</strong>, - чтобы определить, является ли оно ссылкой. Если нет, тогда программа выкинет <strong>ReferenceError</strong>, закончив дальнейшее выполнение алгоритма (невозможно перезаписать текущее значение, если на него нельзя сослаться).</li>
                       
                       <li>Получив подтверждение того, что <strong>V</strong> это ссылка, вернем базовое значение (<strong>base</strong>) с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Теперь алгоритм проверит разрешаемость ссылки с помощью операции <strong>IsUnresolvableReference(V)</strong>. Когда у ссылки базовое значение <strong>undefined</strong>, <strong>IsUnresolvableReference(V)</strong> вернет <strong>true</strong>. 
                          
                           <ol class="list" type="a">
                              
                               <li>Если разигрывется такой сценарий, тогда еще подключится проверка строгости ссылки с помощью операции <strong>IsStrictReference(V)</strong> (она определяет, имеет ли ссылка строгую семантику, или нет). Если <strong>IsStrictReference(V)</strong> вернет <strong>true</strong>, это выкинет <strong>ReferenceError</strong>, ведь строгая семантика ссылки при отсуствии в ней значения - это несовместимое сочетание.</li>
                               
                               <li>В другом случае, когда семантика не является строгой и <strong>IsStrictReference(V)</strong> вернет <strong>false</strong>, тогда алгоритм выполнит операцию записи <strong>Set</strong>. Для этого ему нужно выудить глобальный объект (<strong>globalObj</strong>), который будет использоваться в качестве целевого. Это выполнит операция <strong>GetGlobalObject()</strong>.</li>
                               
                               <li>Обращение к глобальному объекту (<strong>globalObj</strong>) исходит из того, что он является пристанищем всех ссылок, которые находятся в его области видимости, в виде свойств. Потому берется имя ссылки (как ключ свойства), которое возвращает <strong>GetReferencedName(V)</strong>, и выполняется операция записи <strong>Set(globalObj, GetReferencedName(V), W, false)</strong>, которая запишет новое значение <strong>W</strong> вместо <strong>undefined</strong> для целевого глобального объекта (<strong>globalObj</strong>) в его контексте выполнения. Булевское значение <strong>false</strong> (последний аргумент в списке) это признак строгости ссылки.</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если <strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>, это говорит о том, что базовое значение ссылки имеет в себе значение иное от <strong>undefined</strong> и дальше нужно осуществить проверку, к какому типу оно принадлежит. Это сделает операция <strong>IsPropertyReference(V)</strong>.
                       
                           <ol class="list" type="a">
                               
                               <li>Эта проверка напоминает матрешку, поэтому будет еще выполнена операция <strong>HasPrimitiveBase(V)</strong>. Когда <strong>HasPrimitiveBase(V)</strong> вернет <strong>true</strong>, тогда примитивное базовое значение ссылки будет преобразовано в соответствующий примитивному типу (<em>Boolean, String, Symbol, или Number</em>) объект с помощью операции <a href="#toobject"><strong>ToObject(base)</strong></a>.</li>
                               
                               <li>В случае, когда <strong>HasPrimitiveBase(V)</strong> возвращает <strong>false</strong>, тогда базовое значение ссылки уже имеет тип Object. Получив базовое значение в виде объекта, оно может использоваться как целевой объект для внутреннего метода <strong>[[Set]]</strong>, который перезаписывает текущее значение. Он берет ключ свойства, что соответствует имени, на которое ссылаются (его вернет операция <strong>GetReferencedName(V)</strong>), и записывает ему новое значение <strong>W</strong> вместо текущего <strong>V</strong>, выполняя это в контексте значения <strong>this</strong> (его возвращает операция <strong>GetThisValue(V)</strong>). При успешном своем завершении метод <strong>[[Set]]</strong> вернет <strong>true</strong>. Тут еще подтянется проверка <strong>IsStrictReference(V)</strong>. На выходе это выглядит так: <strong><em>base.[[Set]](GetReferencedName(V), W, GetThisValue(V))</em></strong> (<em>succes</em>).</li>
                               
                               <li>При условии, когда внутрннему методу <strong>[[Set]]</strong> не удалось записать новое значение вместо текущего и он вернет <strong>false</strong>, а <strong>IsStrictReference(V)</strong> - <strong>true</strong>, тогда программа выкинет исключение <strong>TypeError</strong>.</li>
                               
                               <li>В остальном, вернется результат выполнения <strong>[[Set]]</strong> (<em>succes</em>).</li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Когда операция <strong>IsPropertyReference(V)</strong> вернет <strong>false</strong>, тогда алгоритм приступит к последнему шагу. На этом этапе базовое значение ссылки будет соответствовать записи окружения (<strong>Environment Record</strong>). К ней будет применен внутренний метод <strong>SetMutableBinding(N, V, S)</strong>, который записывает новое значение существующей привязке (ее имя вернет операция <strong>GetReferencedName(V)</strong>). Итогом будет выполнение операции: <strong><em>base.SetMutableBinding(GetReferencedName(V), W, IsStrictReference(V))</em></strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-getthisvalue">GetThisValue(V)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция возвращает значение <strong>this</strong>, что является объектом, который определяет контекст выполнения.</p>
                   
                   <ol class="list">
                      
                       <li>Обязательное утверждение: ссылка <strong>V</strong> это объект (<strong>IsPropertyReference(V)</strong> возвращает <strong>true</strong>).</li>
                       
                       <li>Затем проверяется, имеет ли ссылка <strong>V</strong> компонент <em>thisValue</em>: выполняется операция <strong>IsSuperReference(V)</strong>. Если она его имеет (<strong>IsSuperReference(V)</strong> будет <strong>true</strong>), тогда возвращается значение этого компонента в качестве <strong>this</strong>.</li>
                       
                       <li>Если предыдущая проверка не подтвердилась, тогда возращается базовое значение ссылки (алгоритм выполнит <strong>GetBase(V)</strong>), которое и будет текущим контекстом выполнения - <strong>this</strong>.</li>
                       
                   </ol>
                   
               </article>
               
               <!--<article>
                   
                   <header class="header header--center">
                       
                       <h4>Абстрактная операция <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-initializereferencedbinding">InitializeReferencedBinding(V, W)</a></h4>
                       
                   </header>
                   
                   <p>Эта операция записывает новое значение <strong>W</strong> существующей, при это не инициализированной привязке, на которую ссылаются, в записи окружения, которая является ссылкой.</p>
                   
                   <ol class="list">
                      
                       <li>Сначала возвращается запись для начального значения - <strong>ReturnIfAbrupt(V)</strong>.</li>
                       
                       <li>После этого возвращается запись для нового значения - <strong>ReturnIfAbrupt(W)</strong>.</li>
                       
                       <li>Обязательное утверждение: начальное значение <strong>V</strong> это ссылка, что подтверждает соответствующая проверка <strong>Type(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: ссылка является обрабатываемой (<strong>IsUnresolvableReference(V)</strong> возвращает <strong>false</strong>).</li>
                       
                       <li>Возвращается базовое значение ссылки с помощью операции <strong>GetBase(V)</strong>.</li>
                       
                       <li>Обязательное утверждение: базовое значение ссылки является записью окружения (<em>Environment Record</em>).</li>
                       
                       <li>И теперь возвращается операция <strong>base.InitializeBinding(<em>GetReferencedName(V), W</em>)</strong>. К записи окружения применяется внутренний метод <strong>InitializeBinding(N, V)</strong>, что записывает значение <strong>W</strong> для существующей, при это не инициализированной привязки в записи окружения, имя которой возвращает <strong>GetReferencedName(V)</strong>.</li>
                       
                   </ol>
                   
               </article>-->
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-property-descriptor-specification-type">Тип описания свойства</a></h4>
                   
               </header>
               
               <p>Тип описания свойства используется, что объяснить управление и воплощение атрибутов свойств объекта. Значениями типа описания свойств являются записи. Имя поля это имя атрибута, а значение поля - это соответствующее значение атрибута.</p>
               
               <p>Значения описания свойства в дальнейшем могут быть классифицированы как описание свойств данных и описание свойств доступа, что основаны на существовании или использовании определенных полей. Описание свойства данных включает в себя поля с именами <strong>[[Value]]</strong> и <strong>[[Writable]]</strong> (либо одно из них, либо оба). Описание свойства доступа включает в себя поля с именами <strong>[[Get]]</strong> или <strong>[[Set]]</strong> (либо одно из них, либо оба). Каждое описание свойства имеет поля, имена которых <strong>[[Enumerable]]</strong> and <strong>[[Configurable]]</strong>. Есть еще общее и полное описание свойства, которое имеет все соответствующие поля.</p>
               
               <p>Существуют абстрактные операции для управления значениями описания свойства.</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isaccessordescriptor"><strong>IsAccessorDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства доступа.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isdatadescriptor"><strong>IsDataDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> описанием свойства данных.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-isgenericdescriptor"><strong>IsGenericDescriptor(Desc)</strong></a> проверяет, является ли описание <strong>Desc</strong> общим описанием свойства.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-frompropertydescriptor"><strong>FromPropertyDescriptor(Desc)</strong></a> записывает значения соответствующих полей свойствам с теми же именами, что создаются для объекта, у которого собственных свойств нет, и возвращает этот объект.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-topropertydescriptor"><strong>ToPropertyDescriptor(Obj)</strong></a> возвращает описание свойства, у которого изначально не было соответствующих полей.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-completepropertydescriptor"><strong>CompletePropertyDescriptor(Desc)</strong></a> возвращает полное описание свойства в зависимости от его типа, у которого отсуствуют соответствующие поля, записывая им значения по умолчанию.</li>
                   
               </ul>
               
           </section>
           
           <p>Есть еще типы <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">записи окружения</a>, <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-lexical-environment-and-environment-record-specification-types">лексического окруженния</a> и <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-data-blocks">блоки данных</a>. Некоторые рассмотрим позже, а некоторые упустим.</p>
           
       </section>
       
   </section>
   
   <section>
      
       <header class="header">
          
           <h2><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-operations">Абстрактные операции</a></h2>
           
       </header>
       
       <p>Существуют абстрактные операции, которые описывают семантику языка.</p>
       
       <section>
          
           <header class="header">
              
               <h3><a href="https://www.ecma-international.org/ecma-262/#sec-type-conversion">Преобразование типов</a></h3>
               
           </header>
           
           <p>ECMAScript неявно выполняет автоматическое преобразование типов при необходимости. Абстрактные операции преобразования типов принимают значения любого типа ECMAScript (при этом они не работают со значениями, что относятся к скрытым внутренним типам языка) и они полиморфные.</p>
           
           <p>Рассмотрим эти абстрактные операции.</p>
           
           <section id="toprimitive">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive">ToPrimitive ( input [ , PreferredType ] )</a></h4>
                   
               </header>
               
               <p>Абстрактная операция <strong>ToPrimitive</strong> преобразовывает входящий аргумент <strong>input</strong> к типу, что не является <em>Object</em>. Объект может быть преобразован в более чем один примитивный тип, поэтому используется дополнительное указание <strong>PreferredType</strong>, чтобы ткнуть пальцем на предпочтительный тип для преобразования. Эта операция преобразования выполняется согласно такому алгоритму:</p>
               
               <ol class="list">
                  
                   <li>Сначала утверждается, что <strong>input</strong> это значение любого типа ECMAScript.</li>
                   
                   <li>Далее проверяется тип входящего аргумента <strong>input</strong> - <strong>Type(input)</strong>. Если выдает, что <strong>input</strong> принадлежит к типу <em>Object</em>, тогда алгоритм выполнит следующие шаги:
                   
                       <ol class="list" type="a">
                           
                           <li>Сперва алгоритм должен узнать, к какому примитивному типу следует преобразовать объект <strong>input</strong>. Если аргументу <strong>PreferredType</strong> не было передано никакого указания, тогда ему по умолчанию запишется <strong>"default"</strong>.</li>
                           
                           <li>Если же аргументу <strong>PreferredType</strong> было передано указание на тип строки (<em>String</em>), тогда ему запишется <strong>"string"</strong>.</li>
                           
                           <li>В случае, когда аргументу <strong>PreferredType</strong> было передано указание на тип числа (<em>Number</em>), тогда оно получит запись <strong>"number"</strong>.</li>
                           
                           <li>Когда вопрос с аргументом <strong>PreferredType</strong> решен, необходимо понять, с каким именно объектом алгоритм имеет дело: обычным или нет. <a href="https://www.ecma-international.org/ecma-262/#sec-built-in-exotic-object-internal-methods-and-slots">Необычные объекты</a> еще будут подробно рассматриваться. Если объект необычный, тогда алгоритм воспользуется операцией <strong>GetMethod(input, @@toPrimitive)</strong> (<em>exoticToPrim</em>). Сама по себе операция <strong>GetMethod (V, P)</strong> используется для получения значения свойства <strong>P</strong> объекта <strong>V</strong>. При этом данное значение не простое, а ожидаемое как функция. И если это значение не функция, тогда вылетит <strong>TypeError</strong>. В контексте этого алгоритма для операции <strong>GetMethod(input, @@toPrimitive)</strong> в итоге будет выполнено извлечение значения свойства (метода) с ключом <strong>@@toPrimitive</strong> целевого объекта <strong>input</strong>: <strong>input.[[Get]](@@toPrimitive, input)</strong>. Символ <strong>@@toPrimitive</strong> соответствует методу, который превращает объект в соответствующее примитивное значение (вызывается он абстрактной операцией <strong><em>ToPrimitive</em></strong>). 
                           
                               <p>Итак, значением свойства <strong>@@toPrimitive</strong> есть функция, что превращает объект символа в примитивное значение. У этой функции есть имя - <strong>"Symbol.toPrimitive"</strong>. Она так же принимает в качетсве аргумента указание на тип преобразования (<em>hint</em>). И если извлеченным значением <strong>@@toPrimitive</strong> является не <strong>undefined</strong>, тогда будет выполнено еще несколько шагов:</p>
                               
                               <ol class="list" type="i">
                                   
                                   <li>Та извлеченная функция метода <strong>@@toPrimitive</strong> (<em>exoticToPrim</em>) будет вызвана с помощью операции <strong> Call(exoticToPrim, input, "hint")</strong>. Эта операция используется для вызова извлеченной функции (<em>exoticToPrim</em>) в контексте выполнения объекта <strong>input</strong> с указанием на тип преобразования (<strong>"hint"</strong>) с помощью внутреннего метода <strong>[[Call]]</strong>. В итоге операция <strong>Set</strong> вернет: <strong>exoticToPrim.[[Call]](input, "hint")</strong>.</li>
                                   
                                   <li>Если результат выполнения извлеченной функции (<em>result</em>) выдержал проверку на не принадлежность к типу Object (<strong>Type(result)</strong>), тогда алгоритм вернет его,  окончив выполнение операции <strong><em>ToPrimitive</em></strong>.</li>
                                   
                                   <li>В противном случае вылетит птичка в виде <strong>TypeError</strong>.</li>
                                   
                               </ol>
                               
                            </li>
                            
                            <li>Если же объект обычный и в качестве указания аргумент <strong>PreferredType</strong> получил запись <strong>"default"</strong>, тогда это указание запишется к <strong>"number"</strong>. </li>
                            
                            <li>Когда объект является обычным, будет выполнена операция <a href="#ordinarytoprimitive"><strong>OrdinaryToPrimitive(input, hint)</strong></a>, что используется для преобразования обычных объектов в примитивное значение.</li>
                           
                       </ol>
                   
                   </li>
                   
                   <li>Если же проверка <strong>Type(input)</strong> выдает, что аргумент <strong>input</strong> не принадлежит к типу <em>Object</em>, алгоритм вернет его начальное значение.</li>
                   
               </ol>
               
               <p>Объекты типа <em>Date</em> и объекты символов (<em>Symbol</em>) единственные, которые переопределяют стандартное поведение операции <strong><em>ToPrimitive</em></strong>.</p>
               
               <p>Теперь не мешает разобрать, что представляет из себя абстрактная операция <strong>OrdinaryToPrimitive</strong>.</p>
               
               <article id="ordinarytoprimitive">
                   
                   <header class="header header--center">
                       
                       <h4><a href="https://www.ecma-international.org/ecma-262/#sec-ordinarytoprimitive">OrdinaryToPrimitive ( O, hint )</a></h4>
                       
                   </header>
                   
                   <p>Эта операция используется для преобразования обычных объектов в примитивное значение. Алгоритм тут состоит из следующих шагов:</p>
                   
                   <ol class="list">
                      
                       <li>Для начала объявляется, что аргумент <strong>O</strong> это значение, которое имеет тип <em>Object</em> (<strong>Type(O)</strong> <span>&#8594;</span> <em>Object</em>).</li>
                       
                       <li>Аргумент <strong>hint</strong> является указанием для преобразования, который принимает в качестве значения строку либо <strong>"string"</strong>, либо <strong>"number"</strong> (<strong>Type(hint)</strong> <span>&#8594;</span> <em>String</em>).</li>
                       
                       <li>Если указанию <strong>hint</strong> было передано значение <strong>"string"</strong> для преобразования объекта <strong>O</strong> в строку, тогда алгоритм получит список из имен внутренних методов (<em>methodNames</em>), которые имеют такую последовательность: <strong>" 'toString', 'valueOf' "</strong>.</li>
                       
                       <li>Если же <strong>hint</strong> получил в качестве значения <strong>"number"</strong> для преобразования объекта <strong>O</strong> в число, тогда последовательность методов (<em>methodNames</em>) будет обратная: <strong>" 'valueOf', 'toString' "</strong>.</li>
                       
                       <li>Для каждого имени метода (<em>name</em>) за порядком списка (<em>methodNames</em>) будут выполнены такие шаги:
                       
                           <ol class="list" type="a">
                               
                               <li>Имя (<em>name</em>) используется как указатель на метод для выполнения операции <strong>Get(O, name)</strong> (<em>method</em>), которая извлекает значение данного метода, возвращая <strong>O.[[Get]](name, O)</strong>. В целевом объекте <strong>O</strong> эти методы достаются из глобального объекта через наследование, что реализовано цепочкой прототипов.</li>
                               
                               <li>Получив значение соответствующего метода, алгоритм выполнит проверку того, является ли оно функцией с внутренним методом вызова <strong>[[Call]]</strong>. Это будет реализовано операцией <strong>IsCallable(method)</strong>. Если в результате выполнения она вернула <strong>true</strong>, тогда:
                               
                                   <ol class="list" type="i">
                                       
                                       <li>Данный метод будет вызван для целевого объекта <strong>O</strong>. Данный вызов выполнит операция <strong>Call(method, O)</strong> (<em>result</em>), что вернет: <strong>method.[[Call]](O)</strong>.</li>
                                       
                                       <li>Если полученный результат (<em>result</em>) не относится к типу <em>Object</em> (тут будет выполнена проверка <strong>Type(result)</strong>), тогда алгоритм вернет его.</li>
                                       
                                   </ol>
                               
                               </li>
                               
                           </ol>
                       
                       </li>
                       
                       <li>Если на предыдущем шаге случилась лажа (в моменте <em>5.b</em>), тогда вылетит <strong>TypeError</strong>.</li>
                       
                   </ol>
                   
                   <p>Итак, теперь важно понимать, какое значение имеет тут последовательность методов, когда алгоритм получил то, или иное указание для преобразования (<em>hint</em>). Когда указанию было передано значение <strong>"string"</strong>, сперва будет выполнен внутренний метод <strong>toString</strong>. Он возвращает строку формата <strong>"[object <em>tag</em>]"</strong>, где обозначением <em>tag</em> может быть: <strong>Undefined</strong>, <strong>Null</strong>, <strong>Array</strong>, <strong>String</strong>, <strong>Arguments</strong>, <strong>Function</strong>, <strong>Error</strong>, <strong>Boolean</strong>, <strong>Number</strong>, <strong>Date</strong>, <strong>RegExp</strong> и <strong>Object</strong>, - что зависит от особенностей объекта, к которому этот метод применяется. Вернув строку, очередь метода <strong>valueOf</strong> не наступит и алгоритм закончит свое выполнение.</p>
                   
                   <p>В случае, когда указанию (<em>hint</em>) было передано значение <strong>"number"</strong>, первым будет выполнен метод <strong>valueOf</strong>. Он возвращает операцию <strong>ToObject(O)</strong>, которая превращает в объект то значение, что было передано ему в аргументе. Получив результат выполнения <strong>valueOf</strong> (<em>result</em>), алгоритм повторит цикл для метода <strong>toString</strong>, который применится к объекту, что вернул предыдущий метод. А он уже вернет соответствующую строку, которая и будет использоваться для дальнейшего преобразования в число.</p>
                   
               </article>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toboolean">ToBoolean ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в булевский тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в булевское значение <strong>ToBolean</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>false</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Если в аргументе дано <strong>+0</strong>, <strong>-0</strong> или <strong>NaN</strong>, тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Если в аргументе дано пустую строку (имеет нулевую длину), тогда вернет <strong>false</strong>; в остальных случаях - вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Вернет <strong>true</strong>.</td>

                    </tr>

                </table>
               
           </section>
           
           <section id="tonumber">
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber">ToNumber ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в числовой тип. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в числовое значение <strong>ToNumber</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>NaN</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>+0</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет 1; в случае, когда <strong>false</strong> - вернет 0.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tonumber-applied-to-the-string-type">алгоритм преоразования</a>.</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint Number)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) уже и будет значением, переданным в аргументе операции <strong>ToNumber</strong> - вернет <strong>ToNumber(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Если аргументу было передано значение с типом <em>String</em>, что не может быть истолковано как числовой литерал, который дается в виде строки (<em>StringNumericLiteral</em>), тогда результатом выполнения операции <strong>ToNumber</strong> будет <strong>NaN</strong>. Итак, если строка, которую нужно преобразовать в число, имеет вид "трали-вали", тогда получим <strong>NaN</strong>. Если же строка является такой, что имеет вид десятичного, двоичного, восьмеричного или шестнадцатиричного числа, тогда она преобразуется в значение, что имеет тип <em>Number</em> ("123" <span>&#8594;</span> 123).</p>
                
                <p>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) имеет некоторые свои особенности, что отличают его от простого числового литерала (<em>NumericLiteral</em>):</p>
                
                <ul class="list">
                   
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя пробел, что начинает и/или завершает строку, и/или символы конца строки (т.е. " 123 " это норм и будет <span>&#8594;</span> 123).</li>
                    
                    <li>Десятичному числовому литералу в виде строки (<em>StringNumericLiteral</em>) может предшествовать любое количество нулей (т.е. "000000123" <span>&#8594;</span> 123, а это говорит о том, что нули являются незначительными).</li>
                    
                    <li>Десятичный числовой литерал в виде строки (<em>StringNumericLiteral</em>) может включать в себя <strong>+ / -</strong>, чтобы указать свой знак (т.е. "-123" <span>&#8594;</span> -123).</li>
                    
                    <li>Числовой литерал в виде строки (<em>StringNumericLiteral</em>), которая является пустой или имеет в себе только пробел, преобразовывется в <strong>+0</strong> (т.е. " " <span>&#8594;</span> 0).</li>
                    
                    <li>Значения <strong>Infinity</strong> и <strong>-Infinity</strong> распознаются как числовой литерал в виде строки (<em>StringNumericLiteral</em>), а не как просто числовой литерал (<em>NumericLiteral</em>), и преобразовывается в настолько огромедное число (10<sup>10000</sup>), что округляется к <strong>+&#8734;</strong> или <strong>-&#8734;</strong>.</li>
                    
                </ul>
                
                <p>Динамическая семантика преобразования того значения, что сидит в строке, к типу <em>Number</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-runtime-semantics-mv-s"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tostring">ToString ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) в строку. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в строку <strong>ToString</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Вернет <strong>"undefined"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Вернет <strong>"null"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Если в аргументе булевское <strong>true</strong>, тогда вернет <strong>"true"</strong>; в случае, когда <strong>false</strong> - вернет <strong>"false"</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Тут существует свой <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type">алгоритм преоразования</a> (вот, к примеру, <strong>NaN</strong> <span>&#8594;</span> <strong>"NaN"</strong>, <strong>+0 / -0</strong> <span>&#8594;</span> <strong>"0"</strong>, а <strong>+&#8734;</strong> <span>&#8594;</span> <strong>"Infinity"</strong>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Вернет свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Вылетит птичка <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Тут для преобразования будет выполнено две операции:
                        
                            <ol class="list">
                               
                                <li><a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a></li>
                                
                                <li>и затем результат выполнения предыдущей операции (<em>primValue</em>) уже и будет значением, переданным в аргументе операции <strong>ToString</strong> - вернет <strong>ToString(primValue)</strong>.</li>
                                
                            </ol>
                        
                        </td>

                    </tr>

                </table>
                
                <p>Динамическая семантика преобразования числа к типу <em>String</em> подробно дается <a href="https://www.ecma-international.org/ecma-262/#sec-tostring-applied-to-the-number-type"><strong>тут</strong></a>.</p>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-toobject">ToObject ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает значение в своем аргументе (<em>argument</em>) к типу <em>Object</em>. К каждому входящему типу значения аргумента применяется соответствующее преобразование:</p>
               
               <table>

                    <caption>Преобразования в объект <strong>ToObject</strong></caption>

                    <colgroup>

                        <col />

                        <col />

                    </colgroup>

                    <tr>

                        <th>Тип аргумента</th>

                        <th>Исходящий результат</th>

                    </tr>

                    <tr>

                        <td><em>Undefined</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Null</em></td>

                        <td>Выкинет <strong>TypeError</strong>.</td>

                    </tr>

                    <tr>

                        <td><em>Boolean</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-boolean-objects">булевский объект</a>, чей внутренний слот <strong>[[BooleanData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Number</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-number-objects">числовой объект</a>, чей внутренний слот <strong>[[NumberData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>String</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-string-objects">строковый объект</a>, чей внутренний слот <strong>[[StringData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Symbol</em></td>

                        <td>Возвращает новый <a href="https://www.ecma-international.org/ecma-262/#sec-symbol-objects">объект символа</a>, чей внутренний слот <strong>[[SymbolData]]</strong> записывается к аргументу (<em>argument</em>).</td>

                    </tr>

                    <tr>

                        <td><em>Object</em></td>

                        <td>Возвращает свой же аргумент (<em>argument</em> без преобразования).</td>

                    </tr>

                </table>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tointeger">ToInteger ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое числовое значение. Её алгоритм такой:</p>
               
               <ol class="list">
                  
                   <li>Сначала будет выполнена операция, что возвращает число - <a href="#tonumber"><strong>ToNumber(argument)</strong></a>.</li>
                   
                   <li>Если результат выполнения предыдущей операции (<em>number</em>) это <strong>NaN</strong>, тогда вернется ноль <strong>+0</strong>.</li>
                   
                   <li>Если результатом выполнения операции <a href="#tonumber"><strong>ToNumber(argument)</strong></a> (<em>number</em>) будет <strong>+0</strong>, <strong>-0</strong>, <strong>+&#8734;</strong> или <strong>-&#8734;</strong>, тогда он же (<em>number</em>) и вернется.</li>
                   
                   <li>В остальных случаях будет возвращатся число со своим знаком (<em>number</em>) и сводится его к абсолютному значению через выполнение <strong>floor(abs(number))</strong>. Разберем по порядку:
                   
                       <ol class="list" type="a">
                           
                           <li>Математическая функция <strong>abs(number)</strong> выдает абсолютное значение числа (<em>number</em>).</li>
                           
                           <li>Затем эта абсолютная величина округляется к наибольшему целому числу, которое при этом не больше входящего значения <strong>abs(number)</strong> - эту выдачу обеспечивает операция <strong>floor</strong> (т.е. 5.66666 тут будет <span>&#8594;</span> 5).</li>
                           
                       </ol>
                   
                   </li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-topropertykey">ToPropertyKey ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в то значение, которое может быть использовано в качестве ключа свойства. Алгоритм тут следующий:</p>
               
               <ol class="list">
                  
                  <li>Первое, что выполняется, это операция, которая сводит входящий аргумент (<em>argument</em>) к примитивному значению - <a href="#toprimitive"><strong>ToPrimitive(argument, hint String)</strong></a>. Это полученное примитивное значение и будет ключом свойства (<em>key</em>).</li>
                  
                  <li>Если полученный ключ является символом (<strong>Type(key)</strong> <span>&#8594;</span> <em>Symbol</em>), тогда вернется этот символ как ключ свойства.</li>
                  
                  <li>В случае же, когда ключ свойства это не символ, тогда полученное примитивное значение, которое родилось на первом этапе (<em>key</em>), попадет в лапы операции, что трансформирует его и наверняка вернет строку - <a href="#tostring"><strong>ToString(key)</strong></a>. Она и будет ключом свойства. Вуа-ля.</li> 

               </ol>
               
           </section>
           
           <section>
              
               <header class="header">
                  
                   <h4><a href="https://www.ecma-international.org/ecma-262/#sec-tolength">ToLength ( argument )</a></h4>
                   
               </header>
               
               <p>Эта операция преобразовывает свой аргумент (<em>argument</em>) в целое число, которое в дальнейшем используется как длина (число элементов) массива. Алгоритм выполнения данной операции:</p>
               
               <ol class="list">
                  
                  <li>Для начала необходимо вернуть целое число (<em>len</em>), чем и займется операция <a href="#tointeger"><strong>ToInteger(argument)</strong></a>.</li>
                  
                  <li>Если полученный результат (<em>len</em>) меньше или равен нулю (<em>len</em> <span>&#8804;</span> <strong>+0</strong>), тогда вернется ноль <strong>+0</strong>.</li>
                  
                  <li>А если полученное число больше нуля, тогда оно и вернется. Вот только не так просто, а через функцию <strong>min(<em>len</em>, 2<sup>53</sup>-1)</strong>, которая возвращает наименьшее число в данном диапазоне. Диапазон тут дается потому, что длина массива (<em>len</em>) не может быть больше 2<sup>53</sup>-1.</li>

               </ol>
               
           </section>
           
           <div>
              
               <p>Существует еще целый набор абстрактных операций, которые производят преобразование входящего значения. Кратко перечислим:</p>
               
               <ul class="list">
                  
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toindex"><strong>ToIndex ( value )</strong></a> - эта операция возвращает корректное целое число для индекса.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-canonicalnumericindexstring"><strong>CanonicalNumericIndexString ( argument )</strong></a> - эта операция возвращает числовое значение, если оно является строковым представлением числа, произведенного операцией <a href="#tostring"><strong>ToString</strong></a>, или строкой <strong>"-0"</strong>. В ином случае вернет <strong>undefined</strong>.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint32"><strong>ToInt32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от -2<sup>31</sup> до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint32"><strong>ToUint32 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>32</sup> целочисленных значений в диапазоне от 0 до 2<sup>31</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint16"><strong>ToInt16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от -32768 до 32767 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint16"><strong>ToUint16 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>16</sup> целочисленных значений в диапазоне от 0 до 2<sup>16</sup> - 1 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-toint8"><strong>ToInt8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от -128 до 127 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8"><strong>ToUint8 ( argument )</strong></a> - эта операция преобразовывает входящее значение в аргументе в одно из 2<sup>8</sup> целочисленных значений в диапазоне от 0 до 255 включительно.</li>
                   
                   <li><a href="https://www.ecma-international.org/ecma-262/#sec-touint8clamp"><strong>ToUint8Clamp ( argument )</strong></a> - то же определение, что и в предыдущей операции, только с измененным алгоритмом выполнения.</li>
                   
               </ul>
               
           </div>
           
       </section>
       
   </section>
    
</body>
</html>